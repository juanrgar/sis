This is bfd.info, produced by makeinfo version 4.8 from bfd.texi.

INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* Bfd: (bfd).                   The Binary File Descriptor library.
END-INFO-DIR-ENTRY

   This file documents the BFD library.

   Copyright (C) 1991-2018 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License" and "Funding Free
Software", the Front-Cover texts being (a) (see below), and with the
Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled "GNU Free Documentation License".

   (a) The FSF's Front-Cover Text is:

   A GNU Manual

   (b) The FSF's Back-Cover Text is:

   You have freedom to copy and modify this GNU Manual, like GNU
software.  Copies published by the Free Software Foundation raise
funds for GNU development.


File: bfd.info,  Node: Top,  Next: Overview,  Prev: (dir),  Up: (dir)

   This file documents the binary file descriptor library libbfd.

* Menu:

* Overview::			Overview of BFD
* BFD front end::		BFD front end
* BFD back ends::		BFD back ends
* GNU Free Documentation License::  GNU Free Documentation License
* BFD Index::		BFD Index


File: bfd.info,  Node: Overview,  Next: BFD front end,  Prev: Top,  Up: Top

1 Introduction
**************

BFD is a package which allows applications to use the same routines to
operate on object files whatever the object file format.  A new object
file format can be supported simply by creating a new BFD back end and
adding it to the library.

   BFD is split into two parts: the front end, and the back ends (one
for each object file format).
   * The front end of BFD provides the interface to the user. It manages
     memory and various canonical data structures. The front end also
     decides which back end to use and when to call back end routines.

   * The back ends provide BFD its view of the real world. Each back
     end provides a set of calls which the BFD front end can use to
     maintain its canonical form. The back ends also may keep around
     information for their own use, for greater efficiency.

* Menu:

* History::			History
* How It Works::		How It Works
* What BFD Version 2 Can Do::	What BFD Version 2 Can Do


File: bfd.info,  Node: History,  Next: How It Works,  Prev: Overview,  Up: Overview

1.1 History
===========

One spur behind BFD was the desire, on the part of the GNU 960 team at
Intel Oregon, for interoperability of applications on their COFF and
b.out file formats.  Cygnus was providing GNU support for the team, and
was contracted to provide the required functionality.

   The name came from a conversation David Wallace was having with
Richard Stallman about the library: RMS said that it would be quite
hard--David said "BFD".  Stallman was right, but the name stuck.

   At the same time, Ready Systems wanted much the same thing, but for
different object file formats: IEEE-695, Oasys, Srecords, a.out and 68k
coff.

   BFD was first implemented by members of Cygnus Support; Steve
Chamberlain (`sac@cygnus.com'), John Gilmore (`gnu@cygnus.com'), K.
Richard Pixley (`rich@cygnus.com') and David Henkel-Wallace
(`gumby@cygnus.com').


File: bfd.info,  Node: How It Works,  Next: What BFD Version 2 Can Do,  Prev: History,  Up: Overview

1.2 How To Use BFD
==================

To use the library, include `bfd.h' and link with `libbfd.a'.

   BFD provides a common interface to the parts of an object file for a
calling application.

   When an application successfully opens a target file (object,
archive, or whatever), a pointer to an internal structure is returned.
This pointer points to a structure called `bfd', described in `bfd.h'.
Our convention is to call this pointer a BFD, and instances of it
within code `abfd'.  All operations on the target object file are
applied as methods to the BFD.  The mapping is defined within `bfd.h'
in a set of macros, all beginning with `bfd_' to reduce namespace
pollution.

   For example, this sequence does what you would probably expect:
return the number of sections in an object file attached to a BFD
`abfd'.

     #include "bfd.h"

     unsigned int number_of_sections (abfd)
     bfd *abfd;
     {
       return bfd_count_sections (abfd);
     }

   The abstraction used within BFD is that an object file has:

   * a header,

   * a number of sections containing raw data (*note Sections::),

   * a set of relocations (*note Relocations::), and

   * some symbol information (*note Symbols::).
   Also, BFDs opened for archives have the additional attribute of an
index and contain subordinate BFDs. This approach is fine for a.out and
coff, but loses efficiency when applied to formats such as S-records and
IEEE-695.


File: bfd.info,  Node: What BFD Version 2 Can Do,  Prev: How It Works,  Up: Overview

1.3 What BFD Version 2 Can Do
=============================

When an object file is opened, BFD subroutines automatically determine
the format of the input object file.  They then build a descriptor in
memory with pointers to routines that will be used to access elements of
the object file's data structures.

   As different information from the object files is required, BFD
reads from different sections of the file and processes them.  For
example, a very common operation for the linker is processing symbol
tables.  Each BFD back end provides a routine for converting between
the object file's representation of symbols and an internal canonical
format. When the linker asks for the symbol table of an object file, it
calls through a memory pointer to the routine from the relevant BFD
back end which reads and converts the table into a canonical form.  The
linker then operates upon the canonical form. When the link is finished
and the linker writes the output file's symbol table, another BFD back
end routine is called to take the newly created symbol table and
convert it into the chosen output format.

* Menu:

* BFD information loss::	Information Loss
* Canonical format::		The BFD	canonical object-file format


File: bfd.info,  Node: BFD information loss,  Next: Canonical format,  Up: What BFD Version 2 Can Do

1.3.1 Information Loss
----------------------

_Information can be lost during output._ The output formats supported
by BFD do not provide identical facilities, and information which can
be described in one form has nowhere to go in another format. One
example of this is alignment information in `b.out'. There is nowhere
in an `a.out' format file to store alignment information on the
contained data, so when a file is linked from `b.out' and an `a.out'
image is produced, alignment information will not propagate to the
output file. (The linker will still use the alignment information
internally, so the link is performed correctly).

   Another example is COFF section names. COFF files may contain an
unlimited number of sections, each one with a textual section name. If
the target of the link is a format which does not have many sections
(e.g., `a.out') or has sections without names (e.g., the Oasys format),
the link cannot be done simply. You can circumvent this problem by
describing the desired input-to-output section mapping with the linker
command language.

   _Information can be lost during canonicalization._ The BFD internal
canonical form of the external formats is not exhaustive; there are
structures in input formats for which there is no direct representation
internally.  This means that the BFD back ends cannot maintain all
possible data richness through the transformation between external to
internal and back to external formats.

   This limitation is only a problem when an application reads one
format and writes another.  Each BFD back end is responsible for
maintaining as much data as possible, and the internal BFD canonical
form has structures which are opaque to the BFD core, and exported only
to the back ends. When a file is read in one format, the canonical form
is generated for BFD and the application. At the same time, the back
end saves away any information which may otherwise be lost. If the data
is then written back in the same format, the back end routine will be
able to use the canonical form provided by the BFD core as well as the
information it prepared earlier.  Since there is a great deal of
commonality between back ends, there is no information lost when
linking or copying big endian COFF to little endian COFF, or `a.out' to
`b.out'.  When a mixture of formats is linked, the information is only
lost from the files whose format differs from the destination.


File: bfd.info,  Node: Canonical format,  Prev: BFD information loss,  Up: What BFD Version 2 Can Do

1.3.2 The BFD canonical object-file format
------------------------------------------

The greatest potential for loss of information occurs when there is the
least overlap between the information provided by the source format,
that stored by the canonical format, and that needed by the destination
format. A brief description of the canonical form may help you
understand which kinds of data you can count on preserving across
conversions.  

_files_
     Information stored on a per-file basis includes target machine
     architecture, particular implementation format type, a demand
     pageable bit, and a write protected bit.  Information like Unix
     magic numbers is not stored here--only the magic numbers' meaning,
     so a `ZMAGIC' file would have both the demand pageable bit and the
     write protected text bit set.  The byte order of the target is
     stored on a per-file basis, so that big- and little-endian object
     files may be used with one another.

_sections_
     Each section in the input file contains the name of the section,
     the section's original address in the object file, size and
     alignment information, various flags, and pointers into other BFD
     data structures.

_symbols_
     Each symbol contains a pointer to the information for the object
     file which originally defined it, its name, its value, and various
     flag bits.  When a BFD back end reads in a symbol table, it
     relocates all symbols to make them relative to the base of the
     section where they were defined.  Doing this ensures that each
     symbol points to its containing section.  Each symbol also has a
     varying amount of hidden private data for the BFD back end.  Since
     the symbol points to the original file, the private data format
     for that symbol is accessible.  `ld' can operate on a collection
     of symbols of wildly different formats without problems.

     Normal global and simple local symbols are maintained on output,
     so an output file (no matter its format) will retain symbols
     pointing to functions and to global, static, and common variables.
     Some symbol information is not worth retaining; in `a.out', type
     information is stored in the symbol table as long symbol names.
     This information would be useless to most COFF debuggers; the
     linker has command-line switches to allow users to throw it away.

     There is one word of type information within the symbol, so if the
     format supports symbol type information within symbols (for
     example, COFF, Oasys) and the type is simple enough to fit within
     one word (nearly everything but aggregates), the information will
     be preserved.

_relocation level_
     Each canonical BFD relocation record contains a pointer to the
     symbol to relocate to, the offset of the data to relocate, the
     section the data is in, and a pointer to a relocation type
     descriptor. Relocation is performed by passing messages through
     the relocation type descriptor and the symbol pointer. Therefore,
     relocations can be performed on output data using a relocation
     method that is only available in one of the input formats. For
     instance, Oasys provides a byte relocation format.  A relocation
     record requesting this relocation type would point indirectly to a
     routine to perform this, so the relocation may be performed on a
     byte being written to a 68k COFF file, even though 68k COFF has no
     such relocation type.

_line numbers_
     Object formats can contain, for debugging purposes, some form of
     mapping between symbols, source line numbers, and addresses in the
     output file.  These addresses have to be relocated along with the
     symbol information.  Each symbol with an associated list of line
     number records points to the first record of the list.  The head
     of a line number list consists of a pointer to the symbol, which
     allows finding out the address of the function whose line number
     is being described. The rest of the list is made up of pairs:
     offsets into the section and line numbers. Any format which can
     simply derive this information can pass it successfully between
     formats.


File: bfd.info,  Node: BFD front end,  Next: BFD back ends,  Prev: Overview,  Up: Top

2 BFD Front End
***************

* Menu:

* typedef bfd::
* Error reporting::
* Miscellaneous::
* Memory Usage::
* Initialization::
* Sections::
* Symbols::
* Archives::
* Formats::
* Relocations::
* Core Files::
* Targets::
* Architectures::
* Opening and Closing::
* Internal::
* File Caching::
* Linker Functions::
* Hash Tables::


File: bfd.info,  Node: typedef bfd,  Next: Error reporting,  Prev: BFD front end,  Up: BFD front end

2.1 `typedef bfd'
=================

A BFD has type `bfd'; objects of this type are the cornerstone of any
application using BFD. Using BFD consists of making references though
the BFD and to data in the BFD.

   Here is the structure that defines the type `bfd'.  It contains the
major data about the file and pointers to the rest of the data.


     enum bfd_direction
       {
         no_direction = 0,
         read_direction = 1,
         write_direction = 2,
         both_direction = 3
       };

     enum bfd_plugin_format
       {
         bfd_plugin_unknown = 0,
         bfd_plugin_yes = 1,
         bfd_plugin_no = 2
       };

     struct bfd_build_id
       {
         bfd_size_type size;
         bfd_byte data[1];
       };

     struct bfd
     {
       /* The filename the application opened the BFD with.  */
       const char *filename;

       /* A pointer to the target jump table.  */
       const struct bfd_target *xvec;

       /* The IOSTREAM, and corresponding IO vector that provide access
          to the file backing the BFD.  */
       void *iostream;
       const struct bfd_iovec *iovec;

       /* The caching routines use these to maintain a
          least-recently-used list of BFDs.  */
       struct bfd *lru_prev, *lru_next;

       /* Track current file position (or current buffer offset for
          in-memory BFDs).  When a file is closed by the caching routines,
          BFD retains state information on the file here.  */
       ufile_ptr where;

       /* File modified time, if mtime_set is TRUE.  */
       long mtime;

       /* A unique identifier of the BFD  */
       unsigned int id;

       /* The format which belongs to the BFD. (object, core, etc.)  */
       ENUM_BITFIELD (bfd_format) format : 3;

       /* The direction with which the BFD was opened.  */
       ENUM_BITFIELD (bfd_direction) direction : 2;

       /* Format_specific flags.  */
       flagword flags : 20;

       /* Values that may appear in the flags field of a BFD.  These also
          appear in the object_flags field of the bfd_target structure, where
          they indicate the set of flags used by that backend (not all flags
          are meaningful for all object file formats) (FIXME: at the moment,
          the object_flags values have mostly just been copied from backend
          to another, and are not necessarily correct).  */

     #define BFD_NO_FLAGS                0x0

       /* BFD contains relocation entries.  */
     #define HAS_RELOC                   0x1

       /* BFD is directly executable.  */
     #define EXEC_P                      0x2

       /* BFD has line number information (basically used for F_LNNO in a
          COFF header).  */
     #define HAS_LINENO                  0x4

       /* BFD has debugging information.  */
     #define HAS_DEBUG                  0x08

       /* BFD has symbols.  */
     #define HAS_SYMS                   0x10

       /* BFD has local symbols (basically used for F_LSYMS in a COFF
          header).  */
     #define HAS_LOCALS                 0x20

       /* BFD is a dynamic object.  */
     #define DYNAMIC                    0x40

       /* Text section is write protected (if D_PAGED is not set, this is
          like an a.out NMAGIC file) (the linker sets this by default, but
          clears it for -r or -N).  */
     #define WP_TEXT                    0x80

       /* BFD is dynamically paged (this is like an a.out ZMAGIC file) (the
          linker sets this by default, but clears it for -r or -n or -N).  */
     #define D_PAGED                   0x100

       /* BFD is relaxable (this means that bfd_relax_section may be able to
          do something) (sometimes bfd_relax_section can do something even if
          this is not set).  */
     #define BFD_IS_RELAXABLE          0x200

       /* This may be set before writing out a BFD to request using a
          traditional format.  For example, this is used to request that when
          writing out an a.out object the symbols not be hashed to eliminate
          duplicates.  */
     #define BFD_TRADITIONAL_FORMAT    0x400

       /* This flag indicates that the BFD contents are actually cached
          in memory.  If this is set, iostream points to a bfd_in_memory
          struct.  */
     #define BFD_IN_MEMORY             0x800

       /* This BFD has been created by the linker and doesn't correspond
          to any input file.  */
     #define BFD_LINKER_CREATED       0x1000

       /* This may be set before writing out a BFD to request that it
          be written using values for UIDs, GIDs, timestamps, etc. that
          will be consistent from run to run.  */
     #define BFD_DETERMINISTIC_OUTPUT 0x2000

       /* Compress sections in this BFD.  */
     #define BFD_COMPRESS             0x4000

       /* Decompress sections in this BFD.  */
     #define BFD_DECOMPRESS           0x8000

       /* BFD is a dummy, for plugins.  */
     #define BFD_PLUGIN              0x10000

       /* Compress sections in this BFD with SHF_COMPRESSED from gABI.  */
     #define BFD_COMPRESS_GABI       0x20000

       /* Convert ELF common symbol type to STT_COMMON or STT_OBJECT in this
          BFD.  */
     #define BFD_CONVERT_ELF_COMMON  0x40000

       /* Use the ELF STT_COMMON type in this BFD.  */
     #define BFD_USE_ELF_STT_COMMON  0x80000

       /* Flags bits to be saved in bfd_preserve_save.  */
     #define BFD_FLAGS_SAVED \
       (BFD_IN_MEMORY | BFD_COMPRESS | BFD_DECOMPRESS | BFD_LINKER_CREATED \
        | BFD_PLUGIN | BFD_COMPRESS_GABI | BFD_CONVERT_ELF_COMMON \
        | BFD_USE_ELF_STT_COMMON)

       /* Flags bits which are for BFD use only.  */
     #define BFD_FLAGS_FOR_BFD_USE_MASK \
       (BFD_IN_MEMORY | BFD_COMPRESS | BFD_DECOMPRESS | BFD_LINKER_CREATED \
        | BFD_PLUGIN | BFD_TRADITIONAL_FORMAT | BFD_DETERMINISTIC_OUTPUT \
        | BFD_COMPRESS_GABI | BFD_CONVERT_ELF_COMMON | BFD_USE_ELF_STT_COMMON)

       /* Is the file descriptor being cached?  That is, can it be closed as
          needed, and re-opened when accessed later?  */
       unsigned int cacheable : 1;

       /* Marks whether there was a default target specified when the
          BFD was opened. This is used to select which matching algorithm
          to use to choose the back end.  */
       unsigned int target_defaulted : 1;

       /* ... and here: (``once'' means at least once).  */
       unsigned int opened_once : 1;

       /* Set if we have a locally maintained mtime value, rather than
          getting it from the file each time.  */
       unsigned int mtime_set : 1;

       /* Flag set if symbols from this BFD should not be exported.  */
       unsigned int no_export : 1;

       /* Remember when output has begun, to stop strange things
          from happening.  */
       unsigned int output_has_begun : 1;

       /* Have archive map.  */
       unsigned int has_armap : 1;

       /* Set if this is a thin archive.  */
       unsigned int is_thin_archive : 1;

       /* Set if only required symbols should be added in the link hash table for
          this object.  Used by VMS linkers.  */
       unsigned int selective_search : 1;

       /* Set if this is the linker output BFD.  */
       unsigned int is_linker_output : 1;

       /* Set if this is the linker input BFD.  */
       unsigned int is_linker_input : 1;

       /* If this is an input for a compiler plug-in library.  */
       ENUM_BITFIELD (bfd_plugin_format) plugin_format : 2;

       /* Set if this is a plugin output file.  */
       unsigned int lto_output : 1;

       /* Set to dummy BFD created when claimed by a compiler plug-in
          library.  */
       bfd *plugin_dummy_bfd;

       /* Currently my_archive is tested before adding origin to
          anything. I believe that this can become always an add of
          origin, with origin set to 0 for non archive files.  */
       ufile_ptr origin;

       /* The origin in the archive of the proxy entry.  This will
          normally be the same as origin, except for thin archives,
          when it will contain the current offset of the proxy in the
          thin archive rather than the offset of the bfd in its actual
          container.  */
       ufile_ptr proxy_origin;

       /* A hash table for section names.  */
       struct bfd_hash_table section_htab;

       /* Pointer to linked list of sections.  */
       struct bfd_section *sections;

       /* The last section on the section list.  */
       struct bfd_section *section_last;

       /* The number of sections.  */
       unsigned int section_count;

       /* A field used by _bfd_generic_link_add_archive_symbols.  This will
          be used only for archive elements.  */
       int archive_pass;

       /* Stuff only useful for object files:
          The start address.  */
       bfd_vma start_address;

       /* Symbol table for output BFD (with symcount entries).
          Also used by the linker to cache input BFD symbols.  */
       struct bfd_symbol  **outsymbols;

       /* Used for input and output.  */
       unsigned int symcount;

       /* Used for slurped dynamic symbol tables.  */
       unsigned int dynsymcount;

       /* Pointer to structure which contains architecture information.  */
       const struct bfd_arch_info *arch_info;

       /* Stuff only useful for archives.  */
       void *arelt_data;
       struct bfd *my_archive;      /* The containing archive BFD.  */
       struct bfd *archive_next;    /* The next BFD in the archive.  */
       struct bfd *archive_head;    /* The first BFD in the archive.  */
       struct bfd *nested_archives; /* List of nested archive in a flattened
                                       thin archive.  */

       union {
         /* For input BFDs, a chain of BFDs involved in a link.  */
         struct bfd *next;
         /* For output BFD, the linker hash table.  */
         struct bfd_link_hash_table *hash;
       } link;

       /* Used by the back end to hold private data.  */
       union
         {
           struct aout_data_struct *aout_data;
           struct artdata *aout_ar_data;
           struct coff_tdata *coff_obj_data;
           struct pe_tdata *pe_obj_data;
           struct xcoff_tdata *xcoff_obj_data;
           struct ecoff_tdata *ecoff_obj_data;
           struct srec_data_struct *srec_data;
           struct verilog_data_struct *verilog_data;
           struct ihex_data_struct *ihex_data;
           struct tekhex_data_struct *tekhex_data;
           struct elf_obj_tdata *elf_obj_data;
           struct mmo_data_struct *mmo_data;
           struct sun_core_struct *sun_core_data;
           struct sco5_core_struct *sco5_core_data;
           struct trad_core_struct *trad_core_data;
           struct som_data_struct *som_data;
           struct hpux_core_struct *hpux_core_data;
           struct hppabsd_core_struct *hppabsd_core_data;
           struct sgi_core_struct *sgi_core_data;
           struct lynx_core_struct *lynx_core_data;
           struct osf_core_struct *osf_core_data;
           struct cisco_core_struct *cisco_core_data;
           struct versados_data_struct *versados_data;
           struct netbsd_core_struct *netbsd_core_data;
           struct mach_o_data_struct *mach_o_data;
           struct mach_o_fat_data_struct *mach_o_fat_data;
           struct plugin_data_struct *plugin_data;
           struct bfd_pef_data_struct *pef_data;
           struct bfd_pef_xlib_data_struct *pef_xlib_data;
           struct bfd_sym_data_struct *sym_data;
           void *any;
         }
       tdata;

       /* Used by the application to hold private data.  */
       void *usrdata;

       /* Where all the allocated stuff under this BFD goes.  This is a
          struct objalloc *, but we use void * to avoid requiring the inclusion
          of objalloc.h.  */
       void *memory;

       /* For input BFDs, the build ID, if the object has one. */
       const struct bfd_build_id *build_id;
     };

     /* See note beside bfd_set_section_userdata.  */
     static inline bfd_boolean
     bfd_set_cacheable (bfd * abfd, bfd_boolean val)
     {
       abfd->cacheable = val;
       return TRUE;
     }


File: bfd.info,  Node: Error reporting,  Next: Miscellaneous,  Prev: typedef bfd,  Up: BFD front end

2.2 Error reporting
===================

Most BFD functions return nonzero on success (check their individual
documentation for precise semantics).  On an error, they call
`bfd_set_error' to set an error condition that callers can check by
calling `bfd_get_error'.  If that returns `bfd_error_system_call', then
check `errno'.

   The easiest way to report a BFD error to the user is to use
`bfd_perror'.

2.2.1 Type `bfd_error_type'
---------------------------

The values returned by `bfd_get_error' are defined by the enumerated
type `bfd_error_type'.


     typedef enum bfd_error
     {
       bfd_error_no_error = 0,
       bfd_error_system_call,
       bfd_error_invalid_target,
       bfd_error_wrong_format,
       bfd_error_wrong_object_format,
       bfd_error_invalid_operation,
       bfd_error_no_memory,
       bfd_error_no_symbols,
       bfd_error_no_armap,
       bfd_error_no_more_archived_files,
       bfd_error_malformed_archive,
       bfd_error_missing_dso,
       bfd_error_file_not_recognized,
       bfd_error_file_ambiguously_recognized,
       bfd_error_no_contents,
       bfd_error_nonrepresentable_section,
       bfd_error_no_debug_section,
       bfd_error_bad_value,
       bfd_error_file_truncated,
       bfd_error_file_too_big,
       bfd_error_on_input,
       bfd_error_invalid_error_code
     }
     bfd_error_type;
   
2.2.1.1 `bfd_get_error'
.......................

*Synopsis*
     bfd_error_type bfd_get_error (void);
   *Description*
Return the current BFD error condition.

2.2.1.2 `bfd_set_error'
.......................

*Synopsis*
     void bfd_set_error (bfd_error_type error_tag);
   *Description*
Set the BFD error condition to be ERROR_TAG.

   ERROR_TAG must not be bfd_error_on_input.  Use bfd_set_input_error
for input errors instead.

2.2.1.3 `bfd_set_input_error'
.............................

*Synopsis*
     void bfd_set_input_error (bfd *input, bfd_error_type error_tag);
   *Description*
Set the BFD error condition to be bfd_error_on_input.  INPUT is the
input bfd where the error occurred, and ERROR_TAG the bfd_error_type
error.

2.2.1.4 `bfd_errmsg'
....................

*Synopsis*
     const char *bfd_errmsg (bfd_error_type error_tag);
   *Description*
Return a string describing the error ERROR_TAG, or the system error if
ERROR_TAG is `bfd_error_system_call'.

2.2.1.5 `bfd_perror'
....................

*Synopsis*
     void bfd_perror (const char *message);
   *Description*
Print to the standard error stream a string describing the last BFD
error that occurred, or the last system error if the last BFD error was
a system call failure.  If MESSAGE is non-NULL and non-empty, the error
string printed is preceded by MESSAGE, a colon, and a space.  It is
followed by a newline.

2.2.2 BFD error handler
-----------------------

Some BFD functions want to print messages describing the problem.  They
call a BFD error handler function.  This function may be overridden by
the program.

   The BFD error handler acts like vprintf.


     typedef void (*bfd_error_handler_type) (const char *, va_list);
   
2.2.2.1 `_bfd_error_handler'
............................

*Synopsis*
     void _bfd_error_handler (const char *fmt, ...) ATTRIBUTE_PRINTF_1;
   *Description*
This is the default routine to handle BFD error messages.  Like fprintf
(stderr, ...), but also handles some extra format specifiers.

   %pA section name from section.  For group components, prints group
name too.  %pB file name from bfd.  For archive components, prints
archive too.

   Beware: Only supports a maximum of 9 format arguments.

2.2.2.2 `bfd_set_error_handler'
...............................

*Synopsis*
     bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);
   *Description*
Set the BFD error handler function.  Returns the previous function.

2.2.2.3 `bfd_set_error_program_name'
....................................

*Synopsis*
     void bfd_set_error_program_name (const char *);
   *Description*
Set the program name to use when printing a BFD error.  This is printed
before the error message followed by a colon and space.  The string
must not be changed after it is passed to this function.

2.2.3 BFD assert handler
------------------------

If BFD finds an internal inconsistency, the bfd assert handler is
called with information on the BFD version, BFD source file and line.
If this happens, most programs linked against BFD are expected to want
to exit with an error, or mark the current BFD operation as failed, so
it is recommended to override the default handler, which just calls
_bfd_error_handler and continues.


     typedef void (*bfd_assert_handler_type) (const char *bfd_formatmsg,
                                              const char *bfd_version,
                                              const char *bfd_file,
                                              int bfd_line);
   
2.2.3.1 `bfd_set_assert_handler'
................................

*Synopsis*
     bfd_assert_handler_type bfd_set_assert_handler (bfd_assert_handler_type);
   *Description*
Set the BFD assert handler function.  Returns the previous function.


File: bfd.info,  Node: Miscellaneous,  Next: Memory Usage,  Prev: Error reporting,  Up: BFD front end

2.3 Miscellaneous
=================

2.3.1 Miscellaneous functions
-----------------------------

2.3.1.1 `bfd_get_reloc_upper_bound'
...................................

*Synopsis*
     long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);
   *Description*
Return the number of bytes required to store the relocation information
associated with section SECT attached to bfd ABFD.  If an error occurs,
return -1.

2.3.1.2 `bfd_canonicalize_reloc'
................................

*Synopsis*
     long bfd_canonicalize_reloc
        (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);
   *Description*
Call the back end associated with the open BFD ABFD and translate the
external form of the relocation information attached to SEC into the
internal canonical form.  Place the table into memory at LOC, which has
been preallocated, usually by a call to `bfd_get_reloc_upper_bound'.
Returns the number of relocs, or -1 on error.

   The SYMS table is also needed for horrible internal magic reasons.

2.3.1.3 `bfd_set_reloc'
.......................

*Synopsis*
     void bfd_set_reloc
        (bfd *abfd, asection *sec, arelent **rel, unsigned int count);
   *Description*
Set the relocation pointer and count within section SEC to the values
REL and COUNT.  The argument ABFD is ignored.
     #define bfd_set_reloc(abfd, asect, location, count) \
            BFD_SEND (abfd, _bfd_set_reloc, (abfd, asect, location, count))

2.3.1.4 `bfd_set_file_flags'
............................

*Synopsis*
     bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);
   *Description*
Set the flag word in the BFD ABFD to the value FLAGS.

   Possible errors are:
   * `bfd_error_wrong_format' - The target bfd was not of object format.

   * `bfd_error_invalid_operation' - The target bfd was open for
     reading.

   * `bfd_error_invalid_operation' - The flag word contained a bit
     which was not applicable to the type of file.  E.g., an attempt
     was made to set the `D_PAGED' bit on a BFD format which does not
     support demand paging.

2.3.1.5 `bfd_get_arch_size'
...........................

*Synopsis*
     int bfd_get_arch_size (bfd *abfd);
   *Description*
Returns the normalized architecture address size, in bits, as
determined by the object file's format.  By normalized, we mean either
32 or 64.  For ELF, this information is included in the header.  Use
bfd_arch_bits_per_address for number of bits in the architecture
address.

   *Returns*
Returns the arch size in bits if known, `-1' otherwise.

2.3.1.6 `bfd_get_sign_extend_vma'
.................................

*Synopsis*
     int bfd_get_sign_extend_vma (bfd *abfd);
   *Description*
Indicates if the target architecture "naturally" sign extends an
address.  Some architectures implicitly sign extend address values when
they are converted to types larger than the size of an address.  For
instance, bfd_get_start_address() will return an address sign extended
to fill a bfd_vma when this is the case.

   *Returns*
Returns `1' if the target architecture is known to sign extend
addresses, `0' if the target architecture is known to not sign extend
addresses, and `-1' otherwise.

2.3.1.7 `bfd_set_start_address'
...............................

*Synopsis*
     bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);
   *Description*
Make VMA the entry point of output BFD ABFD.

   *Returns*
Returns `TRUE' on success, `FALSE' otherwise.

2.3.1.8 `bfd_get_gp_size'
.........................

*Synopsis*
     unsigned int bfd_get_gp_size (bfd *abfd);
   *Description*
Return the maximum size of objects to be optimized using the GP
register under MIPS ECOFF.  This is typically set by the `-G' argument
to the compiler, assembler or linker.

2.3.1.9 `bfd_set_gp_size'
.........................

*Synopsis*
     void bfd_set_gp_size (bfd *abfd, unsigned int i);
   *Description*
Set the maximum size of objects to be optimized using the GP register
under ECOFF or MIPS ELF.  This is typically set by the `-G' argument to
the compiler, assembler or linker.

2.3.1.10 `bfd_scan_vma'
.......................

*Synopsis*
     bfd_vma bfd_scan_vma (const char *string, const char **end, int base);
   *Description*
Convert, like `strtoul', a numerical expression STRING into a `bfd_vma'
integer, and return that integer.  (Though without as many bells and
whistles as `strtoul'.)  The expression is assumed to be unsigned
(i.e., positive).  If given a BASE, it is used as the base for
conversion.  A base of 0 causes the function to interpret the string in
hex if a leading "0x" or "0X" is found, otherwise in octal if a leading
zero is found, otherwise in decimal.

   If the value would overflow, the maximum `bfd_vma' value is returned.

2.3.1.11 `bfd_copy_private_header_data'
.......................................

*Synopsis*
     bfd_boolean bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);
   *Description*
Copy private BFD header information from the BFD IBFD to the the BFD
OBFD.  This copies information that may require sections to exist, but
does not require symbol tables.  Return `true' on success, `false' on
error.  Possible error returns are:

   * `bfd_error_no_memory' - Not enough memory exists to create private
     data for OBFD.

     #define bfd_copy_private_header_data(ibfd, obfd) \
            BFD_SEND (obfd, _bfd_copy_private_header_data, \
                      (ibfd, obfd))

2.3.1.12 `bfd_copy_private_bfd_data'
....................................

*Synopsis*
     bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);
   *Description*
Copy private BFD information from the BFD IBFD to the the BFD OBFD.
Return `TRUE' on success, `FALSE' on error.  Possible error returns are:

   * `bfd_error_no_memory' - Not enough memory exists to create private
     data for OBFD.

     #define bfd_copy_private_bfd_data(ibfd, obfd) \
            BFD_SEND (obfd, _bfd_copy_private_bfd_data, \
                      (ibfd, obfd))

2.3.1.13 `bfd_set_private_flags'
................................

*Synopsis*
     bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
   *Description*
Set private BFD flag information in the BFD ABFD.  Return `TRUE' on
success, `FALSE' on error.  Possible error returns are:

   * `bfd_error_no_memory' - Not enough memory exists to create private
     data for OBFD.

     #define bfd_set_private_flags(abfd, flags) \
            BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))

2.3.1.14 `Other functions'
..........................

*Description*
The following functions exist but have not yet been documented.
     #define bfd_sizeof_headers(abfd, info) \
            BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, info))

     #define bfd_find_nearest_line(abfd, sec, syms, off, file, func, line) \
            BFD_SEND (abfd, _bfd_find_nearest_line, \
                      (abfd, syms, sec, off, file, func, line, NULL))

     #define bfd_find_nearest_line_discriminator(abfd, sec, syms, off, file, func, \
                                                line, disc) \
            BFD_SEND (abfd, _bfd_find_nearest_line, \
                      (abfd, syms, sec, off, file, func, line, disc))

     #define bfd_find_line(abfd, syms, sym, file, line) \
            BFD_SEND (abfd, _bfd_find_line, \
                      (abfd, syms, sym, file, line))

     #define bfd_find_inliner_info(abfd, file, func, line) \
            BFD_SEND (abfd, _bfd_find_inliner_info, \
                      (abfd, file, func, line))

     #define bfd_debug_info_start(abfd) \
            BFD_SEND (abfd, _bfd_debug_info_start, (abfd))

     #define bfd_debug_info_end(abfd) \
            BFD_SEND (abfd, _bfd_debug_info_end, (abfd))

     #define bfd_debug_info_accumulate(abfd, section) \
            BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))

     #define bfd_stat_arch_elt(abfd, stat) \
            BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))

     #define bfd_update_armap_timestamp(abfd) \
            BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))

     #define bfd_set_arch_mach(abfd, arch, mach)\
            BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))

     #define bfd_relax_section(abfd, section, link_info, again) \
            BFD_SEND (abfd, _bfd_relax_section, (abfd, section, link_info, again))

     #define bfd_gc_sections(abfd, link_info) \
            BFD_SEND (abfd, _bfd_gc_sections, (abfd, link_info))

     #define bfd_lookup_section_flags(link_info, flag_info, section) \
            BFD_SEND (abfd, _bfd_lookup_section_flags, (link_info, flag_info, section))

     #define bfd_merge_sections(abfd, link_info) \
            BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info))

     #define bfd_is_group_section(abfd, sec) \
            BFD_SEND (abfd, _bfd_is_group_section, (abfd, sec))

     #define bfd_discard_group(abfd, sec) \
            BFD_SEND (abfd, _bfd_discard_group, (abfd, sec))

     #define bfd_link_hash_table_create(abfd) \
            BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd))

     #define bfd_link_add_symbols(abfd, info) \
            BFD_SEND (abfd, _bfd_link_add_symbols, (abfd, info))

     #define bfd_link_just_syms(abfd, sec, info) \
            BFD_SEND (abfd, _bfd_link_just_syms, (sec, info))

     #define bfd_final_link(abfd, info) \
            BFD_SEND (abfd, _bfd_final_link, (abfd, info))

     #define bfd_free_cached_info(abfd) \
            BFD_SEND (abfd, _bfd_free_cached_info, (abfd))

     #define bfd_get_dynamic_symtab_upper_bound(abfd) \
            BFD_SEND (abfd, _bfd_get_dynamic_symtab_upper_bound, (abfd))

     #define bfd_print_private_bfd_data(abfd, file)\
            BFD_SEND (abfd, _bfd_print_private_bfd_data, (abfd, file))

     #define bfd_canonicalize_dynamic_symtab(abfd, asymbols) \
            BFD_SEND (abfd, _bfd_canonicalize_dynamic_symtab, (abfd, asymbols))

     #define bfd_get_synthetic_symtab(abfd, count, syms, dyncount, dynsyms, ret) \
            BFD_SEND (abfd, _bfd_get_synthetic_symtab, (abfd, count, syms, \
                                                        dyncount, dynsyms, ret))

     #define bfd_get_dynamic_reloc_upper_bound(abfd) \
            BFD_SEND (abfd, _bfd_get_dynamic_reloc_upper_bound, (abfd))

     #define bfd_canonicalize_dynamic_reloc(abfd, arels, asyms) \
            BFD_SEND (abfd, _bfd_canonicalize_dynamic_reloc, (abfd, arels, asyms))

     extern bfd_byte *bfd_get_relocated_section_contents
       (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
        bfd_boolean, asymbol **);

2.3.1.15 `bfd_alt_mach_code'
............................

*Synopsis*
     bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);
   *Description*
When more than one machine code number is available for the same
machine type, this function can be used to switch between the preferred
one (alternative == 0) and any others.  Currently, only ELF supports
this feature, with up to two alternate machine codes.

2.3.1.16 `bfd_emul_get_maxpagesize'
...................................

*Synopsis*
     bfd_vma bfd_emul_get_maxpagesize (const char *);
   *Description*
Returns the maximum page size, in bytes, as determined by emulation.

   *Returns*
Returns the maximum page size in bytes for ELF, 0 otherwise.

2.3.1.17 `bfd_emul_set_maxpagesize'
...................................

*Synopsis*
     void bfd_emul_set_maxpagesize (const char *, bfd_vma);
   *Description*
For ELF, set the maximum page size for the emulation.  It is a no-op
for other formats.

2.3.1.18 `bfd_emul_get_commonpagesize'
......................................

*Synopsis*
     bfd_vma bfd_emul_get_commonpagesize (const char *, bfd_boolean);
   *Description*
Returns the common page size, in bytes, as determined by emulation.

   *Returns*
Returns the common page size in bytes for ELF, 0 otherwise.

2.3.1.19 `bfd_emul_set_commonpagesize'
......................................

*Synopsis*
     void bfd_emul_set_commonpagesize (const char *, bfd_vma);
   *Description*
For ELF, set the common page size for the emulation.  It is a no-op for
other formats.

2.3.1.20 `bfd_demangle'
.......................

*Synopsis*
     char *bfd_demangle (bfd *, const char *, int);
   *Description*
Wrapper around cplus_demangle.  Strips leading underscores and other
such chars that would otherwise confuse the demangler.  If passed a g++
v3 ABI mangled name, returns a buffer allocated with malloc holding the
demangled name.  Returns NULL otherwise and on memory alloc failure.

2.3.1.21 `bfd_update_compression_header'
........................................

*Synopsis*
     void bfd_update_compression_header
        (bfd *abfd, bfd_byte *contents, asection *sec);
   *Description*
Set the compression header at CONTENTS of SEC in ABFD and update
elf_section_flags for compression.

2.3.1.22 `bfd_check_compression_header'
.......................................

*Synopsis*
     bfd_boolean bfd_check_compression_header
        (bfd *abfd, bfd_byte *contents, asection *sec,
         bfd_size_type *uncompressed_size);
   *Description*
Check the compression header at CONTENTS of SEC in ABFD and store the
uncompressed size in UNCOMPRESSED_SIZE if the compression header is
valid.

   *Returns*
Return TRUE if the compression header is valid.

2.3.1.23 `bfd_get_compression_header_size'
..........................................

*Synopsis*
     int bfd_get_compression_header_size (bfd *abfd, asection *sec);
   *Description*
Return the size of the compression header of SEC in ABFD.

   *Returns*
Return the size of the compression header in bytes.

2.3.1.24 `bfd_convert_section_size'
...................................

*Synopsis*
     bfd_size_type bfd_convert_section_size
        (bfd *ibfd, asection *isec, bfd *obfd, bfd_size_type size);
   *Description*
Convert the size SIZE of the section ISEC in input BFD IBFD to the
section size in output BFD OBFD.

2.3.1.25 `bfd_convert_section_contents'
.......................................

*Synopsis*
     bfd_boolean bfd_convert_section_contents
        (bfd *ibfd, asection *isec, bfd *obfd,
         bfd_byte **ptr, bfd_size_type *ptr_size);
   *Description*
Convert the contents, stored in *PTR, of the section ISEC in input BFD
IBFD to output BFD OBFD if needed.  The original buffer pointed to by
*PTR may be freed and *PTR is returned with memory malloc'd by this
function, and the new size written to PTR_SIZE.

2.3.1.26 `struct bfd_iovec'
...........................

*Description*
The `struct bfd_iovec' contains the internal file I/O class.  Each
`BFD' has an instance of this class and all file I/O is routed through
it (it is assumed that the instance implements all methods listed
below).
     struct bfd_iovec
     {
       /* To avoid problems with macros, a "b" rather than "f"
          prefix is prepended to each method name.  */
       /* Attempt to read/write NBYTES on ABFD's IOSTREAM storing/fetching
          bytes starting at PTR.  Return the number of bytes actually
          transfered (a read past end-of-file returns less than NBYTES),
          or -1 (setting `bfd_error') if an error occurs.  */
       file_ptr (*bread) (struct bfd *abfd, void *ptr, file_ptr nbytes);
       file_ptr (*bwrite) (struct bfd *abfd, const void *ptr,
                           file_ptr nbytes);
       /* Return the current IOSTREAM file offset, or -1 (setting `bfd_error'
          if an error occurs.  */
       file_ptr (*btell) (struct bfd *abfd);
       /* For the following, on successful completion a value of 0 is returned.
          Otherwise, a value of -1 is returned (and `bfd_error' is set).  */
       int (*bseek) (struct bfd *abfd, file_ptr offset, int whence);
       int (*bclose) (struct bfd *abfd);
       int (*bflush) (struct bfd *abfd);
       int (*bstat) (struct bfd *abfd, struct stat *sb);
       /* Mmap a part of the files. ADDR, LEN, PROT, FLAGS and OFFSET are the usual
          mmap parameter, except that LEN and OFFSET do not need to be page
          aligned.  Returns (void *)-1 on failure, mmapped address on success.
          Also write in MAP_ADDR the address of the page aligned buffer and in
          MAP_LEN the size mapped (a page multiple).  Use unmap with MAP_ADDR and
          MAP_LEN to unmap.  */
       void *(*bmmap) (struct bfd *abfd, void *addr, bfd_size_type len,
                       int prot, int flags, file_ptr offset,
                       void **map_addr, bfd_size_type *map_len);
     };
     extern const struct bfd_iovec _bfd_memory_iovec;

2.3.1.27 `bfd_get_mtime'
........................

*Synopsis*
     long bfd_get_mtime (bfd *abfd);
   *Description*
Return the file modification time (as read from the file system, or
from the archive header for archive members).

2.3.1.28 `bfd_get_size'
.......................

*Synopsis*
     ufile_ptr bfd_get_size (bfd *abfd);
   *Description*
Return the file size (as read from file system) for the file associated
with BFD ABFD.

   The initial motivation for, and use of, this routine is not so we
can get the exact size of the object the BFD applies to, since that
might not be generally possible (archive members for example).  It
would be ideal if someone could eventually modify it so that such
results were guaranteed.

   Instead, we want to ask questions like "is this NNN byte sized
object I'm about to try read from file offset YYY reasonable?"  As as
example of where we might do this, some object formats use string
tables for which the first `sizeof (long)' bytes of the table contain
the size of the table itself, including the size bytes.  If an
application tries to read what it thinks is one of these string tables,
without some way to validate the size, and for some reason the size is
wrong (byte swapping error, wrong location for the string table, etc.),
the only clue is likely to be a read error when it tries to read the
table, or a "virtual memory exhausted" error when it tries to allocate
15 bazillon bytes of space for the 15 bazillon byte table it is about
to read.  This function at least allows us to answer the question, "is
the size reasonable?".

2.3.1.29 `bfd_get_file_size'
............................

*Synopsis*
     ufile_ptr bfd_get_file_size (bfd *abfd);
   *Description*
Return the file size (as read from file system) for the file associated
with BFD ABFD.  It supports both normal files and archive elements.

2.3.1.30 `bfd_mmap'
...................

*Synopsis*
     void *bfd_mmap (bfd *abfd, void *addr, bfd_size_type len,
         int prot, int flags, file_ptr offset,
         void **map_addr, bfd_size_type *map_len);
   *Description*
Return mmap()ed region of the file, if possible and implemented.  LEN
and OFFSET do not need to be page aligned.  The page aligned address
and length are written to MAP_ADDR and MAP_LEN.


File: bfd.info,  Node: Memory Usage,  Next: Initialization,  Prev: Miscellaneous,  Up: BFD front end

2.4 Memory Usage
================

BFD keeps all of its internal structures in obstacks. There is one
obstack per open BFD file, into which the current state is stored. When
a BFD is closed, the obstack is deleted, and so everything which has
been allocated by BFD for the closing file is thrown away.

   BFD does not free anything created by an application, but pointers
into `bfd' structures become invalid on a `bfd_close'; for example,
after a `bfd_close' the vector passed to `bfd_canonicalize_symtab' is
still around, since it has been allocated by the application, but the
data that it pointed to are lost.

   The general rule is to not close a BFD until all operations dependent
upon data from the BFD have been completed, or all the data from within
the file has been copied. To help with the management of memory, there
is a function (`bfd_alloc_size') which returns the number of bytes in
obstacks associated with the supplied BFD. This could be used to select
the greediest open BFD, close it to reclaim the memory, perform some
operation and reopen the BFD again, to get a fresh copy of the data
structures.


File: bfd.info,  Node: Initialization,  Next: Sections,  Prev: Memory Usage,  Up: BFD front end

2.5 Initialization
==================

2.5.1 Initialization functions
------------------------------

These are the functions that handle initializing a BFD.

2.5.1.1 `bfd_init'
..................

*Synopsis*
     unsigned int bfd_init (void);
   *Description*
This routine must be called before any other BFD function to initialize
magical internal data structures.  Returns a magic number, which may be
used to check that the bfd library is configured as expected by users.

     /* Value returned by bfd_init.  */

     #define BFD_INIT_MAGIC (sizeof (struct bfd_section))


File: bfd.info,  Node: Sections,  Next: Symbols,  Prev: Initialization,  Up: BFD front end

2.6 Sections
============

The raw data contained within a BFD is maintained through the section
abstraction.  A single BFD may have any number of sections.  It keeps
hold of them by pointing to the first; each one points to the next in
the list.

   Sections are supported in BFD in `section.c'.

* Menu:

* Section Input::
* Section Output::
* typedef asection::
* section prototypes::


File: bfd.info,  Node: Section Input,  Next: Section Output,  Prev: Sections,  Up: Sections

2.6.1 Section input
-------------------

When a BFD is opened for reading, the section structures are created
and attached to the BFD.

   Each section has a name which describes the section in the outside
world--for example, `a.out' would contain at least three sections,
called `.text', `.data' and `.bss'.

   Names need not be unique; for example a COFF file may have several
sections named `.data'.

   Sometimes a BFD will contain more than the "natural" number of
sections. A back end may attach other sections containing constructor
data, or an application may add a section (using `bfd_make_section') to
the sections attached to an already open BFD. For example, the linker
creates an extra section `COMMON' for each input file's BFD to hold
information about common storage.

   The raw data is not necessarily read in when the section descriptor
is created. Some targets may leave the data in place until a
`bfd_get_section_contents' call is made. Other back ends may read in
all the data at once.  For example, an S-record file has to be read
once to determine the size of the data.


File: bfd.info,  Node: Section Output,  Next: typedef asection,  Prev: Section Input,  Up: Sections

2.6.2 Section output
--------------------

To write a new object style BFD, the various sections to be written
have to be created. They are attached to the BFD in the same way as
input sections; data is written to the sections using
`bfd_set_section_contents'.

   Any program that creates or combines sections (e.g., the assembler
and linker) must use the `asection' fields `output_section' and
`output_offset' to indicate the file sections to which each section
must be written.  (If the section is being created from scratch,
`output_section' should probably point to the section itself and
`output_offset' should probably be zero.)

   The data to be written comes from input sections attached (via
`output_section' pointers) to the output sections.  The output section
structure can be considered a filter for the input section: the output
section determines the vma of the output data and the name, but the
input section determines the offset into the output section of the data
to be written.

   E.g., to create a section "O", starting at 0x100, 0x123 long,
containing two subsections, "A" at offset 0x0 (i.e., at vma 0x100) and
"B" at offset 0x20 (i.e., at vma 0x120) the `asection' structures would
look like:

        section name          "A"
          output_offset   0x00
          size            0x20
          output_section ----------->  section name    "O"
                                  |    vma             0x100
        section name          "B" |    size            0x123
          output_offset   0x20    |
          size            0x103   |
          output_section  --------|

2.6.3 Link orders
-----------------

The data within a section is stored in a "link_order".  These are much
like the fixups in `gas'.  The link_order abstraction allows a section
to grow and shrink within itself.

   A link_order knows how big it is, and which is the next link_order
and where the raw data for it is; it also points to a list of
relocations which apply to it.

   The link_order is used by the linker to perform relaxing on final
code.  The compiler creates code which is as big as necessary to make
it work without relaxing, and the user can select whether to relax.
Sometimes relaxing takes a lot of time.  The linker runs around the
relocations to see if any are attached to data which can be shrunk, if
so it does it on a link_order by link_order basis.


File: bfd.info,  Node: typedef asection,  Next: section prototypes,  Prev: Section Output,  Up: Sections

2.6.4 typedef asection
----------------------

Here is the section structure:


     typedef struct bfd_section
     {
       /* The name of the section; the name isn't a copy, the pointer is
          the same as that passed to bfd_make_section.  */
       const char *name;

       /* A unique sequence number.  */
       unsigned int id;

       /* Which section in the bfd; 0..n-1 as sections are created in a bfd.  */
       unsigned int index;

       /* The next section in the list belonging to the BFD, or NULL.  */
       struct bfd_section *next;

       /* The previous section in the list belonging to the BFD, or NULL.  */
       struct bfd_section *prev;

       /* The field flags contains attributes of the section. Some
          flags are read in from the object file, and some are
          synthesized from other information.  */
       flagword flags;

     #define SEC_NO_FLAGS                      0x0

       /* Tells the OS to allocate space for this section when loading.
          This is clear for a section containing debug information only.  */
     #define SEC_ALLOC                         0x1

       /* Tells the OS to load the section from the file when loading.
          This is clear for a .bss section.  */
     #define SEC_LOAD                          0x2

       /* The section contains data still to be relocated, so there is
          some relocation information too.  */
     #define SEC_RELOC                         0x4

       /* A signal to the OS that the section contains read only data.  */
     #define SEC_READONLY                      0x8

       /* The section contains code only.  */
     #define SEC_CODE                         0x10

       /* The section contains data only.  */
     #define SEC_DATA                         0x20

       /* The section will reside in ROM.  */
     #define SEC_ROM                          0x40

       /* The section contains constructor information. This section
          type is used by the linker to create lists of constructors and
          destructors used by `g++'. When a back end sees a symbol
          which should be used in a constructor list, it creates a new
          section for the type of name (e.g., `__CTOR_LIST__'), attaches
          the symbol to it, and builds a relocation. To build the lists
          of constructors, all the linker has to do is catenate all the
          sections called `__CTOR_LIST__' and relocate the data
          contained within - exactly the operations it would peform on
          standard data.  */
     #define SEC_CONSTRUCTOR                  0x80

       /* The section has contents - a data section could be
          `SEC_ALLOC' | `SEC_HAS_CONTENTS'; a debug section could be
          `SEC_HAS_CONTENTS'  */
     #define SEC_HAS_CONTENTS                0x100

       /* An instruction to the linker to not output the section
          even if it has information which would normally be written.  */
     #define SEC_NEVER_LOAD                  0x200

       /* The section contains thread local data.  */
     #define SEC_THREAD_LOCAL                0x400

       /* The section's size is fixed.  Generic linker code will not
          recalculate it and it is up to whoever has set this flag to
          get the size right.  */
     #define SEC_FIXED_SIZE                  0x800

       /* The section contains common symbols (symbols may be defined
          multiple times, the value of a symbol is the amount of
          space it requires, and the largest symbol value is the one
          used).  Most targets have exactly one of these (which we
          translate to bfd_com_section_ptr), but ECOFF has two.  */
     #define SEC_IS_COMMON                  0x1000

       /* The section contains only debugging information.  For
          example, this is set for ELF .debug and .stab sections.
          strip tests this flag to see if a section can be
          discarded.  */
     #define SEC_DEBUGGING                  0x2000

       /* The contents of this section are held in memory pointed to
          by the contents field.  This is checked by bfd_get_section_contents,
          and the data is retrieved from memory if appropriate.  */
     #define SEC_IN_MEMORY                  0x4000

       /* The contents of this section are to be excluded by the
          linker for executable and shared objects unless those
          objects are to be further relocated.  */
     #define SEC_EXCLUDE                    0x8000

       /* The contents of this section are to be sorted based on the sum of
          the symbol and addend values specified by the associated relocation
          entries.  Entries without associated relocation entries will be
          appended to the end of the section in an unspecified order.  */
     #define SEC_SORT_ENTRIES              0x10000

       /* When linking, duplicate sections of the same name should be
          discarded, rather than being combined into a single section as
          is usually done.  This is similar to how common symbols are
          handled.  See SEC_LINK_DUPLICATES below.  */
     #define SEC_LINK_ONCE                 0x20000

       /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
          should handle duplicate sections.  */
     #define SEC_LINK_DUPLICATES           0xc0000

       /* This value for SEC_LINK_DUPLICATES means that duplicate
          sections with the same name should simply be discarded.  */
     #define SEC_LINK_DUPLICATES_DISCARD       0x0

       /* This value for SEC_LINK_DUPLICATES means that the linker
          should warn if there are any duplicate sections, although
          it should still only link one copy.  */
     #define SEC_LINK_DUPLICATES_ONE_ONLY  0x40000

       /* This value for SEC_LINK_DUPLICATES means that the linker
          should warn if any duplicate sections are a different size.  */
     #define SEC_LINK_DUPLICATES_SAME_SIZE 0x80000

       /* This value for SEC_LINK_DUPLICATES means that the linker
          should warn if any duplicate sections contain different
          contents.  */
     #define SEC_LINK_DUPLICATES_SAME_CONTENTS \
       (SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE)

       /* This section was created by the linker as part of dynamic
          relocation or other arcane processing.  It is skipped when
          going through the first-pass output, trusting that someone
          else up the line will take care of it later.  */
     #define SEC_LINKER_CREATED           0x100000

       /* This section should not be subject to garbage collection.
          Also set to inform the linker that this section should not be
          listed in the link map as discarded.  */
     #define SEC_KEEP                     0x200000

       /* This section contains "short" data, and should be placed
          "near" the GP.  */
     #define SEC_SMALL_DATA               0x400000

       /* Attempt to merge identical entities in the section.
          Entity size is given in the entsize field.  */
     #define SEC_MERGE                    0x800000

       /* If given with SEC_MERGE, entities to merge are zero terminated
          strings where entsize specifies character size instead of fixed
          size entries.  */
     #define SEC_STRINGS                 0x1000000

       /* This section contains data about section groups.  */
     #define SEC_GROUP                   0x2000000

       /* The section is a COFF shared library section.  This flag is
          only for the linker.  If this type of section appears in
          the input file, the linker must copy it to the output file
          without changing the vma or size.  FIXME: Although this
          was originally intended to be general, it really is COFF
          specific (and the flag was renamed to indicate this).  It
          might be cleaner to have some more general mechanism to
          allow the back end to control what the linker does with
          sections.  */
     #define SEC_COFF_SHARED_LIBRARY     0x4000000

       /* This input section should be copied to output in reverse order
          as an array of pointers.  This is for ELF linker internal use
          only.  */
     #define SEC_ELF_REVERSE_COPY        0x4000000

       /* This section contains data which may be shared with other
          executables or shared objects. This is for COFF only.  */
     #define SEC_COFF_SHARED             0x8000000

       /* This section should be compressed.  This is for ELF linker
          internal use only.  */
     #define SEC_ELF_COMPRESS            0x8000000

       /* When a section with this flag is being linked, then if the size of
          the input section is less than a page, it should not cross a page
          boundary.  If the size of the input section is one page or more,
          it should be aligned on a page boundary.  This is for TI
          TMS320C54X only.  */
     #define SEC_TIC54X_BLOCK           0x10000000

       /* This section should be renamed.  This is for ELF linker
          internal use only.  */
     #define SEC_ELF_RENAME             0x10000000

       /* Conditionally link this section; do not link if there are no
          references found to any symbol in the section.  This is for TI
          TMS320C54X only.  */
     #define SEC_TIC54X_CLINK           0x20000000

       /* This section contains vliw code.  This is for Toshiba MeP only.  */
     #define SEC_MEP_VLIW               0x20000000

       /* Indicate that section has the no read flag set. This happens
          when memory read flag isn't set. */
     #define SEC_COFF_NOREAD            0x40000000

       /* Indicate that section has the purecode flag set.  */
     #define SEC_ELF_PURECODE           0x80000000

       /*  End of section flags.  */

       /* Some internal packed boolean fields.  */

       /* See the vma field.  */
       unsigned int user_set_vma : 1;

       /* A mark flag used by some of the linker backends.  */
       unsigned int linker_mark : 1;

       /* Another mark flag used by some of the linker backends.  Set for
          output sections that have an input section.  */
       unsigned int linker_has_input : 1;

       /* Mark flag used by some linker backends for garbage collection.  */
       unsigned int gc_mark : 1;

       /* Section compression status.  */
       unsigned int compress_status : 2;
     #define COMPRESS_SECTION_NONE    0
     #define COMPRESS_SECTION_DONE    1
     #define DECOMPRESS_SECTION_SIZED 2

       /* The following flags are used by the ELF linker. */

       /* Mark sections which have been allocated to segments.  */
       unsigned int segment_mark : 1;

       /* Type of sec_info information.  */
       unsigned int sec_info_type:3;
     #define SEC_INFO_TYPE_NONE      0
     #define SEC_INFO_TYPE_STABS     1
     #define SEC_INFO_TYPE_MERGE     2
     #define SEC_INFO_TYPE_EH_FRAME  3
     #define SEC_INFO_TYPE_JUST_SYMS 4
     #define SEC_INFO_TYPE_TARGET    5
     #define SEC_INFO_TYPE_EH_FRAME_ENTRY 6

       /* Nonzero if this section uses RELA relocations, rather than REL.  */
       unsigned int use_rela_p:1;

       /* Bits used by various backends.  The generic code doesn't touch
          these fields.  */

       unsigned int sec_flg0:1;
       unsigned int sec_flg1:1;
       unsigned int sec_flg2:1;
       unsigned int sec_flg3:1;
       unsigned int sec_flg4:1;
       unsigned int sec_flg5:1;

       /* End of internal packed boolean fields.  */

       /*  The virtual memory address of the section - where it will be
           at run time.  The symbols are relocated against this.  The
           user_set_vma flag is maintained by bfd; if it's not set, the
           backend can assign addresses (for example, in `a.out', where
           the default address for `.data' is dependent on the specific
           target and various flags).  */
       bfd_vma vma;

       /*  The load address of the section - where it would be in a
           rom image; really only used for writing section header
           information.  */
       bfd_vma lma;

       /* The size of the section in *octets*, as it will be output.
          Contains a value even if the section has no contents (e.g., the
          size of `.bss').  */
       bfd_size_type size;

       /* For input sections, the original size on disk of the section, in
          octets.  This field should be set for any section whose size is
          changed by linker relaxation.  It is required for sections where
          the linker relaxation scheme doesn't cache altered section and
          reloc contents (stabs, eh_frame, SEC_MERGE, some coff relaxing
          targets), and thus the original size needs to be kept to read the
          section multiple times.  For output sections, rawsize holds the
          section size calculated on a previous linker relaxation pass.  */
       bfd_size_type rawsize;

       /* The compressed size of the section in octets.  */
       bfd_size_type compressed_size;

       /* Relaxation table. */
       struct relax_table *relax;

       /* Count of used relaxation table entries. */
       int relax_count;


       /* If this section is going to be output, then this value is the
          offset in *bytes* into the output section of the first byte in the
          input section (byte ==> smallest addressable unit on the
          target).  In most cases, if this was going to start at the
          100th octet (8-bit quantity) in the output section, this value
          would be 100.  However, if the target byte size is 16 bits
          (bfd_octets_per_byte is "2"), this value would be 50.  */
       bfd_vma output_offset;

       /* The output section through which to map on output.  */
       struct bfd_section *output_section;

       /* The alignment requirement of the section, as an exponent of 2 -
          e.g., 3 aligns to 2^3 (or 8).  */
       unsigned int alignment_power;

       /* If an input section, a pointer to a vector of relocation
          records for the data in this section.  */
       struct reloc_cache_entry *relocation;

       /* If an output section, a pointer to a vector of pointers to
          relocation records for the data in this section.  */
       struct reloc_cache_entry **orelocation;

       /* The number of relocation records in one of the above.  */
       unsigned reloc_count;

       /* Information below is back end specific - and not always used
          or updated.  */

       /* File position of section data.  */
       file_ptr filepos;

       /* File position of relocation info.  */
       file_ptr rel_filepos;

       /* File position of line data.  */
       file_ptr line_filepos;

       /* Pointer to data for applications.  */
       void *userdata;

       /* If the SEC_IN_MEMORY flag is set, this points to the actual
          contents.  */
       unsigned char *contents;

       /* Attached line number information.  */
       alent *lineno;

       /* Number of line number records.  */
       unsigned int lineno_count;

       /* Entity size for merging purposes.  */
       unsigned int entsize;

       /* Points to the kept section if this section is a link-once section,
          and is discarded.  */
       struct bfd_section *kept_section;

       /* When a section is being output, this value changes as more
          linenumbers are written out.  */
       file_ptr moving_line_filepos;

       /* What the section number is in the target world.  */
       int target_index;

       void *used_by_bfd;

       /* If this is a constructor section then here is a list of the
          relocations created to relocate items within it.  */
       struct relent_chain *constructor_chain;

       /* The BFD which owns the section.  */
       bfd *owner;

       /* A symbol which points at this section only.  */
       struct bfd_symbol *symbol;
       struct bfd_symbol **symbol_ptr_ptr;

       /* Early in the link process, map_head and map_tail are used to build
          a list of input sections attached to an output section.  Later,
          output sections use these fields for a list of bfd_link_order
          structs.  */
       union {
         struct bfd_link_order *link_order;
         struct bfd_section *s;
       } map_head, map_tail;
     } asection;

     /* Relax table contains information about instructions which can
        be removed by relaxation -- replacing a long address with a
        short address.  */
     struct relax_table {
       /* Address where bytes may be deleted. */
       bfd_vma addr;

       /* Number of bytes to be deleted.  */
       int size;
     };

     /* Note: the following are provided as inline functions rather than macros
        because not all callers use the return value.  A macro implementation
        would use a comma expression, eg: "((ptr)->foo = val, TRUE)" and some
        compilers will complain about comma expressions that have no effect.  */
     static inline bfd_boolean
     bfd_set_section_userdata (bfd * abfd ATTRIBUTE_UNUSED, asection * ptr,
                               void * val)
     {
       ptr->userdata = val;
       return TRUE;
     }

     static inline bfd_boolean
     bfd_set_section_vma (bfd * abfd ATTRIBUTE_UNUSED, asection * ptr, bfd_vma val)
     {
       ptr->vma = ptr->lma = val;
       ptr->user_set_vma = TRUE;
       return TRUE;
     }

     static inline bfd_boolean
     bfd_set_section_alignment (bfd * abfd ATTRIBUTE_UNUSED, asection * ptr,
                                unsigned int val)
     {
       ptr->alignment_power = val;
       return TRUE;
     }

     /* These sections are global, and are managed by BFD.  The application
        and target back end are not permitted to change the values in
        these sections.  */
     extern asection _bfd_std_section[4];

     #define BFD_ABS_SECTION_NAME "*ABS*"
     #define BFD_UND_SECTION_NAME "*UND*"
     #define BFD_COM_SECTION_NAME "*COM*"
     #define BFD_IND_SECTION_NAME "*IND*"

     /* Pointer to the common section.  */
     #define bfd_com_section_ptr (&_bfd_std_section[0])
     /* Pointer to the undefined section.  */
     #define bfd_und_section_ptr (&_bfd_std_section[1])
     /* Pointer to the absolute section.  */
     #define bfd_abs_section_ptr (&_bfd_std_section[2])
     /* Pointer to the indirect section.  */
     #define bfd_ind_section_ptr (&_bfd_std_section[3])

     #define bfd_is_und_section(sec) ((sec) == bfd_und_section_ptr)
     #define bfd_is_abs_section(sec) ((sec) == bfd_abs_section_ptr)
     #define bfd_is_ind_section(sec) ((sec) == bfd_ind_section_ptr)

     #define bfd_is_const_section(SEC)              \
      (   ((SEC) == bfd_abs_section_ptr)            \
       || ((SEC) == bfd_und_section_ptr)            \
       || ((SEC) == bfd_com_section_ptr)            \
       || ((SEC) == bfd_ind_section_ptr))

     /* Macros to handle insertion and deletion of a bfd's sections.  These
        only handle the list pointers, ie. do not adjust section_count,
        target_index etc.  */
     #define bfd_section_list_remove(ABFD, S) \
       do                                                   \
         {                                                  \
           asection *_s = S;                                \
           asection *_next = _s->next;                      \
           asection *_prev = _s->prev;                      \
           if (_prev)                                       \
             _prev->next = _next;                           \
           else                                             \
             (ABFD)->sections = _next;                      \
           if (_next)                                       \
             _next->prev = _prev;                           \
           else                                             \
             (ABFD)->section_last = _prev;                  \
         }                                                  \
       while (0)
     #define bfd_section_list_append(ABFD, S) \
       do                                                   \
         {                                                  \
           asection *_s = S;                                \
           bfd *_abfd = ABFD;                               \
           _s->next = NULL;                                 \
           if (_abfd->section_last)                         \
             {                                              \
               _s->prev = _abfd->section_last;              \
               _abfd->section_last->next = _s;              \
             }                                              \
           else                                             \
             {                                              \
               _s->prev = NULL;                             \
               _abfd->sections = _s;                        \
             }                                              \
           _abfd->section_last = _s;                        \
         }                                                  \
       while (0)
     #define bfd_section_list_prepend(ABFD, S) \
       do                                                   \
         {                                                  \
           asection *_s = S;                                \
           bfd *_abfd = ABFD;                               \
           _s->prev = NULL;                                 \
           if (_abfd->sections)                             \
             {                                              \
               _s->next = _abfd->sections;                  \
               _abfd->sections->prev = _s;                  \
             }                                              \
           else                                             \
             {                                              \
               _s->next = NULL;                             \
               _abfd->section_last = _s;                    \
             }                                              \
           _abfd->sections = _s;                            \
         }                                                  \
       while (0)
     #define bfd_section_list_insert_after(ABFD, A, S) \
       do                                                   \
         {                                                  \
           asection *_a = A;                                \
           asection *_s = S;                                \
           asection *_next = _a->next;                      \
           _s->next = _next;                                \
           _s->prev = _a;                                   \
           _a->next = _s;                                   \
           if (_next)                                       \
             _next->prev = _s;                              \
           else                                             \
             (ABFD)->section_last = _s;                     \
         }                                                  \
       while (0)
     #define bfd_section_list_insert_before(ABFD, B, S) \
       do                                                   \
         {                                                  \
           asection *_b = B;                                \
           asection *_s = S;                                \
           asection *_prev = _b->prev;                      \
           _s->prev = _prev;                                \
           _s->next = _b;                                   \
           _b->prev = _s;                                   \
           if (_prev)                                       \
             _prev->next = _s;                              \
           else                                             \
             (ABFD)->sections = _s;                         \
         }                                                  \
       while (0)
     #define bfd_section_removed_from_list(ABFD, S) \
       ((S)->next == NULL ? (ABFD)->section_last != (S) : (S)->next->prev != (S))

     #define BFD_FAKE_SECTION(SEC, SYM, NAME, IDX, FLAGS)                   \
       /* name, id,  index, next, prev, flags, user_set_vma,            */  \
       {  NAME, IDX, 0,     NULL, NULL, FLAGS, 0,                           \
                                                                            \
       /* linker_mark, linker_has_input, gc_mark, decompress_status,    */  \
          0,           0,                1,       0,                        \
                                                                            \
       /* segment_mark, sec_info_type, use_rela_p,                      */  \
          0,            0,             0,                                   \
                                                                            \
       /* sec_flg0, sec_flg1, sec_flg2, sec_flg3, sec_flg4, sec_flg5,   */  \
          0,        0,        0,        0,        0,        0,              \
                                                                            \
       /* vma, lma, size, rawsize, compressed_size, relax, relax_count, */  \
          0,   0,   0,    0,       0,               0,     0,               \
                                                                            \
       /* output_offset, output_section, alignment_power,               */  \
          0,             &SEC,           0,                                 \
                                                                            \
       /* relocation, orelocation, reloc_count, filepos, rel_filepos,   */  \
          NULL,       NULL,        0,           0,       0,                 \
                                                                            \
       /* line_filepos, userdata, contents, lineno, lineno_count,       */  \
          0,            NULL,     NULL,     NULL,   0,                      \
                                                                            \
       /* entsize, kept_section, moving_line_filepos,                    */ \
          0,       NULL,          0,                                        \
                                                                            \
       /* target_index, used_by_bfd, constructor_chain, owner,          */  \
          0,            NULL,        NULL,              NULL,               \
                                                                            \
       /* symbol,                    symbol_ptr_ptr,                    */  \
          (struct bfd_symbol *) SYM, &SEC.symbol,                           \
                                                                            \
       /* map_head, map_tail                                            */  \
          { NULL }, { NULL }                                                \
         }

     /* We use a macro to initialize the static asymbol structures because
        traditional C does not permit us to initialize a union member while
        gcc warns if we don't initialize it.
        the_bfd, name, value, attr, section [, udata]  */
     #ifdef __STDC__
     #define GLOBAL_SYM_INIT(NAME, SECTION) \
       { 0, NAME, 0, BSF_SECTION_SYM, SECTION, { 0 }}
     #else
     #define GLOBAL_SYM_INIT(NAME, SECTION) \
       { 0, NAME, 0, BSF_SECTION_SYM, SECTION }
     #endif


File: bfd.info,  Node: section prototypes,  Prev: typedef asection,  Up: Sections

2.6.5 Section prototypes
------------------------

These are the functions exported by the section handling part of BFD.

2.6.5.1 `bfd_section_list_clear'
................................

*Synopsis*
     void bfd_section_list_clear (bfd *);
   *Description*
Clears the section list, and also resets the section count and hash
table entries.

2.6.5.2 `bfd_get_section_by_name'
.................................

*Synopsis*
     asection *bfd_get_section_by_name (bfd *abfd, const char *name);
   *Description*
Return the most recently created section attached to ABFD named NAME.
Return NULL if no such section exists.

2.6.5.3 `bfd_get_next_section_by_name'
......................................

*Synopsis*
     asection *bfd_get_next_section_by_name (bfd *ibfd, asection *sec);
   *Description*
Given SEC is a section returned by `bfd_get_section_by_name', return
the next most recently created section attached to the same BFD with
the same name, or if no such section exists in the same BFD and IBFD is
non-NULL, the next section with the same name in any input BFD
following IBFD.  Return NULL on finding no section.

2.6.5.4 `bfd_get_linker_section'
................................

*Synopsis*
     asection *bfd_get_linker_section (bfd *abfd, const char *name);
   *Description*
Return the linker created section attached to ABFD named NAME.  Return
NULL if no such section exists.

2.6.5.5 `bfd_get_section_by_name_if'
....................................

*Synopsis*
     asection *bfd_get_section_by_name_if
        (bfd *abfd,
         const char *name,
         bfd_boolean (*func) (bfd *abfd, asection *sect, void *obj),
         void *obj);
   *Description*
Call the provided function FUNC for each section attached to the BFD
ABFD whose name matches NAME, passing OBJ as an argument. The function
will be called as if by

            func (abfd, the_section, obj);

   It returns the first section for which FUNC returns true, otherwise
`NULL'.

2.6.5.6 `bfd_get_unique_section_name'
.....................................

*Synopsis*
     char *bfd_get_unique_section_name
        (bfd *abfd, const char *templat, int *count);
   *Description*
Invent a section name that is unique in ABFD by tacking a dot and a
digit suffix onto the original TEMPLAT.  If COUNT is non-NULL, then it
specifies the first number tried as a suffix to generate a unique name.
The value pointed to by COUNT will be incremented in this case.

2.6.5.7 `bfd_make_section_old_way'
..................................

*Synopsis*
     asection *bfd_make_section_old_way (bfd *abfd, const char *name);
   *Description*
Create a new empty section called NAME and attach it to the end of the
chain of sections for the BFD ABFD. An attempt to create a section with
a name which is already in use returns its pointer without changing the
section chain.

   It has the funny name since this is the way it used to be before it
was rewritten....

   Possible errors are:
   * `bfd_error_invalid_operation' - If output has already started for
     this BFD.

   * `bfd_error_no_memory' - If memory allocation fails.

2.6.5.8 `bfd_make_section_anyway_with_flags'
............................................

*Synopsis*
     asection *bfd_make_section_anyway_with_flags
        (bfd *abfd, const char *name, flagword flags);
   *Description*
Create a new empty section called NAME and attach it to the end of the
chain of sections for ABFD.  Create a new section even if there is
already a section with that name.  Also set the attributes of the new
section to the value FLAGS.

   Return `NULL' and set `bfd_error' on error; possible errors are:
   * `bfd_error_invalid_operation' - If output has already started for
     ABFD.

   * `bfd_error_no_memory' - If memory allocation fails.

2.6.5.9 `bfd_make_section_anyway'
.................................

*Synopsis*
     asection *bfd_make_section_anyway (bfd *abfd, const char *name);
   *Description*
Create a new empty section called NAME and attach it to the end of the
chain of sections for ABFD.  Create a new section even if there is
already a section with that name.

   Return `NULL' and set `bfd_error' on error; possible errors are:
   * `bfd_error_invalid_operation' - If output has already started for
     ABFD.

   * `bfd_error_no_memory' - If memory allocation fails.

2.6.5.10 `bfd_make_section_with_flags'
......................................

*Synopsis*
     asection *bfd_make_section_with_flags
        (bfd *, const char *name, flagword flags);
   *Description*
Like `bfd_make_section_anyway', but return `NULL' (without calling
bfd_set_error ()) without changing the section chain if there is
already a section named NAME.  Also set the attributes of the new
section to the value FLAGS.  If there is an error, return `NULL' and set
`bfd_error'.

2.6.5.11 `bfd_make_section'
...........................

*Synopsis*
     asection *bfd_make_section (bfd *, const char *name);
   *Description*
Like `bfd_make_section_anyway', but return `NULL' (without calling
bfd_set_error ()) without changing the section chain if there is
already a section named NAME.  If there is an error, return `NULL' and
set `bfd_error'.

2.6.5.12 `bfd_set_section_flags'
................................

*Synopsis*
     bfd_boolean bfd_set_section_flags
        (bfd *abfd, asection *sec, flagword flags);
   *Description*
Set the attributes of the section SEC in the BFD ABFD to the value
FLAGS. Return `TRUE' on success, `FALSE' on error. Possible error
returns are:

   * `bfd_error_invalid_operation' - The section cannot have one or
     more of the attributes requested. For example, a .bss section in
     `a.out' may not have the `SEC_HAS_CONTENTS' field set.

2.6.5.13 `bfd_rename_section'
.............................

*Synopsis*
     void bfd_rename_section
        (bfd *abfd, asection *sec, const char *newname);
   *Description*
Rename section SEC in ABFD to NEWNAME.

2.6.5.14 `bfd_map_over_sections'
................................

*Synopsis*
     void bfd_map_over_sections
        (bfd *abfd,
         void (*func) (bfd *abfd, asection *sect, void *obj),
         void *obj);
   *Description*
Call the provided function FUNC for each section attached to the BFD
ABFD, passing OBJ as an argument. The function will be called as if by

            func (abfd, the_section, obj);

   This is the preferred method for iterating over sections; an
alternative would be to use a loop:

               asection *p;
               for (p = abfd->sections; p != NULL; p = p->next)
                  func (abfd, p, ...)

2.6.5.15 `bfd_sections_find_if'
...............................

*Synopsis*
     asection *bfd_sections_find_if
        (bfd *abfd,
         bfd_boolean (*operation) (bfd *abfd, asection *sect, void *obj),
         void *obj);
   *Description*
Call the provided function OPERATION for each section attached to the
BFD ABFD, passing OBJ as an argument. The function will be called as if
by

            operation (abfd, the_section, obj);

   It returns the first section for which OPERATION returns true.

2.6.5.16 `bfd_set_section_size'
...............................

*Synopsis*
     bfd_boolean bfd_set_section_size
        (bfd *abfd, asection *sec, bfd_size_type val);
   *Description*
Set SEC to the size VAL. If the operation is ok, then `TRUE' is
returned, else `FALSE'.

   Possible error returns:
   * `bfd_error_invalid_operation' - Writing has started to the BFD, so
     setting the size is invalid.

2.6.5.17 `bfd_set_section_contents'
...................................

*Synopsis*
     bfd_boolean bfd_set_section_contents
        (bfd *abfd, asection *section, const void *data,
         file_ptr offset, bfd_size_type count);
   *Description*
Sets the contents of the section SECTION in BFD ABFD to the data
starting in memory at LOCATION.  The data is written to the output
section starting at offset OFFSET for COUNT octets.

   Normally `TRUE' is returned, but `FALSE' is returned if there was an
error.  Possible error returns are:
   * `bfd_error_no_contents' - The output section does not have the
     `SEC_HAS_CONTENTS' attribute, so nothing can be written to it.

   * `bfd_error_bad_value' - The section is unable to contain all of
     the data.

   * `bfd_error_invalid_operation' - The BFD is not writeable.

   * and some more too.
   This routine is front end to the back end function
`_bfd_set_section_contents'.

2.6.5.18 `bfd_get_section_contents'
...................................

*Synopsis*
     bfd_boolean bfd_get_section_contents
        (bfd *abfd, asection *section, void *location, file_ptr offset,
         bfd_size_type count);
   *Description*
Read data from SECTION in BFD ABFD into memory starting at LOCATION.
The data is read at an offset of OFFSET from the start of the input
section, and is read for COUNT bytes.

   If the contents of a constructor with the `SEC_CONSTRUCTOR' flag set
are requested or if the section does not have the `SEC_HAS_CONTENTS'
flag set, then the LOCATION is filled with zeroes. If no errors occur,
`TRUE' is returned, else `FALSE'.

2.6.5.19 `bfd_malloc_and_get_section'
.....................................

*Synopsis*
     bfd_boolean bfd_malloc_and_get_section
        (bfd *abfd, asection *section, bfd_byte **buf);
   *Description*
Read all data from SECTION in BFD ABFD into a buffer, *BUF, malloc'd by
this function.

2.6.5.20 `bfd_copy_private_section_data'
........................................

*Synopsis*
     bfd_boolean bfd_copy_private_section_data
        (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);
   *Description*
Copy private section information from ISEC in the BFD IBFD to the
section OSEC in the BFD OBFD.  Return `TRUE' on success, `FALSE' on
error.  Possible error returns are:

   * `bfd_error_no_memory' - Not enough memory exists to create private
     data for OSEC.

     #define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \
            BFD_SEND (obfd, _bfd_copy_private_section_data, \
                      (ibfd, isection, obfd, osection))

2.6.5.21 `bfd_generic_is_group_section'
.......................................

*Synopsis*
     bfd_boolean bfd_generic_is_group_section (bfd *, const asection *sec);
   *Description*
Returns TRUE if SEC is a member of a group.

2.6.5.22 `bfd_generic_discard_group'
....................................

*Synopsis*
     bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);
   *Description*
Remove all members of GROUP from the output.


File: bfd.info,  Node: Symbols,  Next: Archives,  Prev: Sections,  Up: BFD front end

2.7 Symbols
===========

BFD tries to maintain as much symbol information as it can when it
moves information from file to file. BFD passes information to
applications though the `asymbol' structure. When the application
requests the symbol table, BFD reads the table in the native form and
translates parts of it into the internal format. To maintain more than
the information passed to applications, some targets keep some
information "behind the scenes" in a structure only the particular back
end knows about. For example, the coff back end keeps the original
symbol table structure as well as the canonical structure when a BFD is
read in. On output, the coff back end can reconstruct the output symbol
table so that no information is lost, even information unique to coff
which BFD doesn't know or understand. If a coff symbol table were read,
but were written through an a.out back end, all the coff specific
information would be lost. The symbol table of a BFD is not necessarily
read in until a canonicalize request is made. Then the BFD back end
fills in a table provided by the application with pointers to the
canonical information.  To output symbols, the application provides BFD
with a table of pointers to pointers to `asymbol's. This allows
applications like the linker to output a symbol as it was read, since
the "behind the scenes" information will be still available.

* Menu:

* Reading Symbols::
* Writing Symbols::
* Mini Symbols::
* typedef asymbol::
* symbol handling functions::


File: bfd.info,  Node: Reading Symbols,  Next: Writing Symbols,  Prev: Symbols,  Up: Symbols

2.7.1 Reading symbols
---------------------

There are two stages to reading a symbol table from a BFD: allocating
storage, and the actual reading process. This is an excerpt from an
application which reads the symbol table:

              long storage_needed;
              asymbol **symbol_table;
              long number_of_symbols;
              long i;

              storage_needed = bfd_get_symtab_upper_bound (abfd);

              if (storage_needed < 0)
                FAIL

              if (storage_needed == 0)
                return;

              symbol_table = xmalloc (storage_needed);
                ...
              number_of_symbols =
                 bfd_canonicalize_symtab (abfd, symbol_table);

              if (number_of_symbols < 0)
                FAIL

              for (i = 0; i < number_of_symbols; i++)
                process_symbol (symbol_table[i]);

   All storage for the symbols themselves is in an objalloc connected
to the BFD; it is freed when the BFD is closed.


File: bfd.info,  Node: Writing Symbols,  Next: Mini Symbols,  Prev: Reading Symbols,  Up: Symbols

2.7.2 Writing symbols
---------------------

Writing of a symbol table is automatic when a BFD open for writing is
closed. The application attaches a vector of pointers to pointers to
symbols to the BFD being written, and fills in the symbol count. The
close and cleanup code reads through the table provided and performs
all the necessary operations. The BFD output code must always be
provided with an "owned" symbol: one which has come from another BFD,
or one which has been created using `bfd_make_empty_symbol'.  Here is an
example showing the creation of a symbol table with only one element:

            #include "sysdep.h"
            #include "bfd.h"
            int main (void)
            {
              bfd *abfd;
              asymbol *ptrs[2];
              asymbol *new;

              abfd = bfd_openw ("foo","a.out-sunos-big");
              bfd_set_format (abfd, bfd_object);
              new = bfd_make_empty_symbol (abfd);
              new->name = "dummy_symbol";
              new->section = bfd_make_section_old_way (abfd, ".text");
              new->flags = BSF_GLOBAL;
              new->value = 0x12345;

              ptrs[0] = new;
              ptrs[1] = 0;

              bfd_set_symtab (abfd, ptrs, 1);
              bfd_close (abfd);
              return 0;
            }

            ./makesym
            nm foo
            00012345 A dummy_symbol

   Many formats cannot represent arbitrary symbol information; for
instance, the `a.out' object format does not allow an arbitrary number
of sections. A symbol pointing to a section which is not one  of
`.text', `.data' or `.bss' cannot be described.


File: bfd.info,  Node: Mini Symbols,  Next: typedef asymbol,  Prev: Writing Symbols,  Up: Symbols

2.7.3 Mini Symbols
------------------

Mini symbols provide read-only access to the symbol table.  They use
less memory space, but require more time to access.  They can be useful
for tools like nm or objdump, which may have to handle symbol tables of
extremely large executables.

   The `bfd_read_minisymbols' function will read the symbols into
memory in an internal form.  It will return a `void *' pointer to a
block of memory, a symbol count, and the size of each symbol.  The
pointer is allocated using `malloc', and should be freed by the caller
when it is no longer needed.

   The function `bfd_minisymbol_to_symbol' will take a pointer to a
minisymbol, and a pointer to a structure returned by
`bfd_make_empty_symbol', and return a `asymbol' structure.  The return
value may or may not be the same as the value from
`bfd_make_empty_symbol' which was passed in.


File: bfd.info,  Node: typedef asymbol,  Next: symbol handling functions,  Prev: Mini Symbols,  Up: Symbols

2.7.4 typedef asymbol
---------------------

An `asymbol' has the form:


     typedef struct bfd_symbol
     {
       /* A pointer to the BFD which owns the symbol. This information
          is necessary so that a back end can work out what additional
          information (invisible to the application writer) is carried
          with the symbol.

          This field is *almost* redundant, since you can use section->owner
          instead, except that some symbols point to the global sections
          bfd_{abs,com,und}_section.  This could be fixed by making
          these globals be per-bfd (or per-target-flavor).  FIXME.  */
       struct bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field.  */

       /* The text of the symbol. The name is left alone, and not copied; the
          application may not alter it.  */
       const char *name;

       /* The value of the symbol.  This really should be a union of a
          numeric value with a pointer, since some flags indicate that
          a pointer to another symbol is stored here.  */
       symvalue value;

       /* Attributes of a symbol.  */
     #define BSF_NO_FLAGS            0

       /* The symbol has local scope; `static' in `C'. The value
          is the offset into the section of the data.  */
     #define BSF_LOCAL               (1 << 0)

       /* The symbol has global scope; initialized data in `C'. The
          value is the offset into the section of the data.  */
     #define BSF_GLOBAL              (1 << 1)

       /* The symbol has global scope and is exported. The value is
          the offset into the section of the data.  */
     #define BSF_EXPORT              BSF_GLOBAL /* No real difference.  */

       /* A normal C symbol would be one of:
          `BSF_LOCAL', `BSF_UNDEFINED' or `BSF_GLOBAL'.  */

       /* The symbol is a debugging record. The value has an arbitrary
          meaning, unless BSF_DEBUGGING_RELOC is also set.  */
     #define BSF_DEBUGGING           (1 << 2)

       /* The symbol denotes a function entry point.  Used in ELF,
          perhaps others someday.  */
     #define BSF_FUNCTION            (1 << 3)

       /* Used by the linker.  */
     #define BSF_KEEP                (1 << 5)

       /* An ELF common symbol.  */
     #define BSF_ELF_COMMON          (1 << 6)

       /* A weak global symbol, overridable without warnings by
          a regular global symbol of the same name.  */
     #define BSF_WEAK                (1 << 7)

       /* This symbol was created to point to a section, e.g. ELF's
          STT_SECTION symbols.  */
     #define BSF_SECTION_SYM         (1 << 8)

       /* The symbol used to be a common symbol, but now it is
          allocated.  */
     #define BSF_OLD_COMMON          (1 << 9)

       /* In some files the type of a symbol sometimes alters its
          location in an output file - ie in coff a `ISFCN' symbol
          which is also `C_EXT' symbol appears where it was
          declared and not at the end of a section.  This bit is set
          by the target BFD part to convey this information.  */
     #define BSF_NOT_AT_END          (1 << 10)

       /* Signal that the symbol is the label of constructor section.  */
     #define BSF_CONSTRUCTOR         (1 << 11)

       /* Signal that the symbol is a warning symbol.  The name is a
          warning.  The name of the next symbol is the one to warn about;
          if a reference is made to a symbol with the same name as the next
          symbol, a warning is issued by the linker.  */
     #define BSF_WARNING             (1 << 12)

       /* Signal that the symbol is indirect.  This symbol is an indirect
          pointer to the symbol with the same name as the next symbol.  */
     #define BSF_INDIRECT            (1 << 13)

       /* BSF_FILE marks symbols that contain a file name.  This is used
          for ELF STT_FILE symbols.  */
     #define BSF_FILE                (1 << 14)

       /* Symbol is from dynamic linking information.  */
     #define BSF_DYNAMIC             (1 << 15)

       /* The symbol denotes a data object.  Used in ELF, and perhaps
          others someday.  */
     #define BSF_OBJECT              (1 << 16)

       /* This symbol is a debugging symbol.  The value is the offset
          into the section of the data.  BSF_DEBUGGING should be set
          as well.  */
     #define BSF_DEBUGGING_RELOC     (1 << 17)

       /* This symbol is thread local.  Used in ELF.  */
     #define BSF_THREAD_LOCAL        (1 << 18)

       /* This symbol represents a complex relocation expression,
          with the expression tree serialized in the symbol name.  */
     #define BSF_RELC                (1 << 19)

       /* This symbol represents a signed complex relocation expression,
          with the expression tree serialized in the symbol name.  */
     #define BSF_SRELC               (1 << 20)

       /* This symbol was created by bfd_get_synthetic_symtab.  */
     #define BSF_SYNTHETIC           (1 << 21)

       /* This symbol is an indirect code object.  Unrelated to BSF_INDIRECT.
          The dynamic linker will compute the value of this symbol by
          calling the function that it points to.  BSF_FUNCTION must
          also be also set.  */
     #define BSF_GNU_INDIRECT_FUNCTION (1 << 22)
       /* This symbol is a globally unique data object.  The dynamic linker
          will make sure that in the entire process there is just one symbol
          with this name and type in use.  BSF_OBJECT must also be set.  */
     #define BSF_GNU_UNIQUE          (1 << 23)

       flagword flags;

       /* A pointer to the section to which this symbol is
          relative.  This will always be non NULL, there are special
          sections for undefined and absolute symbols.  */
       struct bfd_section *section;

       /* Back end special data.  */
       union
         {
           void *p;
           bfd_vma i;
         }
       udata;
     }
     asymbol;


File: bfd.info,  Node: symbol handling functions,  Prev: typedef asymbol,  Up: Symbols

2.7.5 Symbol handling functions
-------------------------------

2.7.5.1 `bfd_get_symtab_upper_bound'
....................................

*Description*
Return the number of bytes required to store a vector of pointers to
`asymbols' for all the symbols in the BFD ABFD, including a terminal
NULL pointer. If there are no symbols in the BFD, then return 0.  If an
error occurs, return -1.
     #define bfd_get_symtab_upper_bound(abfd) \
            BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))

2.7.5.2 `bfd_is_local_label'
............................

*Synopsis*
     bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);
   *Description*
Return TRUE if the given symbol SYM in the BFD ABFD is a compiler
generated local label, else return FALSE.

2.7.5.3 `bfd_is_local_label_name'
.................................

*Synopsis*
     bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);
   *Description*
Return TRUE if a symbol with the name NAME in the BFD ABFD is a
compiler generated local label, else return FALSE.  This just checks
whether the name has the form of a local label.
     #define bfd_is_local_label_name(abfd, name) \
            BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))

2.7.5.4 `bfd_is_target_special_symbol'
......................................

*Synopsis*
     bfd_boolean bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);
   *Description*
Return TRUE iff a symbol SYM in the BFD ABFD is something special to
the particular target represented by the BFD.  Such symbols should
normally not be mentioned to the user.
     #define bfd_is_target_special_symbol(abfd, sym) \
            BFD_SEND (abfd, _bfd_is_target_special_symbol, (abfd, sym))

2.7.5.5 `bfd_canonicalize_symtab'
.................................

*Description*
Read the symbols from the BFD ABFD, and fills in the vector LOCATION
with pointers to the symbols and a trailing NULL.  Return the actual
number of symbol pointers, not including the NULL.
     #define bfd_canonicalize_symtab(abfd, location) \
            BFD_SEND (abfd, _bfd_canonicalize_symtab, (abfd, location))

2.7.5.6 `bfd_set_symtab'
........................

*Synopsis*
     bfd_boolean bfd_set_symtab
        (bfd *abfd, asymbol **location, unsigned int count);
   *Description*
Arrange that when the output BFD ABFD is closed, the table LOCATION of
COUNT pointers to symbols will be written.

2.7.5.7 `bfd_print_symbol_vandf'
................................

*Synopsis*
     void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);
   *Description*
Print the value and flags of the SYMBOL supplied to the stream FILE.

2.7.5.8 `bfd_make_empty_symbol'
...............................

*Description*
Create a new `asymbol' structure for the BFD ABFD and return a pointer
to it.

   This routine is necessary because each back end has private
information surrounding the `asymbol'. Building your own `asymbol' and
pointing to it will not create the private information, and will cause
problems later on.
     #define bfd_make_empty_symbol(abfd) \
            BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))

2.7.5.9 `_bfd_generic_make_empty_symbol'
........................................

*Synopsis*
     asymbol *_bfd_generic_make_empty_symbol (bfd *);
   *Description*
Create a new `asymbol' structure for the BFD ABFD and return a pointer
to it.  Used by core file routines, binary back-end and anywhere else
where no private info is needed.

2.7.5.10 `bfd_make_debug_symbol'
................................

*Description*
Create a new `asymbol' structure for the BFD ABFD, to be used as a
debugging symbol.  Further details of its use have yet to be worked out.
     #define bfd_make_debug_symbol(abfd,ptr,size) \
            BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))

2.7.5.11 `bfd_decode_symclass'
..............................

*Description*
Return a character corresponding to the symbol class of SYMBOL, or '?'
for an unknown class.

   *Synopsis*
     int bfd_decode_symclass (asymbol *symbol);
   
2.7.5.12 `bfd_is_undefined_symclass'
....................................

*Description*
Returns non-zero if the class symbol returned by bfd_decode_symclass
represents an undefined symbol.  Returns zero otherwise.

   *Synopsis*
     bfd_boolean bfd_is_undefined_symclass (int symclass);
   
2.7.5.13 `bfd_symbol_info'
..........................

*Description*
Fill in the basic info about symbol that nm needs.  Additional info may
be added by the back-ends after calling this function.

   *Synopsis*
     void bfd_symbol_info (asymbol *symbol, symbol_info *ret);
   
2.7.5.14 `bfd_copy_private_symbol_data'
.......................................

*Synopsis*
     bfd_boolean bfd_copy_private_symbol_data
        (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
   *Description*
Copy private symbol information from ISYM in the BFD IBFD to the symbol
OSYM in the BFD OBFD.  Return `TRUE' on success, `FALSE' on error.
Possible error returns are:

   * `bfd_error_no_memory' - Not enough memory exists to create private
     data for OSEC.

     #define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \
            BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
                      (ibfd, isymbol, obfd, osymbol))


File: bfd.info,  Node: Archives,  Next: Formats,  Prev: Symbols,  Up: BFD front end

2.8 Archives
============

*Description*
An archive (or library) is just another BFD.  It has a symbol table,
although there's not much a user program will do with it.

   The big difference between an archive BFD and an ordinary BFD is
that the archive doesn't have sections.  Instead it has a chain of BFDs
that are considered its contents.  These BFDs can be manipulated like
any other.  The BFDs contained in an archive opened for reading will
all be opened for reading.  You may put either input or output BFDs
into an archive opened for output; they will be handled correctly when
the archive is closed.

   Use `bfd_openr_next_archived_file' to step through the contents of
an archive opened for input.  You don't have to read the entire archive
if you don't want to!  Read it until you find what you want.

   A BFD returned by `bfd_openr_next_archived_file' can be closed
manually with `bfd_close'.  If you do not close it, then a second
iteration through the members of an archive may return the same BFD.
If you close the archive BFD, then all the member BFDs will
automatically be closed as well.

   Archive contents of output BFDs are chained through the
`archive_next' pointer in a BFD.  The first one is findable through the
`archive_head' slot of the archive.  Set it with `bfd_set_archive_head'
(q.v.).  A given BFD may be in only one open output archive at a time.

   As expected, the BFD archive code is more general than the archive
code of any given environment.  BFD archives may contain files of
different formats (e.g., a.out and coff) and even different
architectures.  You may even place archives recursively into archives!

   This can cause unexpected confusion, since some archive formats are
more expressive than others.  For instance, Intel COFF archives can
preserve long filenames; SunOS a.out archives cannot.  If you move a
file from the first to the second format and back again, the filename
may be truncated.  Likewise, different a.out environments have different
conventions as to how they truncate filenames, whether they preserve
directory names in filenames, etc.  When interoperating with native
tools, be sure your files are homogeneous.

   Beware: most of these formats do not react well to the presence of
spaces in filenames.  We do the best we can, but can't always handle
this case due to restrictions in the format of archives.  Many Unix
utilities are braindead in regards to spaces and such in filenames
anyway, so this shouldn't be much of a restriction.

   Archives are supported in BFD in `archive.c'.

2.8.1 Archive functions
-----------------------

2.8.1.1 `bfd_get_next_mapent'
.............................

*Synopsis*
     symindex bfd_get_next_mapent
        (bfd *abfd, symindex previous, carsym **sym);
   *Description*
Step through archive ABFD's symbol table (if it has one).  Successively
update SYM with the next symbol's information, returning that symbol's
(internal) index into the symbol table.

   Supply `BFD_NO_MORE_SYMBOLS' as the PREVIOUS entry to get the first
one; returns `BFD_NO_MORE_SYMBOLS' when you've already got the last one.

   A `carsym' is a canonical archive symbol.  The only user-visible
element is its name, a null-terminated string.

2.8.1.2 `bfd_set_archive_head'
..............................

*Synopsis*
     bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);
   *Description*
Set the head of the chain of BFDs contained in the archive OUTPUT to
NEW_HEAD.

2.8.1.3 `bfd_openr_next_archived_file'
......................................

*Synopsis*
     bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);
   *Description*
Provided a BFD, ARCHIVE, containing an archive and NULL, open an input
BFD on the first contained element and returns that.  Subsequent calls
should pass the archive and the previous return value to return a
created BFD to the next contained element.  NULL is returned when there
are no more.  Note - if you want to process the bfd returned by this
call be sure to call bfd_check_format() on it first.


File: bfd.info,  Node: Formats,  Next: Relocations,  Prev: Archives,  Up: BFD front end

2.9 File formats
================

A format is a BFD concept of high level file contents type. The formats
supported by BFD are:

   * `bfd_object'
   The BFD may contain data, symbols, relocations and debug info.

   * `bfd_archive'
   The BFD contains other BFDs and an optional index.

   * `bfd_core'
   The BFD contains the result of an executable core dump.

2.9.1 File format functions
---------------------------

2.9.1.1 `bfd_check_format'
..........................

*Synopsis*
     bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);
   *Description*
Verify if the file attached to the BFD ABFD is compatible with the
format FORMAT (i.e., one of `bfd_object', `bfd_archive' or `bfd_core').

   If the BFD has been set to a specific target before the call, only
the named target and format combination is checked. If the target has
not been set, or has been set to `default', then all the known target
backends is interrogated to determine a match.  If the default target
matches, it is used.  If not, exactly one target must recognize the
file, or an error results.

   The function returns `TRUE' on success, otherwise `FALSE' with one
of the following error codes:

   * `bfd_error_invalid_operation' - if `format' is not one of
     `bfd_object', `bfd_archive' or `bfd_core'.

   * `bfd_error_system_call' - if an error occured during a read - even
     some file mismatches can cause bfd_error_system_calls.

   * `file_not_recognised' - none of the backends recognised the file
     format.

   * `bfd_error_file_ambiguously_recognized' - more than one backend
     recognised the file format.

2.9.1.2 `bfd_check_format_matches'
..................................

*Synopsis*
     bfd_boolean bfd_check_format_matches
        (bfd *abfd, bfd_format format, char ***matching);
   *Description*
Like `bfd_check_format', except when it returns FALSE with `bfd_errno'
set to `bfd_error_file_ambiguously_recognized'.  In that case, if
MATCHING is not NULL, it will be filled in with a NULL-terminated list
of the names of the formats that matched, allocated with `malloc'.
Then the user may choose a format and try again.

   When done with the list that MATCHING points to, the caller should
free it.

2.9.1.3 `bfd_set_format'
........................

*Synopsis*
     bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);
   *Description*
This function sets the file format of the BFD ABFD to the format
FORMAT. If the target set in the BFD does not support the format
requested, the format is invalid, or the BFD is not open for writing,
then an error occurs.

2.9.1.4 `bfd_format_string'
...........................

*Synopsis*
     const char *bfd_format_string (bfd_format format);
   *Description*
Return a pointer to a const string `invalid', `object', `archive',
`core', or `unknown', depending upon the value of FORMAT.


File: bfd.info,  Node: Relocations,  Next: Core Files,  Prev: Formats,  Up: BFD front end

2.10 Relocations
================

BFD maintains relocations in much the same way it maintains symbols:
they are left alone until required, then read in en-masse and
translated into an internal form.  A common routine
`bfd_perform_relocation' acts upon the canonical form to do the fixup.

   Relocations are maintained on a per section basis, while symbols are
maintained on a per BFD basis.

   All that a back end has to do to fit the BFD interface is to create
a `struct reloc_cache_entry' for each relocation in a particular
section, and fill in the right bits of the structures.

* Menu:

* typedef arelent::
* howto manager::


File: bfd.info,  Node: typedef arelent,  Next: howto manager,  Prev: Relocations,  Up: Relocations

2.10.1 typedef arelent
----------------------

This is the structure of a relocation entry:


     typedef enum bfd_reloc_status
     {
       /* No errors detected.  Note - the value 2 is used so that it
          will not be mistaken for the boolean TRUE or FALSE values.  */
       bfd_reloc_ok = 2,

       /* The relocation was performed, but there was an overflow.  */
       bfd_reloc_overflow,

       /* The address to relocate was not within the section supplied.  */
       bfd_reloc_outofrange,

       /* Used by special functions.  */
       bfd_reloc_continue,

       /* Unsupported relocation size requested.  */
       bfd_reloc_notsupported,

       /* Unused.  */
       bfd_reloc_other,

       /* The symbol to relocate against was undefined.  */
       bfd_reloc_undefined,

       /* The relocation was performed, but may not be ok.  If this type is
          returned, the error_message argument to bfd_perform_relocation
          will be set.  */
       bfd_reloc_dangerous
      }
      bfd_reloc_status_type;

     typedef const struct reloc_howto_struct reloc_howto_type;

     typedef struct reloc_cache_entry
     {
       /* A pointer into the canonical table of pointers.  */
       struct bfd_symbol **sym_ptr_ptr;

       /* offset in section.  */
       bfd_size_type address;

       /* addend for relocation value.  */
       bfd_vma addend;

       /* Pointer to how to perform the required relocation.  */
       reloc_howto_type *howto;

     }
     arelent;
   *Description*
Here is a description of each of the fields within an `arelent':

   * `sym_ptr_ptr'
   The symbol table pointer points to a pointer to the symbol
associated with the relocation request.  It is the pointer into the
table returned by the back end's `canonicalize_symtab' action. *Note
Symbols::. The symbol is referenced through a pointer to a pointer so
that tools like the linker can fix up all the symbols of the same name
by modifying only one pointer. The relocation routine looks in the
symbol and uses the base of the section the symbol is attached to and
the value of the symbol as the initial relocation offset. If the symbol
pointer is zero, then the section provided is looked up.

   * `address'
   The `address' field gives the offset in bytes from the base of the
section data which owns the relocation record to the first byte of
relocatable information. The actual data relocated will be relative to
this point; for example, a relocation type which modifies the bottom
two bytes of a four byte word would not touch the first byte pointed to
in a big endian world.

   * `addend'
   The `addend' is a value provided by the back end to be added (!)  to
the relocation offset. Its interpretation is dependent upon the howto.
For example, on the 68k the code:

             char foo[];
             main()
                     {
                     return foo[0x12345678];
                     }

   Could be compiled into:

             linkw fp,#-4
             moveb @#12345678,d0
             extbl d0
             unlk fp
             rts

   This could create a reloc pointing to `foo', but leave the offset in
the data, something like:

     RELOCATION RECORDS FOR [.text]:
     offset   type      value
     00000006 32        _foo

     00000000 4e56 fffc          ; linkw fp,#-4
     00000004 1039 1234 5678     ; moveb @#12345678,d0
     0000000a 49c0               ; extbl d0
     0000000c 4e5e               ; unlk fp
     0000000e 4e75               ; rts

   Using coff and an 88k, some instructions don't have enough space in
them to represent the full address range, and pointers have to be
loaded in two parts. So you'd get something like:

             or.u     r13,r0,hi16(_foo+0x12345678)
             ld.b     r2,r13,lo16(_foo+0x12345678)
             jmp      r1

   This should create two relocs, both pointing to `_foo', and with
0x12340000 in their addend field. The data would consist of:

     RELOCATION RECORDS FOR [.text]:
     offset   type      value
     00000002 HVRT16    _foo+0x12340000
     00000006 LVRT16    _foo+0x12340000

     00000000 5da05678           ; or.u r13,r0,0x5678
     00000004 1c4d5678           ; ld.b r2,r13,0x5678
     00000008 f400c001           ; jmp r1

   The relocation routine digs out the value from the data, adds it to
the addend to get the original offset, and then adds the value of
`_foo'. Note that all 32 bits have to be kept around somewhere, to cope
with carry from bit 15 to bit 16.

   One further example is the sparc and the a.out format. The sparc has
a similar problem to the 88k, in that some instructions don't have room
for an entire offset, but on the sparc the parts are created in odd
sized lumps. The designers of the a.out format chose to not use the
data within the section for storing part of the offset; all the offset
is kept within the reloc. Anything in the data should be ignored.

             save %sp,-112,%sp
             sethi %hi(_foo+0x12345678),%g2
             ldsb [%g2+%lo(_foo+0x12345678)],%i0
             ret
             restore

   Both relocs contain a pointer to `foo', and the offsets contain junk.

     RELOCATION RECORDS FOR [.text]:
     offset   type      value
     00000004 HI22      _foo+0x12345678
     00000008 LO10      _foo+0x12345678

     00000000 9de3bf90     ; save %sp,-112,%sp
     00000004 05000000     ; sethi %hi(_foo+0),%g2
     00000008 f048a000     ; ldsb [%g2+%lo(_foo+0)],%i0
     0000000c 81c7e008     ; ret
     00000010 81e80000     ; restore

   * `howto'
   The `howto' field can be imagined as a relocation instruction. It is
a pointer to a structure which contains information on what to do with
all of the other information in the reloc record and data section. A
back end would normally have a relocation instruction set and turn
relocations into pointers to the correct structure on input - but it
would be possible to create each howto field on demand.

2.10.1.1 `enum complain_overflow'
.................................

Indicates what sort of overflow checking should be done when performing
a relocation.


     enum complain_overflow
     {
       /* Do not complain on overflow.  */
       complain_overflow_dont,

       /* Complain if the value overflows when considered as a signed
          number one bit larger than the field.  ie. A bitfield of N bits
          is allowed to represent -2**n to 2**n-1.  */
       complain_overflow_bitfield,

       /* Complain if the value overflows when considered as a signed
          number.  */
       complain_overflow_signed,

       /* Complain if the value overflows when considered as an
          unsigned number.  */
       complain_overflow_unsigned
     };

2.10.1.2 `reloc_howto_type'
...........................

The `reloc_howto_type' is a structure which contains all the
information that libbfd needs to know to tie up a back end's data.

     struct reloc_howto_struct
     {
       /* The type field has mainly a documentary use - the back end can
          do what it wants with it, though normally the back end's idea of
          an external reloc number is stored in this field.  */
       unsigned int type;

       /* The encoded size of the item to be relocated.  This is *not* a
          power-of-two measure.  Use bfd_get_reloc_size to find the size
          of the item in bytes.  */
       unsigned int size:3;

       /* The number of bits in the field to be relocated.  This is used
          when doing overflow checking.  */
       unsigned int bitsize:7;

       /* The value the final relocation is shifted right by.  This drops
          unwanted data from the relocation.  */
       unsigned int rightshift:6;

       /* The bit position of the reloc value in the destination.
          The relocated value is left shifted by this amount.  */
       unsigned int bitpos:6;

       /* What type of overflow error should be checked for when
          relocating.  */
       ENUM_BITFIELD (complain_overflow) complain_on_overflow:2;

       /* The relocation value should be negated before applying.  */
       unsigned int negate:1;

       /* The relocation is relative to the item being relocated.  */
       unsigned int pc_relative:1;

       /* Some formats record a relocation addend in the section contents
          rather than with the relocation.  For ELF formats this is the
          distinction between USE_REL and USE_RELA (though the code checks
          for USE_REL == 1/0).  The value of this field is TRUE if the
          addend is recorded with the section contents; when performing a
          partial link (ld -r) the section contents (the data) will be
          modified.  The value of this field is FALSE if addends are
          recorded with the relocation (in arelent.addend); when performing
          a partial link the relocation will be modified.
          All relocations for all ELF USE_RELA targets should set this field
          to FALSE (values of TRUE should be looked on with suspicion).
          However, the converse is not true: not all relocations of all ELF
          USE_REL targets set this field to TRUE.  Why this is so is peculiar
          to each particular target.  For relocs that aren't used in partial
          links (e.g. GOT stuff) it doesn't matter what this is set to.  */
       unsigned int partial_inplace:1;

       /* When some formats create PC relative instructions, they leave
          the value of the pc of the place being relocated in the offset
          slot of the instruction, so that a PC relative relocation can
          be made just by adding in an ordinary offset (e.g., sun3 a.out).
          Some formats leave the displacement part of an instruction
          empty (e.g., ELF); this flag signals the fact.  */
       unsigned int pcrel_offset:1;

       /* src_mask selects the part of the instruction (or data) to be used
          in the relocation sum.  If the target relocations don't have an
          addend in the reloc, eg. ELF USE_REL, src_mask will normally equal
          dst_mask to extract the addend from the section contents.  If
          relocations do have an addend in the reloc, eg. ELF USE_RELA, this
          field should normally be zero.  Non-zero values for ELF USE_RELA
          targets should be viewed with suspicion as normally the value in
          the dst_mask part of the section contents should be ignored.  */
       bfd_vma src_mask;

       /* dst_mask selects which parts of the instruction (or data) are
          replaced with a relocated value.  */
       bfd_vma dst_mask;

       /* If this field is non null, then the supplied function is
          called rather than the normal function.  This allows really
          strange relocation methods to be accommodated.  */
       bfd_reloc_status_type (*special_function)
         (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
          bfd *, char **);

       /* The textual name of the relocation type.  */
       char *name;
     };
   
2.10.1.3 `The HOWTO Macro'
..........................

*Description*
The HOWTO macro fills in a reloc_howto_type (a typedef for const struct
reloc_howto_struct).
     #define HOWTO(type, right, size, bits, pcrel, left, ovf, func, name,   \
                   inplace, src_mask, dst_mask, pcrel_off)                  \
       { (unsigned) type, size < 0 ? -size : size, bits, right, left, ovf,  \
         size < 0, pcrel, inplace, pcrel_off, src_mask, dst_mask, func, name }

   *Description*
This is used to fill in an empty howto entry in an array.
     #define EMPTY_HOWTO(C) \
       HOWTO ((C), 0, 0, 0, FALSE, 0, complain_overflow_dont, NULL, \
              NULL, FALSE, 0, 0, FALSE)

2.10.1.4 `bfd_get_reloc_size'
.............................

*Synopsis*
     unsigned int bfd_get_reloc_size (reloc_howto_type *);
   *Description*
For a reloc_howto_type that operates on a fixed number of bytes, this
returns the number of bytes operated on.

2.10.1.5 `arelent_chain'
........................

*Description*
How relocs are tied together in an `asection':
     typedef struct relent_chain
     {
       arelent relent;
       struct relent_chain *next;
     }
     arelent_chain;

2.10.1.6 `bfd_check_overflow'
.............................

*Synopsis*
     bfd_reloc_status_type bfd_check_overflow
        (enum complain_overflow how,
         unsigned int bitsize,
         unsigned int rightshift,
         unsigned int addrsize,
         bfd_vma relocation);
   *Description*
Perform overflow checking on RELOCATION which has BITSIZE significant
bits and will be shifted right by RIGHTSHIFT bits, on a machine with
addresses containing ADDRSIZE significant bits.  The result is either of
`bfd_reloc_ok' or `bfd_reloc_overflow'.

2.10.1.7 `bfd_reloc_offset_in_range'
....................................

*Synopsis*
     bfd_boolean bfd_reloc_offset_in_range
        (reloc_howto_type *howto,
         bfd *abfd,
         asection *section,
         bfd_size_type offset);
   *Description*
Returns TRUE if the reloc described by HOWTO can be applied at OFFSET
octets in SECTION.

2.10.1.8 `bfd_perform_relocation'
.................................

*Synopsis*
     bfd_reloc_status_type bfd_perform_relocation
        (bfd *abfd,
         arelent *reloc_entry,
         void *data,
         asection *input_section,
         bfd *output_bfd,
         char **error_message);
   *Description*
If OUTPUT_BFD is supplied to this function, the generated image will be
relocatable; the relocations are copied to the output file after they
have been changed to reflect the new state of the world. There are two
ways of reflecting the results of partial linkage in an output file: by
modifying the output data in place, and by modifying the relocation
record.  Some native formats (e.g., basic a.out and basic coff) have no
way of specifying an addend in the relocation type, so the addend has
to go in the output data.  This is no big deal since in these formats
the output data slot will always be big enough for the addend. Complex
reloc types with addends were invented to solve just this problem.  The
ERROR_MESSAGE argument is set to an error message if this return
`bfd_reloc_dangerous'.

2.10.1.9 `bfd_install_relocation'
.................................

*Synopsis*
     bfd_reloc_status_type bfd_install_relocation
        (bfd *abfd,
         arelent *reloc_entry,
         void *data, bfd_vma data_start,
         asection *input_section,
         char **error_message);
   *Description*
This looks remarkably like `bfd_perform_relocation', except it does not
expect that the section contents have been filled in.  I.e., it's
suitable for use when creating, rather than applying a relocation.

   For now, this function should be considered reserved for the
assembler.


File: bfd.info,  Node: howto manager,  Prev: typedef arelent,  Up: Relocations

2.10.2 The howto manager
------------------------

When an application wants to create a relocation, but doesn't know what
the target machine might call it, it can find out by using this bit of
code.

2.10.2.1 `bfd_reloc_code_type'
..............................

*Description*
The insides of a reloc code.  The idea is that, eventually, there will
be one enumerator for every type of relocation we ever do.  Pass one of
these values to `bfd_reloc_type_lookup', and it'll return a howto
pointer.

   This does mean that the application must determine the correct
enumerator value; you can't get a howto pointer from a random set of
attributes.

   Here are the possible values for `enum bfd_reloc_code_real':

 -- : BFD_RELOC_64
 -- : BFD_RELOC_32
 -- : BFD_RELOC_26
 -- : BFD_RELOC_24
 -- : BFD_RELOC_16
 -- : BFD_RELOC_14
 -- : BFD_RELOC_8
     Basic absolute relocations of N bits.

 -- : BFD_RELOC_64_PCREL
 -- : BFD_RELOC_32_PCREL
 -- : BFD_RELOC_24_PCREL
 -- : BFD_RELOC_16_PCREL
 -- : BFD_RELOC_12_PCREL
 -- : BFD_RELOC_8_PCREL
     PC-relative relocations.  Sometimes these are relative to the
     address of the relocation itself; sometimes they are relative to
     the start of the section containing the relocation.  It depends on
     the specific target.

 -- : BFD_RELOC_32_SECREL
     Section relative relocations.  Some targets need this for DWARF2.

 -- : BFD_RELOC_32_GOT_PCREL
 -- : BFD_RELOC_16_GOT_PCREL
 -- : BFD_RELOC_8_GOT_PCREL
 -- : BFD_RELOC_32_GOTOFF
 -- : BFD_RELOC_16_GOTOFF
 -- : BFD_RELOC_LO16_GOTOFF
 -- : BFD_RELOC_HI16_GOTOFF
 -- : BFD_RELOC_HI16_S_GOTOFF
 -- : BFD_RELOC_8_GOTOFF
 -- : BFD_RELOC_64_PLT_PCREL
 -- : BFD_RELOC_32_PLT_PCREL
 -- : BFD_RELOC_24_PLT_PCREL
 -- : BFD_RELOC_16_PLT_PCREL
 -- : BFD_RELOC_8_PLT_PCREL
 -- : BFD_RELOC_64_PLTOFF
 -- : BFD_RELOC_32_PLTOFF
 -- : BFD_RELOC_16_PLTOFF
 -- : BFD_RELOC_LO16_PLTOFF
 -- : BFD_RELOC_HI16_PLTOFF
 -- : BFD_RELOC_HI16_S_PLTOFF
 -- : BFD_RELOC_8_PLTOFF
     For ELF.

 -- : BFD_RELOC_SIZE32
 -- : BFD_RELOC_SIZE64
     Size relocations.

 -- : BFD_RELOC_68K_GLOB_DAT
 -- : BFD_RELOC_68K_JMP_SLOT
 -- : BFD_RELOC_68K_RELATIVE
 -- : BFD_RELOC_68K_TLS_GD32
 -- : BFD_RELOC_68K_TLS_GD16
 -- : BFD_RELOC_68K_TLS_GD8
 -- : BFD_RELOC_68K_TLS_LDM32
 -- : BFD_RELOC_68K_TLS_LDM16
 -- : BFD_RELOC_68K_TLS_LDM8
 -- : BFD_RELOC_68K_TLS_LDO32
 -- : BFD_RELOC_68K_TLS_LDO16
 -- : BFD_RELOC_68K_TLS_LDO8
 -- : BFD_RELOC_68K_TLS_IE32
 -- : BFD_RELOC_68K_TLS_IE16
 -- : BFD_RELOC_68K_TLS_IE8
 -- : BFD_RELOC_68K_TLS_LE32
 -- : BFD_RELOC_68K_TLS_LE16
 -- : BFD_RELOC_68K_TLS_LE8
     Relocations used by 68K ELF.

 -- : BFD_RELOC_32_BASEREL
 -- : BFD_RELOC_16_BASEREL
 -- : BFD_RELOC_LO16_BASEREL
 -- : BFD_RELOC_HI16_BASEREL
 -- : BFD_RELOC_HI16_S_BASEREL
 -- : BFD_RELOC_8_BASEREL
 -- : BFD_RELOC_RVA
     Linkage-table relative.

 -- : BFD_RELOC_8_FFnn
     Absolute 8-bit relocation, but used to form an address like 0xFFnn.

 -- : BFD_RELOC_32_PCREL_S2
 -- : BFD_RELOC_16_PCREL_S2
 -- : BFD_RELOC_23_PCREL_S2
     These PC-relative relocations are stored as word displacements -
     i.e., byte displacements shifted right two bits.  The 30-bit word
     displacement (<<32_PCREL_S2>> - 32 bits, shifted 2) is used on the
     SPARC.  (SPARC tools generally refer to this as <<WDISP30>>.)  The
     signed 16-bit displacement is used on the MIPS, and the 23-bit
     displacement is used on the Alpha.

 -- : BFD_RELOC_HI22
 -- : BFD_RELOC_LO10
     High 22 bits and low 10 bits of 32-bit value, placed into lower
     bits of the target word.  These are used on the SPARC.

 -- : BFD_RELOC_GPREL16
 -- : BFD_RELOC_GPREL32
     For systems that allocate a Global Pointer register, these are
     displacements off that register.  These relocation types are
     handled specially, because the value the register will have is
     decided relatively late.

 -- : BFD_RELOC_NONE
 -- : BFD_RELOC_SPARC_WDISP22
 -- : BFD_RELOC_SPARC22
 -- : BFD_RELOC_SPARC13
 -- : BFD_RELOC_SPARC_GOT10
 -- : BFD_RELOC_SPARC_GOT13
 -- : BFD_RELOC_SPARC_GOT22
 -- : BFD_RELOC_SPARC_PC10
 -- : BFD_RELOC_SPARC_PC22
 -- : BFD_RELOC_SPARC_WPLT30
 -- : BFD_RELOC_SPARC_COPY
 -- : BFD_RELOC_SPARC_GLOB_DAT
 -- : BFD_RELOC_SPARC_JMP_SLOT
 -- : BFD_RELOC_SPARC_RELATIVE
 -- : BFD_RELOC_SPARC_UA16
 -- : BFD_RELOC_SPARC_UA32
 -- : BFD_RELOC_SPARC_UA64
 -- : BFD_RELOC_SPARC_GOTDATA_HIX22
 -- : BFD_RELOC_SPARC_GOTDATA_LOX10
 -- : BFD_RELOC_SPARC_GOTDATA_OP_HIX22
 -- : BFD_RELOC_SPARC_GOTDATA_OP_LOX10
 -- : BFD_RELOC_SPARC_GOTDATA_OP
 -- : BFD_RELOC_SPARC_JMP_IREL
 -- : BFD_RELOC_SPARC_IRELATIVE
     SPARC ELF relocations.  There is probably some overlap with other
     relocation types already defined.

 -- : BFD_RELOC_SPARC_BASE13
 -- : BFD_RELOC_SPARC_BASE22
     I think these are specific to SPARC a.out (e.g., Sun 4).

 -- : BFD_RELOC_SPARC_64
 -- : BFD_RELOC_SPARC_10
 -- : BFD_RELOC_SPARC_11
 -- : BFD_RELOC_SPARC_OLO10
 -- : BFD_RELOC_SPARC_HH22
 -- : BFD_RELOC_SPARC_HM10
 -- : BFD_RELOC_SPARC_LM22
 -- : BFD_RELOC_SPARC_PC_HH22
 -- : BFD_RELOC_SPARC_PC_HM10
 -- : BFD_RELOC_SPARC_PC_LM22
 -- : BFD_RELOC_SPARC_WDISP16
 -- : BFD_RELOC_SPARC_WDISP19
 -- : BFD_RELOC_SPARC_7
 -- : BFD_RELOC_SPARC_6
 -- : BFD_RELOC_SPARC_5
 -- : BFD_RELOC_SPARC_DISP64
 -- : BFD_RELOC_SPARC_PLT32
 -- : BFD_RELOC_SPARC_PLT64
 -- : BFD_RELOC_SPARC_HIX22
 -- : BFD_RELOC_SPARC_LOX10
 -- : BFD_RELOC_SPARC_H44
 -- : BFD_RELOC_SPARC_M44
 -- : BFD_RELOC_SPARC_L44
 -- : BFD_RELOC_SPARC_REGISTER
 -- : BFD_RELOC_SPARC_H34
 -- : BFD_RELOC_SPARC_SIZE32
 -- : BFD_RELOC_SPARC_SIZE64
 -- : BFD_RELOC_SPARC_WDISP10
     SPARC64 relocations

 -- : BFD_RELOC_SPARC_REV32
     SPARC little endian relocation

 -- : BFD_RELOC_SPARC_TLS_GD_HI22
 -- : BFD_RELOC_SPARC_TLS_GD_LO10
 -- : BFD_RELOC_SPARC_TLS_GD_ADD
 -- : BFD_RELOC_SPARC_TLS_GD_CALL
 -- : BFD_RELOC_SPARC_TLS_LDM_HI22
 -- : BFD_RELOC_SPARC_TLS_LDM_LO10
 -- : BFD_RELOC_SPARC_TLS_LDM_ADD
 -- : BFD_RELOC_SPARC_TLS_LDM_CALL
 -- : BFD_RELOC_SPARC_TLS_LDO_HIX22
 -- : BFD_RELOC_SPARC_TLS_LDO_LOX10
 -- : BFD_RELOC_SPARC_TLS_LDO_ADD
 -- : BFD_RELOC_SPARC_TLS_IE_HI22
 -- : BFD_RELOC_SPARC_TLS_IE_LO10
 -- : BFD_RELOC_SPARC_TLS_IE_LD
 -- : BFD_RELOC_SPARC_TLS_IE_LDX
 -- : BFD_RELOC_SPARC_TLS_IE_ADD
 -- : BFD_RELOC_SPARC_TLS_LE_HIX22
 -- : BFD_RELOC_SPARC_TLS_LE_LOX10
 -- : BFD_RELOC_SPARC_TLS_DTPMOD32
 -- : BFD_RELOC_SPARC_TLS_DTPMOD64
 -- : BFD_RELOC_SPARC_TLS_DTPOFF32
 -- : BFD_RELOC_SPARC_TLS_DTPOFF64
 -- : BFD_RELOC_SPARC_TLS_TPOFF32
 -- : BFD_RELOC_SPARC_TLS_TPOFF64
     SPARC TLS relocations

 -- : BFD_RELOC_SPU_IMM7
 -- : BFD_RELOC_SPU_IMM8
 -- : BFD_RELOC_SPU_IMM10
 -- : BFD_RELOC_SPU_IMM10W
 -- : BFD_RELOC_SPU_IMM16
 -- : BFD_RELOC_SPU_IMM16W
 -- : BFD_RELOC_SPU_IMM18
 -- : BFD_RELOC_SPU_PCREL9a
 -- : BFD_RELOC_SPU_PCREL9b
 -- : BFD_RELOC_SPU_PCREL16
 -- : BFD_RELOC_SPU_LO16
 -- : BFD_RELOC_SPU_HI16
 -- : BFD_RELOC_SPU_PPU32
 -- : BFD_RELOC_SPU_PPU64
 -- : BFD_RELOC_SPU_ADD_PIC
     SPU Relocations.

 -- : BFD_RELOC_ALPHA_GPDISP_HI16
     Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
     "addend" in some special way.  For GPDISP_HI16 ("gpdisp")
     relocations, the symbol is ignored when writing; when reading, it
     will be the absolute section symbol.  The addend is the
     displacement in bytes of the "lda" instruction from the "ldah"
     instruction (which is at the address of this reloc).

 -- : BFD_RELOC_ALPHA_GPDISP_LO16
     For GPDISP_LO16 ("ignore") relocations, the symbol is handled as
     with GPDISP_HI16 relocs.  The addend is ignored when writing the
     relocations out, and is filled in with the file's GP value on
     reading, for convenience.

 -- : BFD_RELOC_ALPHA_GPDISP
     The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
     relocation except that there is no accompanying GPDISP_LO16
     relocation.

 -- : BFD_RELOC_ALPHA_LITERAL
 -- : BFD_RELOC_ALPHA_ELF_LITERAL
 -- : BFD_RELOC_ALPHA_LITUSE
     The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;
     the assembler turns it into a LDQ instruction to load the address
     of the symbol, and then fills in a register in the real
     instruction.

     The LITERAL reloc, at the LDQ instruction, refers to the .lita
     section symbol.  The addend is ignored when writing, but is filled
     in with the file's GP value on reading, for convenience, as with
     the GPDISP_LO16 reloc.

     The ELF_LITERAL reloc is somewhere between 16_GOTOFF and
     GPDISP_LO16.  It should refer to the symbol to be referenced, as
     with 16_GOTOFF, but it generates output not based on the position
     within the .got section, but relative to the GP value chosen for
     the file during the final link stage.

     The LITUSE reloc, on the instruction using the loaded address,
     gives information to the linker that it might be able to use to
     optimize away some literal section references.  The symbol is
     ignored (read as the absolute section symbol), and the "addend"
     indicates the type of instruction using the register: 1 - "memory"
     fmt insn 2 - byte-manipulation (byte offset reg) 3 - jsr (target
     of branch)

 -- : BFD_RELOC_ALPHA_HINT
     The HINT relocation indicates a value that should be filled into
     the "hint" field of a jmp/jsr/ret instruction, for possible branch-
     prediction logic which may be provided on some processors.

 -- : BFD_RELOC_ALPHA_LINKAGE
     The LINKAGE relocation outputs a linkage pair in the object file,
     which is filled by the linker.

 -- : BFD_RELOC_ALPHA_CODEADDR
     The CODEADDR relocation outputs a STO_CA in the object file, which
     is filled by the linker.

 -- : BFD_RELOC_ALPHA_GPREL_HI16
 -- : BFD_RELOC_ALPHA_GPREL_LO16
     The GPREL_HI/LO relocations together form a 32-bit offset from the
     GP register.

 -- : BFD_RELOC_ALPHA_BRSGP
     Like BFD_RELOC_23_PCREL_S2, except that the source and target must
     share a common GP, and the target address is adjusted for
     STO_ALPHA_STD_GPLOAD.

 -- : BFD_RELOC_ALPHA_NOP
     The NOP relocation outputs a NOP if the longword displacement
     between two procedure entry points is < 2^21.

 -- : BFD_RELOC_ALPHA_BSR
     The BSR relocation outputs a BSR if the longword displacement
     between two procedure entry points is < 2^21.

 -- : BFD_RELOC_ALPHA_LDA
     The LDA relocation outputs a LDA if the longword displacement
     between two procedure entry points is < 2^16.

 -- : BFD_RELOC_ALPHA_BOH
     The BOH relocation outputs a BSR if the longword displacement
     between two procedure entry points is < 2^21, or else a hint.

 -- : BFD_RELOC_ALPHA_TLSGD
 -- : BFD_RELOC_ALPHA_TLSLDM
 -- : BFD_RELOC_ALPHA_DTPMOD64
 -- : BFD_RELOC_ALPHA_GOTDTPREL16
 -- : BFD_RELOC_ALPHA_DTPREL64
 -- : BFD_RELOC_ALPHA_DTPREL_HI16
 -- : BFD_RELOC_ALPHA_DTPREL_LO16
 -- : BFD_RELOC_ALPHA_DTPREL16
 -- : BFD_RELOC_ALPHA_GOTTPREL16
 -- : BFD_RELOC_ALPHA_TPREL64
 -- : BFD_RELOC_ALPHA_TPREL_HI16
 -- : BFD_RELOC_ALPHA_TPREL_LO16
 -- : BFD_RELOC_ALPHA_TPREL16
     Alpha thread-local storage relocations.

 -- : BFD_RELOC_MIPS_JMP
 -- : BFD_RELOC_MICROMIPS_JMP
     The MIPS jump instruction.

 -- : BFD_RELOC_MIPS16_JMP
     The MIPS16 jump instruction.

 -- : BFD_RELOC_MIPS16_GPREL
     MIPS16 GP relative reloc.

 -- : BFD_RELOC_HI16
     High 16 bits of 32-bit value; simple reloc.

 -- : BFD_RELOC_HI16_S
     High 16 bits of 32-bit value but the low 16 bits will be sign
     extended and added to form the final result.  If the low 16 bits
     form a negative number, we need to add one to the high value to
     compensate for the borrow when the low bits are added.

 -- : BFD_RELOC_LO16
     Low 16 bits.

 -- : BFD_RELOC_HI16_PCREL
     High 16 bits of 32-bit pc-relative value

 -- : BFD_RELOC_HI16_S_PCREL
     High 16 bits of 32-bit pc-relative value, adjusted

 -- : BFD_RELOC_LO16_PCREL
     Low 16 bits of pc-relative value

 -- : BFD_RELOC_MIPS16_GOT16
 -- : BFD_RELOC_MIPS16_CALL16
     Equivalent of BFD_RELOC_MIPS_*, but with the MIPS16 layout of
     16-bit immediate fields

 -- : BFD_RELOC_MIPS16_HI16
     MIPS16 high 16 bits of 32-bit value.

 -- : BFD_RELOC_MIPS16_HI16_S
     MIPS16 high 16 bits of 32-bit value but the low 16 bits will be
     sign extended and added to form the final result.  If the low 16
     bits form a negative number, we need to add one to the high value
     to compensate for the borrow when the low bits are added.

 -- : BFD_RELOC_MIPS16_LO16
     MIPS16 low 16 bits.

 -- : BFD_RELOC_MIPS16_TLS_GD
 -- : BFD_RELOC_MIPS16_TLS_LDM
 -- : BFD_RELOC_MIPS16_TLS_DTPREL_HI16
 -- : BFD_RELOC_MIPS16_TLS_DTPREL_LO16
 -- : BFD_RELOC_MIPS16_TLS_GOTTPREL
 -- : BFD_RELOC_MIPS16_TLS_TPREL_HI16
 -- : BFD_RELOC_MIPS16_TLS_TPREL_LO16
     MIPS16 TLS relocations

 -- : BFD_RELOC_MIPS_LITERAL
 -- : BFD_RELOC_MICROMIPS_LITERAL
     Relocation against a MIPS literal section.

 -- : BFD_RELOC_MICROMIPS_7_PCREL_S1
 -- : BFD_RELOC_MICROMIPS_10_PCREL_S1
 -- : BFD_RELOC_MICROMIPS_16_PCREL_S1
     microMIPS PC-relative relocations.

 -- : BFD_RELOC_MIPS16_16_PCREL_S1
     MIPS16 PC-relative relocation.

 -- : BFD_RELOC_MIPS_21_PCREL_S2
 -- : BFD_RELOC_MIPS_26_PCREL_S2
 -- : BFD_RELOC_MIPS_18_PCREL_S3
 -- : BFD_RELOC_MIPS_19_PCREL_S2
     MIPS PC-relative relocations.

 -- : BFD_RELOC_MICROMIPS_GPREL16
 -- : BFD_RELOC_MICROMIPS_HI16
 -- : BFD_RELOC_MICROMIPS_HI16_S
 -- : BFD_RELOC_MICROMIPS_LO16
     microMIPS versions of generic BFD relocs.

 -- : BFD_RELOC_MIPS_GOT16
 -- : BFD_RELOC_MICROMIPS_GOT16
 -- : BFD_RELOC_MIPS_CALL16
 -- : BFD_RELOC_MICROMIPS_CALL16
 -- : BFD_RELOC_MIPS_GOT_HI16
 -- : BFD_RELOC_MICROMIPS_GOT_HI16
 -- : BFD_RELOC_MIPS_GOT_LO16
 -- : BFD_RELOC_MICROMIPS_GOT_LO16
 -- : BFD_RELOC_MIPS_CALL_HI16
 -- : BFD_RELOC_MICROMIPS_CALL_HI16
 -- : BFD_RELOC_MIPS_CALL_LO16
 -- : BFD_RELOC_MICROMIPS_CALL_LO16
 -- : BFD_RELOC_MIPS_SUB
 -- : BFD_RELOC_MICROMIPS_SUB
 -- : BFD_RELOC_MIPS_GOT_PAGE
 -- : BFD_RELOC_MICROMIPS_GOT_PAGE
 -- : BFD_RELOC_MIPS_GOT_OFST
 -- : BFD_RELOC_MICROMIPS_GOT_OFST
 -- : BFD_RELOC_MIPS_GOT_DISP
 -- : BFD_RELOC_MICROMIPS_GOT_DISP
 -- : BFD_RELOC_MIPS_SHIFT5
 -- : BFD_RELOC_MIPS_SHIFT6
 -- : BFD_RELOC_MIPS_INSERT_A
 -- : BFD_RELOC_MIPS_INSERT_B
 -- : BFD_RELOC_MIPS_DELETE
 -- : BFD_RELOC_MIPS_HIGHEST
 -- : BFD_RELOC_MICROMIPS_HIGHEST
 -- : BFD_RELOC_MIPS_HIGHER
 -- : BFD_RELOC_MICROMIPS_HIGHER
 -- : BFD_RELOC_MIPS_SCN_DISP
 -- : BFD_RELOC_MICROMIPS_SCN_DISP
 -- : BFD_RELOC_MIPS_REL16
 -- : BFD_RELOC_MIPS_RELGOT
 -- : BFD_RELOC_MIPS_JALR
 -- : BFD_RELOC_MICROMIPS_JALR
 -- : BFD_RELOC_MIPS_TLS_DTPMOD32
 -- : BFD_RELOC_MIPS_TLS_DTPREL32
 -- : BFD_RELOC_MIPS_TLS_DTPMOD64
 -- : BFD_RELOC_MIPS_TLS_DTPREL64
 -- : BFD_RELOC_MIPS_TLS_GD
 -- : BFD_RELOC_MICROMIPS_TLS_GD
 -- : BFD_RELOC_MIPS_TLS_LDM
 -- : BFD_RELOC_MICROMIPS_TLS_LDM
 -- : BFD_RELOC_MIPS_TLS_DTPREL_HI16
 -- : BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16
 -- : BFD_RELOC_MIPS_TLS_DTPREL_LO16
 -- : BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16
 -- : BFD_RELOC_MIPS_TLS_GOTTPREL
 -- : BFD_RELOC_MICROMIPS_TLS_GOTTPREL
 -- : BFD_RELOC_MIPS_TLS_TPREL32
 -- : BFD_RELOC_MIPS_TLS_TPREL64
 -- : BFD_RELOC_MIPS_TLS_TPREL_HI16
 -- : BFD_RELOC_MICROMIPS_TLS_TPREL_HI16
 -- : BFD_RELOC_MIPS_TLS_TPREL_LO16
 -- : BFD_RELOC_MICROMIPS_TLS_TPREL_LO16
 -- : BFD_RELOC_MIPS_EH
     MIPS ELF relocations.

 -- : BFD_RELOC_MIPS_COPY
 -- : BFD_RELOC_MIPS_JUMP_SLOT
     MIPS ELF relocations (VxWorks and PLT extensions).

 -- : BFD_RELOC_MOXIE_10_PCREL
     Moxie ELF relocations.

 -- : BFD_RELOC_FT32_10
 -- : BFD_RELOC_FT32_20
 -- : BFD_RELOC_FT32_17
 -- : BFD_RELOC_FT32_18
 -- : BFD_RELOC_FT32_RELAX
 -- : BFD_RELOC_FT32_SC0
 -- : BFD_RELOC_FT32_SC1
 -- : BFD_RELOC_FT32_15
 -- : BFD_RELOC_FT32_DIFF32
     FT32 ELF relocations.

 -- : BFD_RELOC_FRV_LABEL16
 -- : BFD_RELOC_FRV_LABEL24
 -- : BFD_RELOC_FRV_LO16
 -- : BFD_RELOC_FRV_HI16
 -- : BFD_RELOC_FRV_GPREL12
 -- : BFD_RELOC_FRV_GPRELU12
 -- : BFD_RELOC_FRV_GPREL32
 -- : BFD_RELOC_FRV_GPRELHI
 -- : BFD_RELOC_FRV_GPRELLO
 -- : BFD_RELOC_FRV_GOT12
 -- : BFD_RELOC_FRV_GOTHI
 -- : BFD_RELOC_FRV_GOTLO
 -- : BFD_RELOC_FRV_FUNCDESC
 -- : BFD_RELOC_FRV_FUNCDESC_GOT12
 -- : BFD_RELOC_FRV_FUNCDESC_GOTHI
 -- : BFD_RELOC_FRV_FUNCDESC_GOTLO
 -- : BFD_RELOC_FRV_FUNCDESC_VALUE
 -- : BFD_RELOC_FRV_FUNCDESC_GOTOFF12
 -- : BFD_RELOC_FRV_FUNCDESC_GOTOFFHI
 -- : BFD_RELOC_FRV_FUNCDESC_GOTOFFLO
 -- : BFD_RELOC_FRV_GOTOFF12
 -- : BFD_RELOC_FRV_GOTOFFHI
 -- : BFD_RELOC_FRV_GOTOFFLO
 -- : BFD_RELOC_FRV_GETTLSOFF
 -- : BFD_RELOC_FRV_TLSDESC_VALUE
 -- : BFD_RELOC_FRV_GOTTLSDESC12
 -- : BFD_RELOC_FRV_GOTTLSDESCHI
 -- : BFD_RELOC_FRV_GOTTLSDESCLO
 -- : BFD_RELOC_FRV_TLSMOFF12
 -- : BFD_RELOC_FRV_TLSMOFFHI
 -- : BFD_RELOC_FRV_TLSMOFFLO
 -- : BFD_RELOC_FRV_GOTTLSOFF12
 -- : BFD_RELOC_FRV_GOTTLSOFFHI
 -- : BFD_RELOC_FRV_GOTTLSOFFLO
 -- : BFD_RELOC_FRV_TLSOFF
 -- : BFD_RELOC_FRV_TLSDESC_RELAX
 -- : BFD_RELOC_FRV_GETTLSOFF_RELAX
 -- : BFD_RELOC_FRV_TLSOFF_RELAX
 -- : BFD_RELOC_FRV_TLSMOFF
     Fujitsu Frv Relocations.

 -- : BFD_RELOC_MN10300_GOTOFF24
     This is a 24bit GOT-relative reloc for the mn10300.

 -- : BFD_RELOC_MN10300_GOT32
     This is a 32bit GOT-relative reloc for the mn10300, offset by two
     bytes in the instruction.

 -- : BFD_RELOC_MN10300_GOT24
     This is a 24bit GOT-relative reloc for the mn10300, offset by two
     bytes in the instruction.

 -- : BFD_RELOC_MN10300_GOT16
     This is a 16bit GOT-relative reloc for the mn10300, offset by two
     bytes in the instruction.

 -- : BFD_RELOC_MN10300_COPY
     Copy symbol at runtime.

 -- : BFD_RELOC_MN10300_GLOB_DAT
     Create GOT entry.

 -- : BFD_RELOC_MN10300_JMP_SLOT
     Create PLT entry.

 -- : BFD_RELOC_MN10300_RELATIVE
     Adjust by program base.

 -- : BFD_RELOC_MN10300_SYM_DIFF
     Together with another reloc targeted at the same location, allows
     for a value that is the difference of two symbols in the same
     section.

 -- : BFD_RELOC_MN10300_ALIGN
     The addend of this reloc is an alignment power that must be
     honoured at the offset's location, regardless of linker relaxation.

 -- : BFD_RELOC_MN10300_TLS_GD
 -- : BFD_RELOC_MN10300_TLS_LD
 -- : BFD_RELOC_MN10300_TLS_LDO
 -- : BFD_RELOC_MN10300_TLS_GOTIE
 -- : BFD_RELOC_MN10300_TLS_IE
 -- : BFD_RELOC_MN10300_TLS_LE
 -- : BFD_RELOC_MN10300_TLS_DTPMOD
 -- : BFD_RELOC_MN10300_TLS_DTPOFF
 -- : BFD_RELOC_MN10300_TLS_TPOFF
     Various TLS-related relocations.

 -- : BFD_RELOC_MN10300_32_PCREL
     This is a 32bit pcrel reloc for the mn10300, offset by two bytes
     in the instruction.

 -- : BFD_RELOC_MN10300_16_PCREL
     This is a 16bit pcrel reloc for the mn10300, offset by two bytes
     in the instruction.

 -- : BFD_RELOC_386_GOT32
 -- : BFD_RELOC_386_PLT32
 -- : BFD_RELOC_386_COPY
 -- : BFD_RELOC_386_GLOB_DAT
 -- : BFD_RELOC_386_JUMP_SLOT
 -- : BFD_RELOC_386_RELATIVE
 -- : BFD_RELOC_386_GOTOFF
 -- : BFD_RELOC_386_GOTPC
 -- : BFD_RELOC_386_TLS_TPOFF
 -- : BFD_RELOC_386_TLS_IE
 -- : BFD_RELOC_386_TLS_GOTIE
 -- : BFD_RELOC_386_TLS_LE
 -- : BFD_RELOC_386_TLS_GD
 -- : BFD_RELOC_386_TLS_LDM
 -- : BFD_RELOC_386_TLS_LDO_32
 -- : BFD_RELOC_386_TLS_IE_32
 -- : BFD_RELOC_386_TLS_LE_32
 -- : BFD_RELOC_386_TLS_DTPMOD32
 -- : BFD_RELOC_386_TLS_DTPOFF32
 -- : BFD_RELOC_386_TLS_TPOFF32
 -- : BFD_RELOC_386_TLS_GOTDESC
 -- : BFD_RELOC_386_TLS_DESC_CALL
 -- : BFD_RELOC_386_TLS_DESC
 -- : BFD_RELOC_386_IRELATIVE
 -- : BFD_RELOC_386_GOT32X
     i386/elf relocations

 -- : BFD_RELOC_X86_64_GOT32
 -- : BFD_RELOC_X86_64_PLT32
 -- : BFD_RELOC_X86_64_COPY
 -- : BFD_RELOC_X86_64_GLOB_DAT
 -- : BFD_RELOC_X86_64_JUMP_SLOT
 -- : BFD_RELOC_X86_64_RELATIVE
 -- : BFD_RELOC_X86_64_GOTPCREL
 -- : BFD_RELOC_X86_64_32S
 -- : BFD_RELOC_X86_64_DTPMOD64
 -- : BFD_RELOC_X86_64_DTPOFF64
 -- : BFD_RELOC_X86_64_TPOFF64
 -- : BFD_RELOC_X86_64_TLSGD
 -- : BFD_RELOC_X86_64_TLSLD
 -- : BFD_RELOC_X86_64_DTPOFF32
 -- : BFD_RELOC_X86_64_GOTTPOFF
 -- : BFD_RELOC_X86_64_TPOFF32
 -- : BFD_RELOC_X86_64_GOTOFF64
 -- : BFD_RELOC_X86_64_GOTPC32
 -- : BFD_RELOC_X86_64_GOT64
 -- : BFD_RELOC_X86_64_GOTPCREL64
 -- : BFD_RELOC_X86_64_GOTPC64
 -- : BFD_RELOC_X86_64_GOTPLT64
 -- : BFD_RELOC_X86_64_PLTOFF64
 -- : BFD_RELOC_X86_64_GOTPC32_TLSDESC
 -- : BFD_RELOC_X86_64_TLSDESC_CALL
 -- : BFD_RELOC_X86_64_TLSDESC
 -- : BFD_RELOC_X86_64_IRELATIVE
 -- : BFD_RELOC_X86_64_PC32_BND
 -- : BFD_RELOC_X86_64_PLT32_BND
 -- : BFD_RELOC_X86_64_GOTPCRELX
 -- : BFD_RELOC_X86_64_REX_GOTPCRELX
     x86-64/elf relocations

 -- : BFD_RELOC_NS32K_IMM_8
 -- : BFD_RELOC_NS32K_IMM_16
 -- : BFD_RELOC_NS32K_IMM_32
 -- : BFD_RELOC_NS32K_IMM_8_PCREL
 -- : BFD_RELOC_NS32K_IMM_16_PCREL
 -- : BFD_RELOC_NS32K_IMM_32_PCREL
 -- : BFD_RELOC_NS32K_DISP_8
 -- : BFD_RELOC_NS32K_DISP_16
 -- : BFD_RELOC_NS32K_DISP_32
 -- : BFD_RELOC_NS32K_DISP_8_PCREL
 -- : BFD_RELOC_NS32K_DISP_16_PCREL
 -- : BFD_RELOC_NS32K_DISP_32_PCREL
     ns32k relocations

 -- : BFD_RELOC_PDP11_DISP_8_PCREL
 -- : BFD_RELOC_PDP11_DISP_6_PCREL
     PDP11 relocations

 -- : BFD_RELOC_PJ_CODE_HI16
 -- : BFD_RELOC_PJ_CODE_LO16
 -- : BFD_RELOC_PJ_CODE_DIR16
 -- : BFD_RELOC_PJ_CODE_DIR32
 -- : BFD_RELOC_PJ_CODE_REL16
 -- : BFD_RELOC_PJ_CODE_REL32
     Picojava relocs.  Not all of these appear in object files.

 -- : BFD_RELOC_PPC_B26
 -- : BFD_RELOC_PPC_BA26
 -- : BFD_RELOC_PPC_TOC16
 -- : BFD_RELOC_PPC_B16
 -- : BFD_RELOC_PPC_B16_BRTAKEN
 -- : BFD_RELOC_PPC_B16_BRNTAKEN
 -- : BFD_RELOC_PPC_BA16
 -- : BFD_RELOC_PPC_BA16_BRTAKEN
 -- : BFD_RELOC_PPC_BA16_BRNTAKEN
 -- : BFD_RELOC_PPC_COPY
 -- : BFD_RELOC_PPC_GLOB_DAT
 -- : BFD_RELOC_PPC_JMP_SLOT
 -- : BFD_RELOC_PPC_RELATIVE
 -- : BFD_RELOC_PPC_LOCAL24PC
 -- : BFD_RELOC_PPC_EMB_NADDR32
 -- : BFD_RELOC_PPC_EMB_NADDR16
 -- : BFD_RELOC_PPC_EMB_NADDR16_LO
 -- : BFD_RELOC_PPC_EMB_NADDR16_HI
 -- : BFD_RELOC_PPC_EMB_NADDR16_HA
 -- : BFD_RELOC_PPC_EMB_SDAI16
 -- : BFD_RELOC_PPC_EMB_SDA2I16
 -- : BFD_RELOC_PPC_EMB_SDA2REL
 -- : BFD_RELOC_PPC_EMB_SDA21
 -- : BFD_RELOC_PPC_EMB_MRKREF
 -- : BFD_RELOC_PPC_EMB_RELSEC16
 -- : BFD_RELOC_PPC_EMB_RELST_LO
 -- : BFD_RELOC_PPC_EMB_RELST_HI
 -- : BFD_RELOC_PPC_EMB_RELST_HA
 -- : BFD_RELOC_PPC_EMB_BIT_FLD
 -- : BFD_RELOC_PPC_EMB_RELSDA
 -- : BFD_RELOC_PPC_VLE_REL8
 -- : BFD_RELOC_PPC_VLE_REL15
 -- : BFD_RELOC_PPC_VLE_REL24
 -- : BFD_RELOC_PPC_VLE_LO16A
 -- : BFD_RELOC_PPC_VLE_LO16D
 -- : BFD_RELOC_PPC_VLE_HI16A
 -- : BFD_RELOC_PPC_VLE_HI16D
 -- : BFD_RELOC_PPC_VLE_HA16A
 -- : BFD_RELOC_PPC_VLE_HA16D
 -- : BFD_RELOC_PPC_VLE_SDA21
 -- : BFD_RELOC_PPC_VLE_SDA21_LO
 -- : BFD_RELOC_PPC_VLE_SDAREL_LO16A
 -- : BFD_RELOC_PPC_VLE_SDAREL_LO16D
 -- : BFD_RELOC_PPC_VLE_SDAREL_HI16A
 -- : BFD_RELOC_PPC_VLE_SDAREL_HI16D
 -- : BFD_RELOC_PPC_VLE_SDAREL_HA16A
 -- : BFD_RELOC_PPC_VLE_SDAREL_HA16D
 -- : BFD_RELOC_PPC_16DX_HA
 -- : BFD_RELOC_PPC_REL16DX_HA
 -- : BFD_RELOC_PPC64_HIGHER
 -- : BFD_RELOC_PPC64_HIGHER_S
 -- : BFD_RELOC_PPC64_HIGHEST
 -- : BFD_RELOC_PPC64_HIGHEST_S
 -- : BFD_RELOC_PPC64_TOC16_LO
 -- : BFD_RELOC_PPC64_TOC16_HI
 -- : BFD_RELOC_PPC64_TOC16_HA
 -- : BFD_RELOC_PPC64_TOC
 -- : BFD_RELOC_PPC64_PLTGOT16
 -- : BFD_RELOC_PPC64_PLTGOT16_LO
 -- : BFD_RELOC_PPC64_PLTGOT16_HI
 -- : BFD_RELOC_PPC64_PLTGOT16_HA
 -- : BFD_RELOC_PPC64_ADDR16_DS
 -- : BFD_RELOC_PPC64_ADDR16_LO_DS
 -- : BFD_RELOC_PPC64_GOT16_DS
 -- : BFD_RELOC_PPC64_GOT16_LO_DS
 -- : BFD_RELOC_PPC64_PLT16_LO_DS
 -- : BFD_RELOC_PPC64_SECTOFF_DS
 -- : BFD_RELOC_PPC64_SECTOFF_LO_DS
 -- : BFD_RELOC_PPC64_TOC16_DS
 -- : BFD_RELOC_PPC64_TOC16_LO_DS
 -- : BFD_RELOC_PPC64_PLTGOT16_DS
 -- : BFD_RELOC_PPC64_PLTGOT16_LO_DS
 -- : BFD_RELOC_PPC64_ADDR16_HIGH
 -- : BFD_RELOC_PPC64_ADDR16_HIGHA
 -- : BFD_RELOC_PPC64_REL16_HIGH
 -- : BFD_RELOC_PPC64_REL16_HIGHA
 -- : BFD_RELOC_PPC64_REL16_HIGHER
 -- : BFD_RELOC_PPC64_REL16_HIGHERA
 -- : BFD_RELOC_PPC64_REL16_HIGHEST
 -- : BFD_RELOC_PPC64_REL16_HIGHESTA
 -- : BFD_RELOC_PPC64_ADDR64_LOCAL
 -- : BFD_RELOC_PPC64_ENTRY
 -- : BFD_RELOC_PPC64_REL24_NOTOC
     Power(rs6000) and PowerPC relocations.

 -- : BFD_RELOC_PPC_TLS
 -- : BFD_RELOC_PPC_TLSGD
 -- : BFD_RELOC_PPC_TLSLD
 -- : BFD_RELOC_PPC_DTPMOD
 -- : BFD_RELOC_PPC_TPREL16
 -- : BFD_RELOC_PPC_TPREL16_LO
 -- : BFD_RELOC_PPC_TPREL16_HI
 -- : BFD_RELOC_PPC_TPREL16_HA
 -- : BFD_RELOC_PPC_TPREL
 -- : BFD_RELOC_PPC_DTPREL16
 -- : BFD_RELOC_PPC_DTPREL16_LO
 -- : BFD_RELOC_PPC_DTPREL16_HI
 -- : BFD_RELOC_PPC_DTPREL16_HA
 -- : BFD_RELOC_PPC_DTPREL
 -- : BFD_RELOC_PPC_GOT_TLSGD16
 -- : BFD_RELOC_PPC_GOT_TLSGD16_LO
 -- : BFD_RELOC_PPC_GOT_TLSGD16_HI
 -- : BFD_RELOC_PPC_GOT_TLSGD16_HA
 -- : BFD_RELOC_PPC_GOT_TLSLD16
 -- : BFD_RELOC_PPC_GOT_TLSLD16_LO
 -- : BFD_RELOC_PPC_GOT_TLSLD16_HI
 -- : BFD_RELOC_PPC_GOT_TLSLD16_HA
 -- : BFD_RELOC_PPC_GOT_TPREL16
 -- : BFD_RELOC_PPC_GOT_TPREL16_LO
 -- : BFD_RELOC_PPC_GOT_TPREL16_HI
 -- : BFD_RELOC_PPC_GOT_TPREL16_HA
 -- : BFD_RELOC_PPC_GOT_DTPREL16
 -- : BFD_RELOC_PPC_GOT_DTPREL16_LO
 -- : BFD_RELOC_PPC_GOT_DTPREL16_HI
 -- : BFD_RELOC_PPC_GOT_DTPREL16_HA
 -- : BFD_RELOC_PPC64_TPREL16_DS
 -- : BFD_RELOC_PPC64_TPREL16_LO_DS
 -- : BFD_RELOC_PPC64_TPREL16_HIGHER
 -- : BFD_RELOC_PPC64_TPREL16_HIGHERA
 -- : BFD_RELOC_PPC64_TPREL16_HIGHEST
 -- : BFD_RELOC_PPC64_TPREL16_HIGHESTA
 -- : BFD_RELOC_PPC64_DTPREL16_DS
 -- : BFD_RELOC_PPC64_DTPREL16_LO_DS
 -- : BFD_RELOC_PPC64_DTPREL16_HIGHER
 -- : BFD_RELOC_PPC64_DTPREL16_HIGHERA
 -- : BFD_RELOC_PPC64_DTPREL16_HIGHEST
 -- : BFD_RELOC_PPC64_DTPREL16_HIGHESTA
 -- : BFD_RELOC_PPC64_TPREL16_HIGH
 -- : BFD_RELOC_PPC64_TPREL16_HIGHA
 -- : BFD_RELOC_PPC64_DTPREL16_HIGH
 -- : BFD_RELOC_PPC64_DTPREL16_HIGHA
     PowerPC and PowerPC64 thread-local storage relocations.

 -- : BFD_RELOC_I370_D12
     IBM 370/390 relocations

 -- : BFD_RELOC_CTOR
     The type of reloc used to build a constructor table - at the moment
     probably a 32 bit wide absolute relocation, but the target can
     choose.  It generally does map to one of the other relocation
     types.

 -- : BFD_RELOC_ARM_PCREL_BRANCH
     ARM 26 bit pc-relative branch.  The lowest two bits must be zero
     and are not stored in the instruction.

 -- : BFD_RELOC_ARM_PCREL_BLX
     ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
     not stored in the instruction.  The 2nd lowest bit comes from a 1
     bit field in the instruction.

 -- : BFD_RELOC_THUMB_PCREL_BLX
     Thumb 22 bit pc-relative branch.  The lowest bit must be zero and
     is not stored in the instruction.  The 2nd lowest bit comes from a
     1 bit field in the instruction.

 -- : BFD_RELOC_ARM_PCREL_CALL
     ARM 26-bit pc-relative branch for an unconditional BL or BLX
     instruction.

 -- : BFD_RELOC_ARM_PCREL_JUMP
     ARM 26-bit pc-relative branch for B or conditional BL instruction.

 -- : BFD_RELOC_THUMB_PCREL_BRANCH7
 -- : BFD_RELOC_THUMB_PCREL_BRANCH9
 -- : BFD_RELOC_THUMB_PCREL_BRANCH12
 -- : BFD_RELOC_THUMB_PCREL_BRANCH20
 -- : BFD_RELOC_THUMB_PCREL_BRANCH23
 -- : BFD_RELOC_THUMB_PCREL_BRANCH25
     Thumb 7-, 9-, 12-, 20-, 23-, and 25-bit pc-relative branches.  The
     lowest bit must be zero and is not stored in the instruction.
     Note that the corresponding ELF R_ARM_THM_JUMPnn constant has an
     "nn" one smaller in all cases.  Note further that BRANCH23
     corresponds to R_ARM_THM_CALL.

 -- : BFD_RELOC_ARM_OFFSET_IMM
     12-bit immediate offset, used in ARM-format ldr and str
     instructions.

 -- : BFD_RELOC_ARM_THUMB_OFFSET
     5-bit immediate offset, used in Thumb-format ldr and str
     instructions.

 -- : BFD_RELOC_ARM_TARGET1
     Pc-relative or absolute relocation depending on target.  Used for
     entries in .init_array sections.

 -- : BFD_RELOC_ARM_ROSEGREL32
     Read-only segment base relative address.

 -- : BFD_RELOC_ARM_SBREL32
     Data segment base relative address.

 -- : BFD_RELOC_ARM_TARGET2
     This reloc is used for references to RTTI data from exception
     handling tables.  The actual definition depends on the target.  It
     may be a pc-relative or some form of GOT-indirect relocation.

 -- : BFD_RELOC_ARM_PREL31
     31-bit PC relative address.

 -- : BFD_RELOC_ARM_MOVW
 -- : BFD_RELOC_ARM_MOVT
 -- : BFD_RELOC_ARM_MOVW_PCREL
 -- : BFD_RELOC_ARM_MOVT_PCREL
 -- : BFD_RELOC_ARM_THUMB_MOVW
 -- : BFD_RELOC_ARM_THUMB_MOVT
 -- : BFD_RELOC_ARM_THUMB_MOVW_PCREL
 -- : BFD_RELOC_ARM_THUMB_MOVT_PCREL
     Low and High halfword relocations for MOVW and MOVT instructions.

 -- : BFD_RELOC_ARM_GOTFUNCDESC
 -- : BFD_RELOC_ARM_GOTOFFFUNCDESC
 -- : BFD_RELOC_ARM_FUNCDESC
 -- : BFD_RELOC_ARM_FUNCDESC_VALUE
 -- : BFD_RELOC_ARM_TLS_GD32_FDPIC
 -- : BFD_RELOC_ARM_TLS_LDM32_FDPIC
 -- : BFD_RELOC_ARM_TLS_IE32_FDPIC
     ARM FDPIC specific relocations.

 -- : BFD_RELOC_ARM_JUMP_SLOT
 -- : BFD_RELOC_ARM_GLOB_DAT
 -- : BFD_RELOC_ARM_GOT32
 -- : BFD_RELOC_ARM_PLT32
 -- : BFD_RELOC_ARM_RELATIVE
 -- : BFD_RELOC_ARM_GOTOFF
 -- : BFD_RELOC_ARM_GOTPC
 -- : BFD_RELOC_ARM_GOT_PREL
     Relocations for setting up GOTs and PLTs for shared libraries.

 -- : BFD_RELOC_ARM_TLS_GD32
 -- : BFD_RELOC_ARM_TLS_LDO32
 -- : BFD_RELOC_ARM_TLS_LDM32
 -- : BFD_RELOC_ARM_TLS_DTPOFF32
 -- : BFD_RELOC_ARM_TLS_DTPMOD32
 -- : BFD_RELOC_ARM_TLS_TPOFF32
 -- : BFD_RELOC_ARM_TLS_IE32
 -- : BFD_RELOC_ARM_TLS_LE32
 -- : BFD_RELOC_ARM_TLS_GOTDESC
 -- : BFD_RELOC_ARM_TLS_CALL
 -- : BFD_RELOC_ARM_THM_TLS_CALL
 -- : BFD_RELOC_ARM_TLS_DESCSEQ
 -- : BFD_RELOC_ARM_THM_TLS_DESCSEQ
 -- : BFD_RELOC_ARM_TLS_DESC
     ARM thread-local storage relocations.

 -- : BFD_RELOC_ARM_ALU_PC_G0_NC
 -- : BFD_RELOC_ARM_ALU_PC_G0
 -- : BFD_RELOC_ARM_ALU_PC_G1_NC
 -- : BFD_RELOC_ARM_ALU_PC_G1
 -- : BFD_RELOC_ARM_ALU_PC_G2
 -- : BFD_RELOC_ARM_LDR_PC_G0
 -- : BFD_RELOC_ARM_LDR_PC_G1
 -- : BFD_RELOC_ARM_LDR_PC_G2
 -- : BFD_RELOC_ARM_LDRS_PC_G0
 -- : BFD_RELOC_ARM_LDRS_PC_G1
 -- : BFD_RELOC_ARM_LDRS_PC_G2
 -- : BFD_RELOC_ARM_LDC_PC_G0
 -- : BFD_RELOC_ARM_LDC_PC_G1
 -- : BFD_RELOC_ARM_LDC_PC_G2
 -- : BFD_RELOC_ARM_ALU_SB_G0_NC
 -- : BFD_RELOC_ARM_ALU_SB_G0
 -- : BFD_RELOC_ARM_ALU_SB_G1_NC
 -- : BFD_RELOC_ARM_ALU_SB_G1
 -- : BFD_RELOC_ARM_ALU_SB_G2
 -- : BFD_RELOC_ARM_LDR_SB_G0
 -- : BFD_RELOC_ARM_LDR_SB_G1
 -- : BFD_RELOC_ARM_LDR_SB_G2
 -- : BFD_RELOC_ARM_LDRS_SB_G0
 -- : BFD_RELOC_ARM_LDRS_SB_G1
 -- : BFD_RELOC_ARM_LDRS_SB_G2
 -- : BFD_RELOC_ARM_LDC_SB_G0
 -- : BFD_RELOC_ARM_LDC_SB_G1
 -- : BFD_RELOC_ARM_LDC_SB_G2
     ARM group relocations.

 -- : BFD_RELOC_ARM_V4BX
     Annotation of BX instructions.

 -- : BFD_RELOC_ARM_IRELATIVE
     ARM support for STT_GNU_IFUNC.

 -- : BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC
 -- : BFD_RELOC_ARM_THUMB_ALU_ABS_G1_NC
 -- : BFD_RELOC_ARM_THUMB_ALU_ABS_G2_NC
 -- : BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC
     Thumb1 relocations to support execute-only code.

 -- : BFD_RELOC_ARM_IMMEDIATE
 -- : BFD_RELOC_ARM_ADRL_IMMEDIATE
 -- : BFD_RELOC_ARM_T32_IMMEDIATE
 -- : BFD_RELOC_ARM_T32_ADD_IMM
 -- : BFD_RELOC_ARM_T32_IMM12
 -- : BFD_RELOC_ARM_T32_ADD_PC12
 -- : BFD_RELOC_ARM_SHIFT_IMM
 -- : BFD_RELOC_ARM_SMC
 -- : BFD_RELOC_ARM_HVC
 -- : BFD_RELOC_ARM_SWI
 -- : BFD_RELOC_ARM_MULTI
 -- : BFD_RELOC_ARM_CP_OFF_IMM
 -- : BFD_RELOC_ARM_CP_OFF_IMM_S2
 -- : BFD_RELOC_ARM_T32_CP_OFF_IMM
 -- : BFD_RELOC_ARM_T32_CP_OFF_IMM_S2
 -- : BFD_RELOC_ARM_ADR_IMM
 -- : BFD_RELOC_ARM_LDR_IMM
 -- : BFD_RELOC_ARM_LITERAL
 -- : BFD_RELOC_ARM_IN_POOL
 -- : BFD_RELOC_ARM_OFFSET_IMM8
 -- : BFD_RELOC_ARM_T32_OFFSET_U8
 -- : BFD_RELOC_ARM_T32_OFFSET_IMM
 -- : BFD_RELOC_ARM_HWLITERAL
 -- : BFD_RELOC_ARM_THUMB_ADD
 -- : BFD_RELOC_ARM_THUMB_IMM
 -- : BFD_RELOC_ARM_THUMB_SHIFT
     These relocs are only used within the ARM assembler.  They are not
     (at present) written to any object files.

 -- : BFD_RELOC_SH_PCDISP8BY2
 -- : BFD_RELOC_SH_PCDISP12BY2
 -- : BFD_RELOC_SH_IMM3
 -- : BFD_RELOC_SH_IMM3U
 -- : BFD_RELOC_SH_DISP12
 -- : BFD_RELOC_SH_DISP12BY2
 -- : BFD_RELOC_SH_DISP12BY4
 -- : BFD_RELOC_SH_DISP12BY8
 -- : BFD_RELOC_SH_DISP20
 -- : BFD_RELOC_SH_DISP20BY8
 -- : BFD_RELOC_SH_IMM4
 -- : BFD_RELOC_SH_IMM4BY2
 -- : BFD_RELOC_SH_IMM4BY4
 -- : BFD_RELOC_SH_IMM8
 -- : BFD_RELOC_SH_IMM8BY2
 -- : BFD_RELOC_SH_IMM8BY4
 -- : BFD_RELOC_SH_PCRELIMM8BY2
 -- : BFD_RELOC_SH_PCRELIMM8BY4
 -- : BFD_RELOC_SH_SWITCH16
 -- : BFD_RELOC_SH_SWITCH32
 -- : BFD_RELOC_SH_USES
 -- : BFD_RELOC_SH_COUNT
 -- : BFD_RELOC_SH_ALIGN
 -- : BFD_RELOC_SH_CODE
 -- : BFD_RELOC_SH_DATA
 -- : BFD_RELOC_SH_LABEL
 -- : BFD_RELOC_SH_LOOP_START
 -- : BFD_RELOC_SH_LOOP_END
 -- : BFD_RELOC_SH_COPY
 -- : BFD_RELOC_SH_GLOB_DAT
 -- : BFD_RELOC_SH_JMP_SLOT
 -- : BFD_RELOC_SH_RELATIVE
 -- : BFD_RELOC_SH_GOTPC
 -- : BFD_RELOC_SH_GOT_LOW16
 -- : BFD_RELOC_SH_GOT_MEDLOW16
 -- : BFD_RELOC_SH_GOT_MEDHI16
 -- : BFD_RELOC_SH_GOT_HI16
 -- : BFD_RELOC_SH_GOTPLT_LOW16
 -- : BFD_RELOC_SH_GOTPLT_MEDLOW16
 -- : BFD_RELOC_SH_GOTPLT_MEDHI16
 -- : BFD_RELOC_SH_GOTPLT_HI16
 -- : BFD_RELOC_SH_PLT_LOW16
 -- : BFD_RELOC_SH_PLT_MEDLOW16
 -- : BFD_RELOC_SH_PLT_MEDHI16
 -- : BFD_RELOC_SH_PLT_HI16
 -- : BFD_RELOC_SH_GOTOFF_LOW16
 -- : BFD_RELOC_SH_GOTOFF_MEDLOW16
 -- : BFD_RELOC_SH_GOTOFF_MEDHI16
 -- : BFD_RELOC_SH_GOTOFF_HI16
 -- : BFD_RELOC_SH_GOTPC_LOW16
 -- : BFD_RELOC_SH_GOTPC_MEDLOW16
 -- : BFD_RELOC_SH_GOTPC_MEDHI16
 -- : BFD_RELOC_SH_GOTPC_HI16
 -- : BFD_RELOC_SH_COPY64
 -- : BFD_RELOC_SH_GLOB_DAT64
 -- : BFD_RELOC_SH_JMP_SLOT64
 -- : BFD_RELOC_SH_RELATIVE64
 -- : BFD_RELOC_SH_GOT10BY4
 -- : BFD_RELOC_SH_GOT10BY8
 -- : BFD_RELOC_SH_GOTPLT10BY4
 -- : BFD_RELOC_SH_GOTPLT10BY8
 -- : BFD_RELOC_SH_GOTPLT32
 -- : BFD_RELOC_SH_SHMEDIA_CODE
 -- : BFD_RELOC_SH_IMMU5
 -- : BFD_RELOC_SH_IMMS6
 -- : BFD_RELOC_SH_IMMS6BY32
 -- : BFD_RELOC_SH_IMMU6
 -- : BFD_RELOC_SH_IMMS10
 -- : BFD_RELOC_SH_IMMS10BY2
 -- : BFD_RELOC_SH_IMMS10BY4
 -- : BFD_RELOC_SH_IMMS10BY8
 -- : BFD_RELOC_SH_IMMS16
 -- : BFD_RELOC_SH_IMMU16
 -- : BFD_RELOC_SH_IMM_LOW16
 -- : BFD_RELOC_SH_IMM_LOW16_PCREL
 -- : BFD_RELOC_SH_IMM_MEDLOW16
 -- : BFD_RELOC_SH_IMM_MEDLOW16_PCREL
 -- : BFD_RELOC_SH_IMM_MEDHI16
 -- : BFD_RELOC_SH_IMM_MEDHI16_PCREL
 -- : BFD_RELOC_SH_IMM_HI16
 -- : BFD_RELOC_SH_IMM_HI16_PCREL
 -- : BFD_RELOC_SH_PT_16
 -- : BFD_RELOC_SH_TLS_GD_32
 -- : BFD_RELOC_SH_TLS_LD_32
 -- : BFD_RELOC_SH_TLS_LDO_32
 -- : BFD_RELOC_SH_TLS_IE_32
 -- : BFD_RELOC_SH_TLS_LE_32
 -- : BFD_RELOC_SH_TLS_DTPMOD32
 -- : BFD_RELOC_SH_TLS_DTPOFF32
 -- : BFD_RELOC_SH_TLS_TPOFF32
 -- : BFD_RELOC_SH_GOT20
 -- : BFD_RELOC_SH_GOTOFF20
 -- : BFD_RELOC_SH_GOTFUNCDESC
 -- : BFD_RELOC_SH_GOTFUNCDESC20
 -- : BFD_RELOC_SH_GOTOFFFUNCDESC
 -- : BFD_RELOC_SH_GOTOFFFUNCDESC20
 -- : BFD_RELOC_SH_FUNCDESC
     Renesas / SuperH SH relocs.  Not all of these appear in object
     files.

 -- : BFD_RELOC_ARC_NONE
 -- : BFD_RELOC_ARC_8
 -- : BFD_RELOC_ARC_16
 -- : BFD_RELOC_ARC_24
 -- : BFD_RELOC_ARC_32
 -- : BFD_RELOC_ARC_N8
 -- : BFD_RELOC_ARC_N16
 -- : BFD_RELOC_ARC_N24
 -- : BFD_RELOC_ARC_N32
 -- : BFD_RELOC_ARC_SDA
 -- : BFD_RELOC_ARC_SECTOFF
 -- : BFD_RELOC_ARC_S21H_PCREL
 -- : BFD_RELOC_ARC_S21W_PCREL
 -- : BFD_RELOC_ARC_S25H_PCREL
 -- : BFD_RELOC_ARC_S25W_PCREL
 -- : BFD_RELOC_ARC_SDA32
 -- : BFD_RELOC_ARC_SDA_LDST
 -- : BFD_RELOC_ARC_SDA_LDST1
 -- : BFD_RELOC_ARC_SDA_LDST2
 -- : BFD_RELOC_ARC_SDA16_LD
 -- : BFD_RELOC_ARC_SDA16_LD1
 -- : BFD_RELOC_ARC_SDA16_LD2
 -- : BFD_RELOC_ARC_S13_PCREL
 -- : BFD_RELOC_ARC_W
 -- : BFD_RELOC_ARC_32_ME
 -- : BFD_RELOC_ARC_32_ME_S
 -- : BFD_RELOC_ARC_N32_ME
 -- : BFD_RELOC_ARC_SECTOFF_ME
 -- : BFD_RELOC_ARC_SDA32_ME
 -- : BFD_RELOC_ARC_W_ME
 -- : BFD_RELOC_AC_SECTOFF_U8
 -- : BFD_RELOC_AC_SECTOFF_U8_1
 -- : BFD_RELOC_AC_SECTOFF_U8_2
 -- : BFD_RELOC_AC_SECTOFF_S9
 -- : BFD_RELOC_AC_SECTOFF_S9_1
 -- : BFD_RELOC_AC_SECTOFF_S9_2
 -- : BFD_RELOC_ARC_SECTOFF_ME_1
 -- : BFD_RELOC_ARC_SECTOFF_ME_2
 -- : BFD_RELOC_ARC_SECTOFF_1
 -- : BFD_RELOC_ARC_SECTOFF_2
 -- : BFD_RELOC_ARC_SDA_12
 -- : BFD_RELOC_ARC_SDA16_ST2
 -- : BFD_RELOC_ARC_32_PCREL
 -- : BFD_RELOC_ARC_PC32
 -- : BFD_RELOC_ARC_GOT32
 -- : BFD_RELOC_ARC_GOTPC32
 -- : BFD_RELOC_ARC_PLT32
 -- : BFD_RELOC_ARC_COPY
 -- : BFD_RELOC_ARC_GLOB_DAT
 -- : BFD_RELOC_ARC_JMP_SLOT
 -- : BFD_RELOC_ARC_RELATIVE
 -- : BFD_RELOC_ARC_GOTOFF
 -- : BFD_RELOC_ARC_GOTPC
 -- : BFD_RELOC_ARC_S21W_PCREL_PLT
 -- : BFD_RELOC_ARC_S25H_PCREL_PLT
 -- : BFD_RELOC_ARC_TLS_DTPMOD
 -- : BFD_RELOC_ARC_TLS_TPOFF
 -- : BFD_RELOC_ARC_TLS_GD_GOT
 -- : BFD_RELOC_ARC_TLS_GD_LD
 -- : BFD_RELOC_ARC_TLS_GD_CALL
 -- : BFD_RELOC_ARC_TLS_IE_GOT
 -- : BFD_RELOC_ARC_TLS_DTPOFF
 -- : BFD_RELOC_ARC_TLS_DTPOFF_S9
 -- : BFD_RELOC_ARC_TLS_LE_S9
 -- : BFD_RELOC_ARC_TLS_LE_32
 -- : BFD_RELOC_ARC_S25W_PCREL_PLT
 -- : BFD_RELOC_ARC_S21H_PCREL_PLT
 -- : BFD_RELOC_ARC_NPS_CMEM16
 -- : BFD_RELOC_ARC_JLI_SECTOFF
     ARC relocs.

 -- : BFD_RELOC_BFIN_16_IMM
     ADI Blackfin 16 bit immediate absolute reloc.

 -- : BFD_RELOC_BFIN_16_HIGH
     ADI Blackfin 16 bit immediate absolute reloc higher 16 bits.

 -- : BFD_RELOC_BFIN_4_PCREL
     ADI Blackfin 'a' part of LSETUP.

 -- : BFD_RELOC_BFIN_5_PCREL
     ADI Blackfin.

 -- : BFD_RELOC_BFIN_16_LOW
     ADI Blackfin 16 bit immediate absolute reloc lower 16 bits.

 -- : BFD_RELOC_BFIN_10_PCREL
     ADI Blackfin.

 -- : BFD_RELOC_BFIN_11_PCREL
     ADI Blackfin 'b' part of LSETUP.

 -- : BFD_RELOC_BFIN_12_PCREL_JUMP
     ADI Blackfin.

 -- : BFD_RELOC_BFIN_12_PCREL_JUMP_S
     ADI Blackfin Short jump, pcrel.

 -- : BFD_RELOC_BFIN_24_PCREL_CALL_X
     ADI Blackfin Call.x not implemented.

 -- : BFD_RELOC_BFIN_24_PCREL_JUMP_L
     ADI Blackfin Long Jump pcrel.

 -- : BFD_RELOC_BFIN_GOT17M4
 -- : BFD_RELOC_BFIN_GOTHI
 -- : BFD_RELOC_BFIN_GOTLO
 -- : BFD_RELOC_BFIN_FUNCDESC
 -- : BFD_RELOC_BFIN_FUNCDESC_GOT17M4
 -- : BFD_RELOC_BFIN_FUNCDESC_GOTHI
 -- : BFD_RELOC_BFIN_FUNCDESC_GOTLO
 -- : BFD_RELOC_BFIN_FUNCDESC_VALUE
 -- : BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4
 -- : BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI
 -- : BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO
 -- : BFD_RELOC_BFIN_GOTOFF17M4
 -- : BFD_RELOC_BFIN_GOTOFFHI
 -- : BFD_RELOC_BFIN_GOTOFFLO
     ADI Blackfin FD-PIC relocations.

 -- : BFD_RELOC_BFIN_GOT
     ADI Blackfin GOT relocation.

 -- : BFD_RELOC_BFIN_PLTPC
     ADI Blackfin PLTPC relocation.

 -- : BFD_ARELOC_BFIN_PUSH
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_CONST
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_ADD
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_SUB
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_MULT
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_DIV
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_MOD
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_LSHIFT
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_RSHIFT
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_AND
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_OR
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_XOR
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_LAND
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_LOR
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_LEN
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_NEG
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_COMP
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_PAGE
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_HWPAGE
     ADI Blackfin arithmetic relocation.

 -- : BFD_ARELOC_BFIN_ADDR
     ADI Blackfin arithmetic relocation.

 -- : BFD_RELOC_D10V_10_PCREL_R
     Mitsubishi D10V relocs.  This is a 10-bit reloc with the right 2
     bits assumed to be 0.

 -- : BFD_RELOC_D10V_10_PCREL_L
     Mitsubishi D10V relocs.  This is a 10-bit reloc with the right 2
     bits assumed to be 0.  This is the same as the previous reloc
     except it is in the left container, i.e., shifted left 15 bits.

 -- : BFD_RELOC_D10V_18
     This is an 18-bit reloc with the right 2 bits assumed to be 0.

 -- : BFD_RELOC_D10V_18_PCREL
     This is an 18-bit reloc with the right 2 bits assumed to be 0.

 -- : BFD_RELOC_D30V_6
     Mitsubishi D30V relocs.  This is a 6-bit absolute reloc.

 -- : BFD_RELOC_D30V_9_PCREL
     This is a 6-bit pc-relative reloc with the right 3 bits assumed to
     be 0.

 -- : BFD_RELOC_D30V_9_PCREL_R
     This is a 6-bit pc-relative reloc with the right 3 bits assumed to
     be 0. Same as the previous reloc but on the right side of the
     container.

 -- : BFD_RELOC_D30V_15
     This is a 12-bit absolute reloc with the right 3 bitsassumed to be
     0.

 -- : BFD_RELOC_D30V_15_PCREL
     This is a 12-bit pc-relative reloc with the right 3 bits assumed
     to be 0.

 -- : BFD_RELOC_D30V_15_PCREL_R
     This is a 12-bit pc-relative reloc with the right 3 bits assumed
     to be 0. Same as the previous reloc but on the right side of the
     container.

 -- : BFD_RELOC_D30V_21
     This is an 18-bit absolute reloc with the right 3 bits assumed to
     be 0.

 -- : BFD_RELOC_D30V_21_PCREL
     This is an 18-bit pc-relative reloc with the right 3 bits assumed
     to be 0.

 -- : BFD_RELOC_D30V_21_PCREL_R
     This is an 18-bit pc-relative reloc with the right 3 bits assumed
     to be 0. Same as the previous reloc but on the right side of the
     container.

 -- : BFD_RELOC_D30V_32
     This is a 32-bit absolute reloc.

 -- : BFD_RELOC_D30V_32_PCREL
     This is a 32-bit pc-relative reloc.

 -- : BFD_RELOC_DLX_HI16_S
     DLX relocs

 -- : BFD_RELOC_DLX_LO16
     DLX relocs

 -- : BFD_RELOC_DLX_JMP26
     DLX relocs

 -- : BFD_RELOC_M32C_HI8
 -- : BFD_RELOC_M32C_RL_JUMP
 -- : BFD_RELOC_M32C_RL_1ADDR
 -- : BFD_RELOC_M32C_RL_2ADDR
     Renesas M16C/M32C Relocations.

 -- : BFD_RELOC_M32R_24
     Renesas M32R (formerly Mitsubishi M32R) relocs.  This is a 24 bit
     absolute address.

 -- : BFD_RELOC_M32R_10_PCREL
     This is a 10-bit pc-relative reloc with the right 2 bits assumed
     to be 0.

 -- : BFD_RELOC_M32R_18_PCREL
     This is an 18-bit reloc with the right 2 bits assumed to be 0.

 -- : BFD_RELOC_M32R_26_PCREL
     This is a 26-bit reloc with the right 2 bits assumed to be 0.

 -- : BFD_RELOC_M32R_HI16_ULO
     This is a 16-bit reloc containing the high 16 bits of an address
     used when the lower 16 bits are treated as unsigned.

 -- : BFD_RELOC_M32R_HI16_SLO
     This is a 16-bit reloc containing the high 16 bits of an address
     used when the lower 16 bits are treated as signed.

 -- : BFD_RELOC_M32R_LO16
     This is a 16-bit reloc containing the lower 16 bits of an address.

 -- : BFD_RELOC_M32R_SDA16
     This is a 16-bit reloc containing the small data area offset for
     use in add3, load, and store instructions.

 -- : BFD_RELOC_M32R_GOT24
 -- : BFD_RELOC_M32R_26_PLTREL
 -- : BFD_RELOC_M32R_COPY
 -- : BFD_RELOC_M32R_GLOB_DAT
 -- : BFD_RELOC_M32R_JMP_SLOT
 -- : BFD_RELOC_M32R_RELATIVE
 -- : BFD_RELOC_M32R_GOTOFF
 -- : BFD_RELOC_M32R_GOTOFF_HI_ULO
 -- : BFD_RELOC_M32R_GOTOFF_HI_SLO
 -- : BFD_RELOC_M32R_GOTOFF_LO
 -- : BFD_RELOC_M32R_GOTPC24
 -- : BFD_RELOC_M32R_GOT16_HI_ULO
 -- : BFD_RELOC_M32R_GOT16_HI_SLO
 -- : BFD_RELOC_M32R_GOT16_LO
 -- : BFD_RELOC_M32R_GOTPC_HI_ULO
 -- : BFD_RELOC_M32R_GOTPC_HI_SLO
 -- : BFD_RELOC_M32R_GOTPC_LO
     For PIC.

 -- : BFD_RELOC_NDS32_20
     NDS32 relocs.  This is a 20 bit absolute address.

 -- : BFD_RELOC_NDS32_9_PCREL
     This is a 9-bit pc-relative reloc with the right 1 bit assumed to
     be 0.

 -- : BFD_RELOC_NDS32_WORD_9_PCREL
     This is a 9-bit pc-relative reloc with the right 1 bit assumed to
     be 0.

 -- : BFD_RELOC_NDS32_15_PCREL
     This is an 15-bit reloc with the right 1 bit assumed to be 0.

 -- : BFD_RELOC_NDS32_17_PCREL
     This is an 17-bit reloc with the right 1 bit assumed to be 0.

 -- : BFD_RELOC_NDS32_25_PCREL
     This is a 25-bit reloc with the right 1 bit assumed to be 0.

 -- : BFD_RELOC_NDS32_HI20
     This is a 20-bit reloc containing the high 20 bits of an address
     used with the lower 12 bits

 -- : BFD_RELOC_NDS32_LO12S3
     This is a 12-bit reloc containing the lower 12 bits of an address
     then shift right by 3. This is used with ldi,sdi...

 -- : BFD_RELOC_NDS32_LO12S2
     This is a 12-bit reloc containing the lower 12 bits of an address
     then shift left by 2. This is used with lwi,swi...

 -- : BFD_RELOC_NDS32_LO12S1
     This is a 12-bit reloc containing the lower 12 bits of an address
     then shift left by 1. This is used with lhi,shi...

 -- : BFD_RELOC_NDS32_LO12S0
     This is a 12-bit reloc containing the lower 12 bits of an address
     then shift left by 0. This is used with lbisbi...

 -- : BFD_RELOC_NDS32_LO12S0_ORI
     This is a 12-bit reloc containing the lower 12 bits of an address
     then shift left by 0. This is only used with branch relaxations

 -- : BFD_RELOC_NDS32_SDA15S3
     This is a 15-bit reloc containing the small data area 18-bit
     signed offset and shift left by 3 for use in ldi, sdi...

 -- : BFD_RELOC_NDS32_SDA15S2
     This is a 15-bit reloc containing the small data area 17-bit
     signed offset and shift left by 2 for use in lwi, swi...

 -- : BFD_RELOC_NDS32_SDA15S1
     This is a 15-bit reloc containing the small data area 16-bit
     signed offset and shift left by 1 for use in lhi, shi...

 -- : BFD_RELOC_NDS32_SDA15S0
     This is a 15-bit reloc containing the small data area 15-bit
     signed offset and shift left by 0 for use in lbi, sbi...

 -- : BFD_RELOC_NDS32_SDA16S3
     This is a 16-bit reloc containing the small data area 16-bit
     signed offset and shift left by 3

 -- : BFD_RELOC_NDS32_SDA17S2
     This is a 17-bit reloc containing the small data area 17-bit
     signed offset and shift left by 2 for use in lwi.gp, swi.gp...

 -- : BFD_RELOC_NDS32_SDA18S1
     This is a 18-bit reloc containing the small data area 18-bit
     signed offset and shift left by 1 for use in lhi.gp, shi.gp...

 -- : BFD_RELOC_NDS32_SDA19S0
     This is a 19-bit reloc containing the small data area 19-bit
     signed offset and shift left by 0 for use in lbi.gp, sbi.gp...

 -- : BFD_RELOC_NDS32_GOT20
 -- : BFD_RELOC_NDS32_9_PLTREL
 -- : BFD_RELOC_NDS32_25_PLTREL
 -- : BFD_RELOC_NDS32_COPY
 -- : BFD_RELOC_NDS32_GLOB_DAT
 -- : BFD_RELOC_NDS32_JMP_SLOT
 -- : BFD_RELOC_NDS32_RELATIVE
 -- : BFD_RELOC_NDS32_GOTOFF
 -- : BFD_RELOC_NDS32_GOTOFF_HI20
 -- : BFD_RELOC_NDS32_GOTOFF_LO12
 -- : BFD_RELOC_NDS32_GOTPC20
 -- : BFD_RELOC_NDS32_GOT_HI20
 -- : BFD_RELOC_NDS32_GOT_LO12
 -- : BFD_RELOC_NDS32_GOTPC_HI20
 -- : BFD_RELOC_NDS32_GOTPC_LO12
     for PIC

 -- : BFD_RELOC_NDS32_INSN16
 -- : BFD_RELOC_NDS32_LABEL
 -- : BFD_RELOC_NDS32_LONGCALL1
 -- : BFD_RELOC_NDS32_LONGCALL2
 -- : BFD_RELOC_NDS32_LONGCALL3
 -- : BFD_RELOC_NDS32_LONGJUMP1
 -- : BFD_RELOC_NDS32_LONGJUMP2
 -- : BFD_RELOC_NDS32_LONGJUMP3
 -- : BFD_RELOC_NDS32_LOADSTORE
 -- : BFD_RELOC_NDS32_9_FIXED
 -- : BFD_RELOC_NDS32_15_FIXED
 -- : BFD_RELOC_NDS32_17_FIXED
 -- : BFD_RELOC_NDS32_25_FIXED
 -- : BFD_RELOC_NDS32_LONGCALL4
 -- : BFD_RELOC_NDS32_LONGCALL5
 -- : BFD_RELOC_NDS32_LONGCALL6
 -- : BFD_RELOC_NDS32_LONGJUMP4
 -- : BFD_RELOC_NDS32_LONGJUMP5
 -- : BFD_RELOC_NDS32_LONGJUMP6
 -- : BFD_RELOC_NDS32_LONGJUMP7
     for relax

 -- : BFD_RELOC_NDS32_PLTREL_HI20
 -- : BFD_RELOC_NDS32_PLTREL_LO12
 -- : BFD_RELOC_NDS32_PLT_GOTREL_HI20
 -- : BFD_RELOC_NDS32_PLT_GOTREL_LO12
     for PIC

 -- : BFD_RELOC_NDS32_SDA12S2_DP
 -- : BFD_RELOC_NDS32_SDA12S2_SP
 -- : BFD_RELOC_NDS32_LO12S2_DP
 -- : BFD_RELOC_NDS32_LO12S2_SP
     for floating point

 -- : BFD_RELOC_NDS32_DWARF2_OP1
 -- : BFD_RELOC_NDS32_DWARF2_OP2
 -- : BFD_RELOC_NDS32_DWARF2_LEB
     for dwarf2 debug_line.

 -- : BFD_RELOC_NDS32_UPDATE_TA
     for eliminate 16-bit instructions

 -- : BFD_RELOC_NDS32_PLT_GOTREL_LO20
 -- : BFD_RELOC_NDS32_PLT_GOTREL_LO15
 -- : BFD_RELOC_NDS32_PLT_GOTREL_LO19
 -- : BFD_RELOC_NDS32_GOT_LO15
 -- : BFD_RELOC_NDS32_GOT_LO19
 -- : BFD_RELOC_NDS32_GOTOFF_LO15
 -- : BFD_RELOC_NDS32_GOTOFF_LO19
 -- : BFD_RELOC_NDS32_GOT15S2
 -- : BFD_RELOC_NDS32_GOT17S2
     for PIC object relaxation

 -- : BFD_RELOC_NDS32_5
     NDS32 relocs.  This is a 5 bit absolute address.

 -- : BFD_RELOC_NDS32_10_UPCREL
     This is a 10-bit unsigned pc-relative reloc with the right 1 bit
     assumed to be 0.

 -- : BFD_RELOC_NDS32_SDA_FP7U2_RELA
     If fp were omitted, fp can used as another gp.

 -- : BFD_RELOC_NDS32_RELAX_ENTRY
 -- : BFD_RELOC_NDS32_GOT_SUFF
 -- : BFD_RELOC_NDS32_GOTOFF_SUFF
 -- : BFD_RELOC_NDS32_PLT_GOT_SUFF
 -- : BFD_RELOC_NDS32_MULCALL_SUFF
 -- : BFD_RELOC_NDS32_PTR
 -- : BFD_RELOC_NDS32_PTR_COUNT
 -- : BFD_RELOC_NDS32_PTR_RESOLVED
 -- : BFD_RELOC_NDS32_PLTBLOCK
 -- : BFD_RELOC_NDS32_RELAX_REGION_BEGIN
 -- : BFD_RELOC_NDS32_RELAX_REGION_END
 -- : BFD_RELOC_NDS32_MINUEND
 -- : BFD_RELOC_NDS32_SUBTRAHEND
 -- : BFD_RELOC_NDS32_DIFF8
 -- : BFD_RELOC_NDS32_DIFF16
 -- : BFD_RELOC_NDS32_DIFF32
 -- : BFD_RELOC_NDS32_DIFF_ULEB128
 -- : BFD_RELOC_NDS32_EMPTY
     relaxation relative relocation types

 -- : BFD_RELOC_NDS32_25_ABS
     This is a 25 bit absolute address.

 -- : BFD_RELOC_NDS32_DATA
 -- : BFD_RELOC_NDS32_TRAN
 -- : BFD_RELOC_NDS32_17IFC_PCREL
 -- : BFD_RELOC_NDS32_10IFCU_PCREL
     For ex9 and ifc using.

 -- : BFD_RELOC_NDS32_TPOFF
 -- : BFD_RELOC_NDS32_GOTTPOFF
 -- : BFD_RELOC_NDS32_TLS_LE_HI20
 -- : BFD_RELOC_NDS32_TLS_LE_LO12
 -- : BFD_RELOC_NDS32_TLS_LE_20
 -- : BFD_RELOC_NDS32_TLS_LE_15S0
 -- : BFD_RELOC_NDS32_TLS_LE_15S1
 -- : BFD_RELOC_NDS32_TLS_LE_15S2
 -- : BFD_RELOC_NDS32_TLS_LE_ADD
 -- : BFD_RELOC_NDS32_TLS_LE_LS
 -- : BFD_RELOC_NDS32_TLS_IE_HI20
 -- : BFD_RELOC_NDS32_TLS_IE_LO12
 -- : BFD_RELOC_NDS32_TLS_IE_LO12S2
 -- : BFD_RELOC_NDS32_TLS_IEGP_HI20
 -- : BFD_RELOC_NDS32_TLS_IEGP_LO12
 -- : BFD_RELOC_NDS32_TLS_IEGP_LO12S2
 -- : BFD_RELOC_NDS32_TLS_IEGP_LW
 -- : BFD_RELOC_NDS32_TLS_DESC
 -- : BFD_RELOC_NDS32_TLS_DESC_HI20
 -- : BFD_RELOC_NDS32_TLS_DESC_LO12
 -- : BFD_RELOC_NDS32_TLS_DESC_20
 -- : BFD_RELOC_NDS32_TLS_DESC_SDA17S2
 -- : BFD_RELOC_NDS32_TLS_DESC_ADD
 -- : BFD_RELOC_NDS32_TLS_DESC_FUNC
 -- : BFD_RELOC_NDS32_TLS_DESC_CALL
 -- : BFD_RELOC_NDS32_TLS_DESC_MEM
 -- : BFD_RELOC_NDS32_REMOVE
 -- : BFD_RELOC_NDS32_GROUP
     For TLS.

 -- : BFD_RELOC_NDS32_LSI
     For floating load store relaxation.

 -- : BFD_RELOC_V850_9_PCREL
     This is a 9-bit reloc

 -- : BFD_RELOC_V850_22_PCREL
     This is a 22-bit reloc

 -- : BFD_RELOC_V850_SDA_16_16_OFFSET
     This is a 16 bit offset from the short data area pointer.

 -- : BFD_RELOC_V850_SDA_15_16_OFFSET
     This is a 16 bit offset (of which only 15 bits are used) from the
     short data area pointer.

 -- : BFD_RELOC_V850_ZDA_16_16_OFFSET
     This is a 16 bit offset from the zero data area pointer.

 -- : BFD_RELOC_V850_ZDA_15_16_OFFSET
     This is a 16 bit offset (of which only 15 bits are used) from the
     zero data area pointer.

 -- : BFD_RELOC_V850_TDA_6_8_OFFSET
     This is an 8 bit offset (of which only 6 bits are used) from the
     tiny data area pointer.

 -- : BFD_RELOC_V850_TDA_7_8_OFFSET
     This is an 8bit offset (of which only 7 bits are used) from the
     tiny data area pointer.

 -- : BFD_RELOC_V850_TDA_7_7_OFFSET
     This is a 7 bit offset from the tiny data area pointer.

 -- : BFD_RELOC_V850_TDA_16_16_OFFSET
     This is a 16 bit offset from the tiny data area pointer.

 -- : BFD_RELOC_V850_TDA_4_5_OFFSET
     This is a 5 bit offset (of which only 4 bits are used) from the
     tiny data area pointer.

 -- : BFD_RELOC_V850_TDA_4_4_OFFSET
     This is a 4 bit offset from the tiny data area pointer.

 -- : BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET
     This is a 16 bit offset from the short data area pointer, with the
     bits placed non-contiguously in the instruction.

 -- : BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET
     This is a 16 bit offset from the zero data area pointer, with the
     bits placed non-contiguously in the instruction.

 -- : BFD_RELOC_V850_CALLT_6_7_OFFSET
     This is a 6 bit offset from the call table base pointer.

 -- : BFD_RELOC_V850_CALLT_16_16_OFFSET
     This is a 16 bit offset from the call table base pointer.

 -- : BFD_RELOC_V850_LONGCALL
     Used for relaxing indirect function calls.

 -- : BFD_RELOC_V850_LONGJUMP
     Used for relaxing indirect jumps.

 -- : BFD_RELOC_V850_ALIGN
     Used to maintain alignment whilst relaxing.

 -- : BFD_RELOC_V850_LO16_SPLIT_OFFSET
     This is a variation of BFD_RELOC_LO16 that can be used in v850e
     ld.bu instructions.

 -- : BFD_RELOC_V850_16_PCREL
     This is a 16-bit reloc.

 -- : BFD_RELOC_V850_17_PCREL
     This is a 17-bit reloc.

 -- : BFD_RELOC_V850_23
     This is a 23-bit reloc.

 -- : BFD_RELOC_V850_32_PCREL
     This is a 32-bit reloc.

 -- : BFD_RELOC_V850_32_ABS
     This is a 32-bit reloc.

 -- : BFD_RELOC_V850_16_SPLIT_OFFSET
     This is a 16-bit reloc.

 -- : BFD_RELOC_V850_16_S1
     This is a 16-bit reloc.

 -- : BFD_RELOC_V850_LO16_S1
     Low 16 bits. 16 bit shifted by 1.

 -- : BFD_RELOC_V850_CALLT_15_16_OFFSET
     This is a 16 bit offset from the call table base pointer.

 -- : BFD_RELOC_V850_32_GOTPCREL
     DSO relocations.

 -- : BFD_RELOC_V850_16_GOT
     DSO relocations.

 -- : BFD_RELOC_V850_32_GOT
     DSO relocations.

 -- : BFD_RELOC_V850_22_PLT_PCREL
     DSO relocations.

 -- : BFD_RELOC_V850_32_PLT_PCREL
     DSO relocations.

 -- : BFD_RELOC_V850_COPY
     DSO relocations.

 -- : BFD_RELOC_V850_GLOB_DAT
     DSO relocations.

 -- : BFD_RELOC_V850_JMP_SLOT
     DSO relocations.

 -- : BFD_RELOC_V850_RELATIVE
     DSO relocations.

 -- : BFD_RELOC_V850_16_GOTOFF
     DSO relocations.

 -- : BFD_RELOC_V850_32_GOTOFF
     DSO relocations.

 -- : BFD_RELOC_V850_CODE
     start code.

 -- : BFD_RELOC_V850_DATA
     start data in text.

 -- : BFD_RELOC_TIC30_LDP
     This is a 8bit DP reloc for the tms320c30, where the most
     significant 8 bits of a 24 bit word are placed into the least
     significant 8 bits of the opcode.

 -- : BFD_RELOC_TIC54X_PARTLS7
     This is a 7bit reloc for the tms320c54x, where the least
     significant 7 bits of a 16 bit word are placed into the least
     significant 7 bits of the opcode.

 -- : BFD_RELOC_TIC54X_PARTMS9
     This is a 9bit DP reloc for the tms320c54x, where the most
     significant 9 bits of a 16 bit word are placed into the least
     significant 9 bits of the opcode.

 -- : BFD_RELOC_TIC54X_23
     This is an extended address 23-bit reloc for the tms320c54x.

 -- : BFD_RELOC_TIC54X_16_OF_23
     This is a 16-bit reloc for the tms320c54x, where the least
     significant 16 bits of a 23-bit extended address are placed into
     the opcode.

 -- : BFD_RELOC_TIC54X_MS7_OF_23
     This is a reloc for the tms320c54x, where the most significant 7
     bits of a 23-bit extended address are placed into the opcode.

 -- : BFD_RELOC_C6000_PCR_S21
 -- : BFD_RELOC_C6000_PCR_S12
 -- : BFD_RELOC_C6000_PCR_S10
 -- : BFD_RELOC_C6000_PCR_S7
 -- : BFD_RELOC_C6000_ABS_S16
 -- : BFD_RELOC_C6000_ABS_L16
 -- : BFD_RELOC_C6000_ABS_H16
 -- : BFD_RELOC_C6000_SBR_U15_B
 -- : BFD_RELOC_C6000_SBR_U15_H
 -- : BFD_RELOC_C6000_SBR_U15_W
 -- : BFD_RELOC_C6000_SBR_S16
 -- : BFD_RELOC_C6000_SBR_L16_B
 -- : BFD_RELOC_C6000_SBR_L16_H
 -- : BFD_RELOC_C6000_SBR_L16_W
 -- : BFD_RELOC_C6000_SBR_H16_B
 -- : BFD_RELOC_C6000_SBR_H16_H
 -- : BFD_RELOC_C6000_SBR_H16_W
 -- : BFD_RELOC_C6000_SBR_GOT_U15_W
 -- : BFD_RELOC_C6000_SBR_GOT_L16_W
 -- : BFD_RELOC_C6000_SBR_GOT_H16_W
 -- : BFD_RELOC_C6000_DSBT_INDEX
 -- : BFD_RELOC_C6000_PREL31
 -- : BFD_RELOC_C6000_COPY
 -- : BFD_RELOC_C6000_JUMP_SLOT
 -- : BFD_RELOC_C6000_EHTYPE
 -- : BFD_RELOC_C6000_PCR_H16
 -- : BFD_RELOC_C6000_PCR_L16
 -- : BFD_RELOC_C6000_ALIGN
 -- : BFD_RELOC_C6000_FPHEAD
 -- : BFD_RELOC_C6000_NOCMP
     TMS320C6000 relocations.

 -- : BFD_RELOC_FR30_48
     This is a 48 bit reloc for the FR30 that stores 32 bits.

 -- : BFD_RELOC_FR30_20
     This is a 32 bit reloc for the FR30 that stores 20 bits split up
     into two sections.

 -- : BFD_RELOC_FR30_6_IN_4
     This is a 16 bit reloc for the FR30 that stores a 6 bit word
     offset in 4 bits.

 -- : BFD_RELOC_FR30_8_IN_8
     This is a 16 bit reloc for the FR30 that stores an 8 bit byte
     offset into 8 bits.

 -- : BFD_RELOC_FR30_9_IN_8
     This is a 16 bit reloc for the FR30 that stores a 9 bit short
     offset into 8 bits.

 -- : BFD_RELOC_FR30_10_IN_8
     This is a 16 bit reloc for the FR30 that stores a 10 bit word
     offset into 8 bits.

 -- : BFD_RELOC_FR30_9_PCREL
     This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
     short offset into 8 bits.

 -- : BFD_RELOC_FR30_12_PCREL
     This is a 16 bit reloc for the FR30 that stores a 12 bit pc
     relative short offset into 11 bits.

 -- : BFD_RELOC_MCORE_PCREL_IMM8BY4
 -- : BFD_RELOC_MCORE_PCREL_IMM11BY2
 -- : BFD_RELOC_MCORE_PCREL_IMM4BY2
 -- : BFD_RELOC_MCORE_PCREL_32
 -- : BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2
 -- : BFD_RELOC_MCORE_RVA
     Motorola Mcore relocations.

 -- : BFD_RELOC_MEP_8
 -- : BFD_RELOC_MEP_16
 -- : BFD_RELOC_MEP_32
 -- : BFD_RELOC_MEP_PCREL8A2
 -- : BFD_RELOC_MEP_PCREL12A2
 -- : BFD_RELOC_MEP_PCREL17A2
 -- : BFD_RELOC_MEP_PCREL24A2
 -- : BFD_RELOC_MEP_PCABS24A2
 -- : BFD_RELOC_MEP_LOW16
 -- : BFD_RELOC_MEP_HI16U
 -- : BFD_RELOC_MEP_HI16S
 -- : BFD_RELOC_MEP_GPREL
 -- : BFD_RELOC_MEP_TPREL
 -- : BFD_RELOC_MEP_TPREL7
 -- : BFD_RELOC_MEP_TPREL7A2
 -- : BFD_RELOC_MEP_TPREL7A4
 -- : BFD_RELOC_MEP_UIMM24
 -- : BFD_RELOC_MEP_ADDR24A4
 -- : BFD_RELOC_MEP_GNU_VTINHERIT
 -- : BFD_RELOC_MEP_GNU_VTENTRY
     Toshiba Media Processor Relocations.

 -- : BFD_RELOC_METAG_HIADDR16
 -- : BFD_RELOC_METAG_LOADDR16
 -- : BFD_RELOC_METAG_RELBRANCH
 -- : BFD_RELOC_METAG_GETSETOFF
 -- : BFD_RELOC_METAG_HIOG
 -- : BFD_RELOC_METAG_LOOG
 -- : BFD_RELOC_METAG_REL8
 -- : BFD_RELOC_METAG_REL16
 -- : BFD_RELOC_METAG_HI16_GOTOFF
 -- : BFD_RELOC_METAG_LO16_GOTOFF
 -- : BFD_RELOC_METAG_GETSET_GOTOFF
 -- : BFD_RELOC_METAG_GETSET_GOT
 -- : BFD_RELOC_METAG_HI16_GOTPC
 -- : BFD_RELOC_METAG_LO16_GOTPC
 -- : BFD_RELOC_METAG_HI16_PLT
 -- : BFD_RELOC_METAG_LO16_PLT
 -- : BFD_RELOC_METAG_RELBRANCH_PLT
 -- : BFD_RELOC_METAG_GOTOFF
 -- : BFD_RELOC_METAG_PLT
 -- : BFD_RELOC_METAG_COPY
 -- : BFD_RELOC_METAG_JMP_SLOT
 -- : BFD_RELOC_METAG_RELATIVE
 -- : BFD_RELOC_METAG_GLOB_DAT
 -- : BFD_RELOC_METAG_TLS_GD
 -- : BFD_RELOC_METAG_TLS_LDM
 -- : BFD_RELOC_METAG_TLS_LDO_HI16
 -- : BFD_RELOC_METAG_TLS_LDO_LO16
 -- : BFD_RELOC_METAG_TLS_LDO
 -- : BFD_RELOC_METAG_TLS_IE
 -- : BFD_RELOC_METAG_TLS_IENONPIC
 -- : BFD_RELOC_METAG_TLS_IENONPIC_HI16
 -- : BFD_RELOC_METAG_TLS_IENONPIC_LO16
 -- : BFD_RELOC_METAG_TLS_TPOFF
 -- : BFD_RELOC_METAG_TLS_DTPMOD
 -- : BFD_RELOC_METAG_TLS_DTPOFF
 -- : BFD_RELOC_METAG_TLS_LE
 -- : BFD_RELOC_METAG_TLS_LE_HI16
 -- : BFD_RELOC_METAG_TLS_LE_LO16
     Imagination Technologies Meta relocations.

 -- : BFD_RELOC_MMIX_GETA
 -- : BFD_RELOC_MMIX_GETA_1
 -- : BFD_RELOC_MMIX_GETA_2
 -- : BFD_RELOC_MMIX_GETA_3
     These are relocations for the GETA instruction.

 -- : BFD_RELOC_MMIX_CBRANCH
 -- : BFD_RELOC_MMIX_CBRANCH_J
 -- : BFD_RELOC_MMIX_CBRANCH_1
 -- : BFD_RELOC_MMIX_CBRANCH_2
 -- : BFD_RELOC_MMIX_CBRANCH_3
     These are relocations for a conditional branch instruction.

 -- : BFD_RELOC_MMIX_PUSHJ
 -- : BFD_RELOC_MMIX_PUSHJ_1
 -- : BFD_RELOC_MMIX_PUSHJ_2
 -- : BFD_RELOC_MMIX_PUSHJ_3
 -- : BFD_RELOC_MMIX_PUSHJ_STUBBABLE
     These are relocations for the PUSHJ instruction.

 -- : BFD_RELOC_MMIX_JMP
 -- : BFD_RELOC_MMIX_JMP_1
 -- : BFD_RELOC_MMIX_JMP_2
 -- : BFD_RELOC_MMIX_JMP_3
     These are relocations for the JMP instruction.

 -- : BFD_RELOC_MMIX_ADDR19
     This is a relocation for a relative address as in a GETA
     instruction or a branch.

 -- : BFD_RELOC_MMIX_ADDR27
     This is a relocation for a relative address as in a JMP
     instruction.

 -- : BFD_RELOC_MMIX_REG_OR_BYTE
     This is a relocation for an instruction field that may be a general
     register or a value 0..255.

 -- : BFD_RELOC_MMIX_REG
     This is a relocation for an instruction field that may be a general
     register.

 -- : BFD_RELOC_MMIX_BASE_PLUS_OFFSET
     This is a relocation for two instruction fields holding a register
     and an offset, the equivalent of the relocation.

 -- : BFD_RELOC_MMIX_LOCAL
     This relocation is an assertion that the expression is not
     allocated as a global register.  It does not modify contents.

 -- : BFD_RELOC_AVR_7_PCREL
     This is a 16 bit reloc for the AVR that stores 8 bit pc relative
     short offset into 7 bits.

 -- : BFD_RELOC_AVR_13_PCREL
     This is a 16 bit reloc for the AVR that stores 13 bit pc relative
     short offset into 12 bits.

 -- : BFD_RELOC_AVR_16_PM
     This is a 16 bit reloc for the AVR that stores 17 bit value
     (usually program memory address) into 16 bits.

 -- : BFD_RELOC_AVR_LO8_LDI
     This is a 16 bit reloc for the AVR that stores 8 bit value (usually
     data memory address) into 8 bit immediate value of LDI insn.

 -- : BFD_RELOC_AVR_HI8_LDI
     This is a 16 bit reloc for the AVR that stores 8 bit value (high 8
     bit of data memory address) into 8 bit immediate value of LDI insn.

 -- : BFD_RELOC_AVR_HH8_LDI
     This is a 16 bit reloc for the AVR that stores 8 bit value (most
     high 8 bit of program memory address) into 8 bit immediate value
     of LDI insn.

 -- : BFD_RELOC_AVR_MS8_LDI
     This is a 16 bit reloc for the AVR that stores 8 bit value (most
     high 8 bit of 32 bit value) into 8 bit immediate value of LDI insn.

 -- : BFD_RELOC_AVR_LO8_LDI_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (usually data memory address) into 8 bit immediate value of SUBI
     insn.

 -- : BFD_RELOC_AVR_HI8_LDI_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (high 8 bit of data memory address) into 8 bit immediate value of
     SUBI insn.

 -- : BFD_RELOC_AVR_HH8_LDI_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (most high 8 bit of program memory address) into 8 bit immediate
     value of LDI or SUBI insn.

 -- : BFD_RELOC_AVR_MS8_LDI_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (msb of 32 bit value) into 8 bit immediate value of LDI insn.

 -- : BFD_RELOC_AVR_LO8_LDI_PM
     This is a 16 bit reloc for the AVR that stores 8 bit value (usually
     command address) into 8 bit immediate value of LDI insn.

 -- : BFD_RELOC_AVR_LO8_LDI_GS
     This is a 16 bit reloc for the AVR that stores 8 bit value
     (command address) into 8 bit immediate value of LDI insn. If the
     address is beyond the 128k boundary, the linker inserts a jump
     stub for this reloc in the lower 128k.

 -- : BFD_RELOC_AVR_HI8_LDI_PM
     This is a 16 bit reloc for the AVR that stores 8 bit value (high 8
     bit of command address) into 8 bit immediate value of LDI insn.

 -- : BFD_RELOC_AVR_HI8_LDI_GS
     This is a 16 bit reloc for the AVR that stores 8 bit value (high 8
     bit of command address) into 8 bit immediate value of LDI insn.
     If the address is beyond the 128k boundary, the linker inserts a
     jump stub for this reloc below 128k.

 -- : BFD_RELOC_AVR_HH8_LDI_PM
     This is a 16 bit reloc for the AVR that stores 8 bit value (most
     high 8 bit of command address) into 8 bit immediate value of LDI
     insn.

 -- : BFD_RELOC_AVR_LO8_LDI_PM_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (usually command address) into 8 bit immediate value of SUBI insn.

 -- : BFD_RELOC_AVR_HI8_LDI_PM_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (high 8 bit of 16 bit command address) into 8 bit immediate value
     of SUBI insn.

 -- : BFD_RELOC_AVR_HH8_LDI_PM_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (high 6 bit of 22 bit command address) into 8 bit immediate value
     of SUBI insn.

 -- : BFD_RELOC_AVR_CALL
     This is a 32 bit reloc for the AVR that stores 23 bit value into
     22 bits.

 -- : BFD_RELOC_AVR_LDI
     This is a 16 bit reloc for the AVR that stores all needed bits for
     absolute addressing with ldi with overflow check to linktime

 -- : BFD_RELOC_AVR_6
     This is a 6 bit reloc for the AVR that stores offset for ldd/std
     instructions

 -- : BFD_RELOC_AVR_6_ADIW
     This is a 6 bit reloc for the AVR that stores offset for adiw/sbiw
     instructions

 -- : BFD_RELOC_AVR_8_LO
     This is a 8 bit reloc for the AVR that stores bits 0..7 of a symbol
     in .byte lo8(symbol)

 -- : BFD_RELOC_AVR_8_HI
     This is a 8 bit reloc for the AVR that stores bits 8..15 of a
     symbol in .byte hi8(symbol)

 -- : BFD_RELOC_AVR_8_HLO
     This is a 8 bit reloc for the AVR that stores bits 16..23 of a
     symbol in .byte hlo8(symbol)

 -- : BFD_RELOC_AVR_DIFF8
 -- : BFD_RELOC_AVR_DIFF16
 -- : BFD_RELOC_AVR_DIFF32
     AVR relocations to mark the difference of two local symbols.
     These are only needed to support linker relaxation and can be
     ignored when not relaxing.  The field is set to the value of the
     difference assuming no relaxation.  The relocation encodes the
     position of the second symbol so the linker can determine whether
     to adjust the field value.

 -- : BFD_RELOC_AVR_LDS_STS_16
     This is a 7 bit reloc for the AVR that stores SRAM address for
     16bit lds and sts instructions supported only tiny core.

 -- : BFD_RELOC_AVR_PORT6
     This is a 6 bit reloc for the AVR that stores an I/O register
     number for the IN and OUT instructions

 -- : BFD_RELOC_AVR_PORT5
     This is a 5 bit reloc for the AVR that stores an I/O register
     number for the SBIC, SBIS, SBI and CBI instructions

 -- : BFD_RELOC_RISCV_HI20
 -- : BFD_RELOC_RISCV_PCREL_HI20
 -- : BFD_RELOC_RISCV_PCREL_LO12_I
 -- : BFD_RELOC_RISCV_PCREL_LO12_S
 -- : BFD_RELOC_RISCV_LO12_I
 -- : BFD_RELOC_RISCV_LO12_S
 -- : BFD_RELOC_RISCV_GPREL12_I
 -- : BFD_RELOC_RISCV_GPREL12_S
 -- : BFD_RELOC_RISCV_TPREL_HI20
 -- : BFD_RELOC_RISCV_TPREL_LO12_I
 -- : BFD_RELOC_RISCV_TPREL_LO12_S
 -- : BFD_RELOC_RISCV_TPREL_ADD
 -- : BFD_RELOC_RISCV_CALL
 -- : BFD_RELOC_RISCV_CALL_PLT
 -- : BFD_RELOC_RISCV_ADD8
 -- : BFD_RELOC_RISCV_ADD16
 -- : BFD_RELOC_RISCV_ADD32
 -- : BFD_RELOC_RISCV_ADD64
 -- : BFD_RELOC_RISCV_SUB8
 -- : BFD_RELOC_RISCV_SUB16
 -- : BFD_RELOC_RISCV_SUB32
 -- : BFD_RELOC_RISCV_SUB64
 -- : BFD_RELOC_RISCV_GOT_HI20
 -- : BFD_RELOC_RISCV_TLS_GOT_HI20
 -- : BFD_RELOC_RISCV_TLS_GD_HI20
 -- : BFD_RELOC_RISCV_JMP
 -- : BFD_RELOC_RISCV_TLS_DTPMOD32
 -- : BFD_RELOC_RISCV_TLS_DTPREL32
 -- : BFD_RELOC_RISCV_TLS_DTPMOD64
 -- : BFD_RELOC_RISCV_TLS_DTPREL64
 -- : BFD_RELOC_RISCV_TLS_TPREL32
 -- : BFD_RELOC_RISCV_TLS_TPREL64
 -- : BFD_RELOC_RISCV_ALIGN
 -- : BFD_RELOC_RISCV_RVC_BRANCH
 -- : BFD_RELOC_RISCV_RVC_JUMP
 -- : BFD_RELOC_RISCV_RVC_LUI
 -- : BFD_RELOC_RISCV_GPREL_I
 -- : BFD_RELOC_RISCV_GPREL_S
 -- : BFD_RELOC_RISCV_TPREL_I
 -- : BFD_RELOC_RISCV_TPREL_S
 -- : BFD_RELOC_RISCV_RELAX
 -- : BFD_RELOC_RISCV_CFA
 -- : BFD_RELOC_RISCV_SUB6
 -- : BFD_RELOC_RISCV_SET6
 -- : BFD_RELOC_RISCV_SET8
 -- : BFD_RELOC_RISCV_SET16
 -- : BFD_RELOC_RISCV_SET32
 -- : BFD_RELOC_RISCV_32_PCREL
     RISC-V relocations.

 -- : BFD_RELOC_RL78_NEG8
 -- : BFD_RELOC_RL78_NEG16
 -- : BFD_RELOC_RL78_NEG24
 -- : BFD_RELOC_RL78_NEG32
 -- : BFD_RELOC_RL78_16_OP
 -- : BFD_RELOC_RL78_24_OP
 -- : BFD_RELOC_RL78_32_OP
 -- : BFD_RELOC_RL78_8U
 -- : BFD_RELOC_RL78_16U
 -- : BFD_RELOC_RL78_24U
 -- : BFD_RELOC_RL78_DIR3U_PCREL
 -- : BFD_RELOC_RL78_DIFF
 -- : BFD_RELOC_RL78_GPRELB
 -- : BFD_RELOC_RL78_GPRELW
 -- : BFD_RELOC_RL78_GPRELL
 -- : BFD_RELOC_RL78_SYM
 -- : BFD_RELOC_RL78_OP_SUBTRACT
 -- : BFD_RELOC_RL78_OP_NEG
 -- : BFD_RELOC_RL78_OP_AND
 -- : BFD_RELOC_RL78_OP_SHRA
 -- : BFD_RELOC_RL78_ABS8
 -- : BFD_RELOC_RL78_ABS16
 -- : BFD_RELOC_RL78_ABS16_REV
 -- : BFD_RELOC_RL78_ABS32
 -- : BFD_RELOC_RL78_ABS32_REV
 -- : BFD_RELOC_RL78_ABS16U
 -- : BFD_RELOC_RL78_ABS16UW
 -- : BFD_RELOC_RL78_ABS16UL
 -- : BFD_RELOC_RL78_RELAX
 -- : BFD_RELOC_RL78_HI16
 -- : BFD_RELOC_RL78_HI8
 -- : BFD_RELOC_RL78_LO16
 -- : BFD_RELOC_RL78_CODE
 -- : BFD_RELOC_RL78_SADDR
     Renesas RL78 Relocations.

 -- : BFD_RELOC_RX_NEG8
 -- : BFD_RELOC_RX_NEG16
 -- : BFD_RELOC_RX_NEG24
 -- : BFD_RELOC_RX_NEG32
 -- : BFD_RELOC_RX_16_OP
 -- : BFD_RELOC_RX_24_OP
 -- : BFD_RELOC_RX_32_OP
 -- : BFD_RELOC_RX_8U
 -- : BFD_RELOC_RX_16U
 -- : BFD_RELOC_RX_24U
 -- : BFD_RELOC_RX_DIR3U_PCREL
 -- : BFD_RELOC_RX_DIFF
 -- : BFD_RELOC_RX_GPRELB
 -- : BFD_RELOC_RX_GPRELW
 -- : BFD_RELOC_RX_GPRELL
 -- : BFD_RELOC_RX_SYM
 -- : BFD_RELOC_RX_OP_SUBTRACT
 -- : BFD_RELOC_RX_OP_NEG
 -- : BFD_RELOC_RX_ABS8
 -- : BFD_RELOC_RX_ABS16
 -- : BFD_RELOC_RX_ABS16_REV
 -- : BFD_RELOC_RX_ABS32
 -- : BFD_RELOC_RX_ABS32_REV
 -- : BFD_RELOC_RX_ABS16U
 -- : BFD_RELOC_RX_ABS16UW
 -- : BFD_RELOC_RX_ABS16UL
 -- : BFD_RELOC_RX_RELAX
     Renesas RX Relocations.

 -- : BFD_RELOC_390_12
     Direct 12 bit.

 -- : BFD_RELOC_390_GOT12
     12 bit GOT offset.

 -- : BFD_RELOC_390_PLT32
     32 bit PC relative PLT address.

 -- : BFD_RELOC_390_COPY
     Copy symbol at runtime.

 -- : BFD_RELOC_390_GLOB_DAT
     Create GOT entry.

 -- : BFD_RELOC_390_JMP_SLOT
     Create PLT entry.

 -- : BFD_RELOC_390_RELATIVE
     Adjust by program base.

 -- : BFD_RELOC_390_GOTPC
     32 bit PC relative offset to GOT.

 -- : BFD_RELOC_390_GOT16
     16 bit GOT offset.

 -- : BFD_RELOC_390_PC12DBL
     PC relative 12 bit shifted by 1.

 -- : BFD_RELOC_390_PLT12DBL
     12 bit PC rel. PLT shifted by 1.

 -- : BFD_RELOC_390_PC16DBL
     PC relative 16 bit shifted by 1.

 -- : BFD_RELOC_390_PLT16DBL
     16 bit PC rel. PLT shifted by 1.

 -- : BFD_RELOC_390_PC24DBL
     PC relative 24 bit shifted by 1.

 -- : BFD_RELOC_390_PLT24DBL
     24 bit PC rel. PLT shifted by 1.

 -- : BFD_RELOC_390_PC32DBL
     PC relative 32 bit shifted by 1.

 -- : BFD_RELOC_390_PLT32DBL
     32 bit PC rel. PLT shifted by 1.

 -- : BFD_RELOC_390_GOTPCDBL
     32 bit PC rel. GOT shifted by 1.

 -- : BFD_RELOC_390_GOT64
     64 bit GOT offset.

 -- : BFD_RELOC_390_PLT64
     64 bit PC relative PLT address.

 -- : BFD_RELOC_390_GOTENT
     32 bit rel. offset to GOT entry.

 -- : BFD_RELOC_390_GOTOFF64
     64 bit offset to GOT.

 -- : BFD_RELOC_390_GOTPLT12
     12-bit offset to symbol-entry within GOT, with PLT handling.

 -- : BFD_RELOC_390_GOTPLT16
     16-bit offset to symbol-entry within GOT, with PLT handling.

 -- : BFD_RELOC_390_GOTPLT32
     32-bit offset to symbol-entry within GOT, with PLT handling.

 -- : BFD_RELOC_390_GOTPLT64
     64-bit offset to symbol-entry within GOT, with PLT handling.

 -- : BFD_RELOC_390_GOTPLTENT
     32-bit rel. offset to symbol-entry within GOT, with PLT handling.

 -- : BFD_RELOC_390_PLTOFF16
     16-bit rel. offset from the GOT to a PLT entry.

 -- : BFD_RELOC_390_PLTOFF32
     32-bit rel. offset from the GOT to a PLT entry.

 -- : BFD_RELOC_390_PLTOFF64
     64-bit rel. offset from the GOT to a PLT entry.

 -- : BFD_RELOC_390_TLS_LOAD
 -- : BFD_RELOC_390_TLS_GDCALL
 -- : BFD_RELOC_390_TLS_LDCALL
 -- : BFD_RELOC_390_TLS_GD32
 -- : BFD_RELOC_390_TLS_GD64
 -- : BFD_RELOC_390_TLS_GOTIE12
 -- : BFD_RELOC_390_TLS_GOTIE32
 -- : BFD_RELOC_390_TLS_GOTIE64
 -- : BFD_RELOC_390_TLS_LDM32
 -- : BFD_RELOC_390_TLS_LDM64
 -- : BFD_RELOC_390_TLS_IE32
 -- : BFD_RELOC_390_TLS_IE64
 -- : BFD_RELOC_390_TLS_IEENT
 -- : BFD_RELOC_390_TLS_LE32
 -- : BFD_RELOC_390_TLS_LE64
 -- : BFD_RELOC_390_TLS_LDO32
 -- : BFD_RELOC_390_TLS_LDO64
 -- : BFD_RELOC_390_TLS_DTPMOD
 -- : BFD_RELOC_390_TLS_DTPOFF
 -- : BFD_RELOC_390_TLS_TPOFF
     s390 tls relocations.

 -- : BFD_RELOC_390_20
 -- : BFD_RELOC_390_GOT20
 -- : BFD_RELOC_390_GOTPLT20
 -- : BFD_RELOC_390_TLS_GOTIE20
     Long displacement extension.

 -- : BFD_RELOC_390_IRELATIVE
     STT_GNU_IFUNC relocation.

 -- : BFD_RELOC_SCORE_GPREL15
     Score relocations Low 16 bit for load/store

 -- : BFD_RELOC_SCORE_DUMMY2
 -- : BFD_RELOC_SCORE_JMP
     This is a 24-bit reloc with the right 1 bit assumed to be 0

 -- : BFD_RELOC_SCORE_BRANCH
     This is a 19-bit reloc with the right 1 bit assumed to be 0

 -- : BFD_RELOC_SCORE_IMM30
     This is a 32-bit reloc for 48-bit instructions.

 -- : BFD_RELOC_SCORE_IMM32
     This is a 32-bit reloc for 48-bit instructions.

 -- : BFD_RELOC_SCORE16_JMP
     This is a 11-bit reloc with the right 1 bit assumed to be 0

 -- : BFD_RELOC_SCORE16_BRANCH
     This is a 8-bit reloc with the right 1 bit assumed to be 0

 -- : BFD_RELOC_SCORE_BCMP
     This is a 9-bit reloc with the right 1 bit assumed to be 0

 -- : BFD_RELOC_SCORE_GOT15
 -- : BFD_RELOC_SCORE_GOT_LO16
 -- : BFD_RELOC_SCORE_CALL15
 -- : BFD_RELOC_SCORE_DUMMY_HI16
     Undocumented Score relocs

 -- : BFD_RELOC_IP2K_FR9
     Scenix IP2K - 9-bit register number / data address

 -- : BFD_RELOC_IP2K_BANK
     Scenix IP2K - 4-bit register/data bank number

 -- : BFD_RELOC_IP2K_ADDR16CJP
     Scenix IP2K - low 13 bits of instruction word address

 -- : BFD_RELOC_IP2K_PAGE3
     Scenix IP2K - high 3 bits of instruction word address

 -- : BFD_RELOC_IP2K_LO8DATA
 -- : BFD_RELOC_IP2K_HI8DATA
 -- : BFD_RELOC_IP2K_EX8DATA
     Scenix IP2K - ext/low/high 8 bits of data address

 -- : BFD_RELOC_IP2K_LO8INSN
 -- : BFD_RELOC_IP2K_HI8INSN
     Scenix IP2K - low/high 8 bits of instruction word address

 -- : BFD_RELOC_IP2K_PC_SKIP
     Scenix IP2K - even/odd PC modifier to modify snb pcl.0

 -- : BFD_RELOC_IP2K_TEXT
     Scenix IP2K - 16 bit word address in text section.

 -- : BFD_RELOC_IP2K_FR_OFFSET
     Scenix IP2K - 7-bit sp or dp offset

 -- : BFD_RELOC_VPE4KMATH_DATA
 -- : BFD_RELOC_VPE4KMATH_INSN
     Scenix VPE4K coprocessor - data/insn-space addressing

 -- : BFD_RELOC_VTABLE_INHERIT
 -- : BFD_RELOC_VTABLE_ENTRY
     These two relocations are used by the linker to determine which of
     the entries in a C++ virtual function table are actually used.
     When the -gc-sections option is given, the linker will zero out
     the entries that are not used, so that the code for those
     functions need not be included in the output.

     VTABLE_INHERIT is a zero-space relocation used to describe to the
     linker the inheritance tree of a C++ virtual function table.  The
     relocation's symbol should be the parent class' vtable, and the
     relocation should be located at the child vtable.

     VTABLE_ENTRY is a zero-space relocation that describes the use of a
     virtual function table entry.  The reloc's symbol should refer to
     the table of the class mentioned in the code.  Off of that base,
     an offset describes the entry that is being used.  For Rela hosts,
     this offset is stored in the reloc's addend.  For Rel hosts, we
     are forced to put this offset in the reloc's section offset.

 -- : BFD_RELOC_IA64_IMM14
 -- : BFD_RELOC_IA64_IMM22
 -- : BFD_RELOC_IA64_IMM64
 -- : BFD_RELOC_IA64_DIR32MSB
 -- : BFD_RELOC_IA64_DIR32LSB
 -- : BFD_RELOC_IA64_DIR64MSB
 -- : BFD_RELOC_IA64_DIR64LSB
 -- : BFD_RELOC_IA64_GPREL22
 -- : BFD_RELOC_IA64_GPREL64I
 -- : BFD_RELOC_IA64_GPREL32MSB
 -- : BFD_RELOC_IA64_GPREL32LSB
 -- : BFD_RELOC_IA64_GPREL64MSB
 -- : BFD_RELOC_IA64_GPREL64LSB
 -- : BFD_RELOC_IA64_LTOFF22
 -- : BFD_RELOC_IA64_LTOFF64I
 -- : BFD_RELOC_IA64_PLTOFF22
 -- : BFD_RELOC_IA64_PLTOFF64I
 -- : BFD_RELOC_IA64_PLTOFF64MSB
 -- : BFD_RELOC_IA64_PLTOFF64LSB
 -- : BFD_RELOC_IA64_FPTR64I
 -- : BFD_RELOC_IA64_FPTR32MSB
 -- : BFD_RELOC_IA64_FPTR32LSB
 -- : BFD_RELOC_IA64_FPTR64MSB
 -- : BFD_RELOC_IA64_FPTR64LSB
 -- : BFD_RELOC_IA64_PCREL21B
 -- : BFD_RELOC_IA64_PCREL21BI
 -- : BFD_RELOC_IA64_PCREL21M
 -- : BFD_RELOC_IA64_PCREL21F
 -- : BFD_RELOC_IA64_PCREL22
 -- : BFD_RELOC_IA64_PCREL60B
 -- : BFD_RELOC_IA64_PCREL64I
 -- : BFD_RELOC_IA64_PCREL32MSB
 -- : BFD_RELOC_IA64_PCREL32LSB
 -- : BFD_RELOC_IA64_PCREL64MSB
 -- : BFD_RELOC_IA64_PCREL64LSB
 -- : BFD_RELOC_IA64_LTOFF_FPTR22
 -- : BFD_RELOC_IA64_LTOFF_FPTR64I
 -- : BFD_RELOC_IA64_LTOFF_FPTR32MSB
 -- : BFD_RELOC_IA64_LTOFF_FPTR32LSB
 -- : BFD_RELOC_IA64_LTOFF_FPTR64MSB
 -- : BFD_RELOC_IA64_LTOFF_FPTR64LSB
 -- : BFD_RELOC_IA64_SEGREL32MSB
 -- : BFD_RELOC_IA64_SEGREL32LSB
 -- : BFD_RELOC_IA64_SEGREL64MSB
 -- : BFD_RELOC_IA64_SEGREL64LSB
 -- : BFD_RELOC_IA64_SECREL32MSB
 -- : BFD_RELOC_IA64_SECREL32LSB
 -- : BFD_RELOC_IA64_SECREL64MSB
 -- : BFD_RELOC_IA64_SECREL64LSB
 -- : BFD_RELOC_IA64_REL32MSB
 -- : BFD_RELOC_IA64_REL32LSB
 -- : BFD_RELOC_IA64_REL64MSB
 -- : BFD_RELOC_IA64_REL64LSB
 -- : BFD_RELOC_IA64_LTV32MSB
 -- : BFD_RELOC_IA64_LTV32LSB
 -- : BFD_RELOC_IA64_LTV64MSB
 -- : BFD_RELOC_IA64_LTV64LSB
 -- : BFD_RELOC_IA64_IPLTMSB
 -- : BFD_RELOC_IA64_IPLTLSB
 -- : BFD_RELOC_IA64_COPY
 -- : BFD_RELOC_IA64_LTOFF22X
 -- : BFD_RELOC_IA64_LDXMOV
 -- : BFD_RELOC_IA64_TPREL14
 -- : BFD_RELOC_IA64_TPREL22
 -- : BFD_RELOC_IA64_TPREL64I
 -- : BFD_RELOC_IA64_TPREL64MSB
 -- : BFD_RELOC_IA64_TPREL64LSB
 -- : BFD_RELOC_IA64_LTOFF_TPREL22
 -- : BFD_RELOC_IA64_DTPMOD64MSB
 -- : BFD_RELOC_IA64_DTPMOD64LSB
 -- : BFD_RELOC_IA64_LTOFF_DTPMOD22
 -- : BFD_RELOC_IA64_DTPREL14
 -- : BFD_RELOC_IA64_DTPREL22
 -- : BFD_RELOC_IA64_DTPREL64I
 -- : BFD_RELOC_IA64_DTPREL32MSB
 -- : BFD_RELOC_IA64_DTPREL32LSB
 -- : BFD_RELOC_IA64_DTPREL64MSB
 -- : BFD_RELOC_IA64_DTPREL64LSB
 -- : BFD_RELOC_IA64_LTOFF_DTPREL22
     Intel IA64 Relocations.

 -- : BFD_RELOC_M68HC11_HI8
     Motorola 68HC11 reloc.  This is the 8 bit high part of an absolute
     address.

 -- : BFD_RELOC_M68HC11_LO8
     Motorola 68HC11 reloc.  This is the 8 bit low part of an absolute
     address.

 -- : BFD_RELOC_M68HC11_3B
     Motorola 68HC11 reloc.  This is the 3 bit of a value.

 -- : BFD_RELOC_M68HC11_RL_JUMP
     Motorola 68HC11 reloc.  This reloc marks the beginning of a
     jump/call instruction.  It is used for linker relaxation to
     correctly identify beginning of instruction and change some
     branches to use PC-relative addressing mode.

 -- : BFD_RELOC_M68HC11_RL_GROUP
     Motorola 68HC11 reloc.  This reloc marks a group of several
     instructions that gcc generates and for which the linker
     relaxation pass can modify and/or remove some of them.

 -- : BFD_RELOC_M68HC11_LO16
     Motorola 68HC11 reloc.  This is the 16-bit lower part of an
     address.  It is used for 'call' instruction to specify the symbol
     address without any special transformation (due to memory bank
     window).

 -- : BFD_RELOC_M68HC11_PAGE
     Motorola 68HC11 reloc.  This is a 8-bit reloc that specifies the
     page number of an address.  It is used by 'call' instruction to
     specify the page number of the symbol.

 -- : BFD_RELOC_M68HC11_24
     Motorola 68HC11 reloc.  This is a 24-bit reloc that represents the
     address with a 16-bit value and a 8-bit page number.  The symbol
     address is transformed to follow the 16K memory bank of 68HC12
     (seen as mapped in the window).

 -- : BFD_RELOC_M68HC12_5B
     Motorola 68HC12 reloc.  This is the 5 bits of a value.

 -- : BFD_RELOC_XGATE_RL_JUMP
     Freescale XGATE reloc.  This reloc marks the beginning of a
     bra/jal instruction.

 -- : BFD_RELOC_XGATE_RL_GROUP
     Freescale XGATE reloc.  This reloc marks a group of several
     instructions that gcc generates and for which the linker
     relaxation pass can modify and/or remove some of them.

 -- : BFD_RELOC_XGATE_LO16
     Freescale XGATE reloc.  This is the 16-bit lower part of an
     address.  It is used for the '16-bit' instructions.

 -- : BFD_RELOC_XGATE_GPAGE
     Freescale XGATE reloc.

 -- : BFD_RELOC_XGATE_24
     Freescale XGATE reloc.

 -- : BFD_RELOC_XGATE_PCREL_9
     Freescale XGATE reloc.  This is a 9-bit pc-relative reloc.

 -- : BFD_RELOC_XGATE_PCREL_10
     Freescale XGATE reloc.  This is a 10-bit pc-relative reloc.

 -- : BFD_RELOC_XGATE_IMM8_LO
     Freescale XGATE reloc.  This is the 16-bit lower part of an
     address.  It is used for the '16-bit' instructions.

 -- : BFD_RELOC_XGATE_IMM8_HI
     Freescale XGATE reloc.  This is the 16-bit higher part of an
     address.  It is used for the '16-bit' instructions.

 -- : BFD_RELOC_XGATE_IMM3
     Freescale XGATE reloc.  This is a 3-bit pc-relative reloc.

 -- : BFD_RELOC_XGATE_IMM4
     Freescale XGATE reloc.  This is a 4-bit pc-relative reloc.

 -- : BFD_RELOC_XGATE_IMM5
     Freescale XGATE reloc.  This is a 5-bit pc-relative reloc.

 -- : BFD_RELOC_M68HC12_9B
     Motorola 68HC12 reloc.  This is the 9 bits of a value.

 -- : BFD_RELOC_M68HC12_16B
     Motorola 68HC12 reloc.  This is the 16 bits of a value.

 -- : BFD_RELOC_M68HC12_9_PCREL
     Motorola 68HC12/XGATE reloc.  This is a PCREL9 branch.

 -- : BFD_RELOC_M68HC12_10_PCREL
     Motorola 68HC12/XGATE reloc.  This is a PCREL10 branch.

 -- : BFD_RELOC_M68HC12_LO8XG
     Motorola 68HC12/XGATE reloc.  This is the 8 bit low part of an
     absolute address and immediately precedes a matching HI8XG part.

 -- : BFD_RELOC_M68HC12_HI8XG
     Motorola 68HC12/XGATE reloc.  This is the 8 bit high part of an
     absolute address and immediately follows a matching LO8XG part.

 -- : BFD_RELOC_S12Z_15_PCREL
     Freescale S12Z reloc.  This is a 15 bit relative address.  If the
     most significant bits are all zero then it may be truncated to 8
     bits.

 -- : BFD_RELOC_16C_NUM08
 -- : BFD_RELOC_16C_NUM08_C
 -- : BFD_RELOC_16C_NUM16
 -- : BFD_RELOC_16C_NUM16_C
 -- : BFD_RELOC_16C_NUM32
 -- : BFD_RELOC_16C_NUM32_C
 -- : BFD_RELOC_16C_DISP04
 -- : BFD_RELOC_16C_DISP04_C
 -- : BFD_RELOC_16C_DISP08
 -- : BFD_RELOC_16C_DISP08_C
 -- : BFD_RELOC_16C_DISP16
 -- : BFD_RELOC_16C_DISP16_C
 -- : BFD_RELOC_16C_DISP24
 -- : BFD_RELOC_16C_DISP24_C
 -- : BFD_RELOC_16C_DISP24a
 -- : BFD_RELOC_16C_DISP24a_C
 -- : BFD_RELOC_16C_REG04
 -- : BFD_RELOC_16C_REG04_C
 -- : BFD_RELOC_16C_REG04a
 -- : BFD_RELOC_16C_REG04a_C
 -- : BFD_RELOC_16C_REG14
 -- : BFD_RELOC_16C_REG14_C
 -- : BFD_RELOC_16C_REG16
 -- : BFD_RELOC_16C_REG16_C
 -- : BFD_RELOC_16C_REG20
 -- : BFD_RELOC_16C_REG20_C
 -- : BFD_RELOC_16C_ABS20
 -- : BFD_RELOC_16C_ABS20_C
 -- : BFD_RELOC_16C_ABS24
 -- : BFD_RELOC_16C_ABS24_C
 -- : BFD_RELOC_16C_IMM04
 -- : BFD_RELOC_16C_IMM04_C
 -- : BFD_RELOC_16C_IMM16
 -- : BFD_RELOC_16C_IMM16_C
 -- : BFD_RELOC_16C_IMM20
 -- : BFD_RELOC_16C_IMM20_C
 -- : BFD_RELOC_16C_IMM24
 -- : BFD_RELOC_16C_IMM24_C
 -- : BFD_RELOC_16C_IMM32
 -- : BFD_RELOC_16C_IMM32_C
     NS CR16C Relocations.

 -- : BFD_RELOC_CR16_NUM8
 -- : BFD_RELOC_CR16_NUM16
 -- : BFD_RELOC_CR16_NUM32
 -- : BFD_RELOC_CR16_NUM32a
 -- : BFD_RELOC_CR16_REGREL0
 -- : BFD_RELOC_CR16_REGREL4
 -- : BFD_RELOC_CR16_REGREL4a
 -- : BFD_RELOC_CR16_REGREL14
 -- : BFD_RELOC_CR16_REGREL14a
 -- : BFD_RELOC_CR16_REGREL16
 -- : BFD_RELOC_CR16_REGREL20
 -- : BFD_RELOC_CR16_REGREL20a
 -- : BFD_RELOC_CR16_ABS20
 -- : BFD_RELOC_CR16_ABS24
 -- : BFD_RELOC_CR16_IMM4
 -- : BFD_RELOC_CR16_IMM8
 -- : BFD_RELOC_CR16_IMM16
 -- : BFD_RELOC_CR16_IMM20
 -- : BFD_RELOC_CR16_IMM24
 -- : BFD_RELOC_CR16_IMM32
 -- : BFD_RELOC_CR16_IMM32a
 -- : BFD_RELOC_CR16_DISP4
 -- : BFD_RELOC_CR16_DISP8
 -- : BFD_RELOC_CR16_DISP16
 -- : BFD_RELOC_CR16_DISP20
 -- : BFD_RELOC_CR16_DISP24
 -- : BFD_RELOC_CR16_DISP24a
 -- : BFD_RELOC_CR16_SWITCH8
 -- : BFD_RELOC_CR16_SWITCH16
 -- : BFD_RELOC_CR16_SWITCH32
 -- : BFD_RELOC_CR16_GOT_REGREL20
 -- : BFD_RELOC_CR16_GOTC_REGREL20
 -- : BFD_RELOC_CR16_GLOB_DAT
     NS CR16 Relocations.

 -- : BFD_RELOC_CRX_REL4
 -- : BFD_RELOC_CRX_REL8
 -- : BFD_RELOC_CRX_REL8_CMP
 -- : BFD_RELOC_CRX_REL16
 -- : BFD_RELOC_CRX_REL24
 -- : BFD_RELOC_CRX_REL32
 -- : BFD_RELOC_CRX_REGREL12
 -- : BFD_RELOC_CRX_REGREL22
 -- : BFD_RELOC_CRX_REGREL28
 -- : BFD_RELOC_CRX_REGREL32
 -- : BFD_RELOC_CRX_ABS16
 -- : BFD_RELOC_CRX_ABS32
 -- : BFD_RELOC_CRX_NUM8
 -- : BFD_RELOC_CRX_NUM16
 -- : BFD_RELOC_CRX_NUM32
 -- : BFD_RELOC_CRX_IMM16
 -- : BFD_RELOC_CRX_IMM32
 -- : BFD_RELOC_CRX_SWITCH8
 -- : BFD_RELOC_CRX_SWITCH16
 -- : BFD_RELOC_CRX_SWITCH32
     NS CRX Relocations.

 -- : BFD_RELOC_CRIS_BDISP8
 -- : BFD_RELOC_CRIS_UNSIGNED_5
 -- : BFD_RELOC_CRIS_SIGNED_6
 -- : BFD_RELOC_CRIS_UNSIGNED_6
 -- : BFD_RELOC_CRIS_SIGNED_8
 -- : BFD_RELOC_CRIS_UNSIGNED_8
 -- : BFD_RELOC_CRIS_SIGNED_16
 -- : BFD_RELOC_CRIS_UNSIGNED_16
 -- : BFD_RELOC_CRIS_LAPCQ_OFFSET
 -- : BFD_RELOC_CRIS_UNSIGNED_4
     These relocs are only used within the CRIS assembler.  They are not
     (at present) written to any object files.

 -- : BFD_RELOC_CRIS_COPY
 -- : BFD_RELOC_CRIS_GLOB_DAT
 -- : BFD_RELOC_CRIS_JUMP_SLOT
 -- : BFD_RELOC_CRIS_RELATIVE
     Relocs used in ELF shared libraries for CRIS.

 -- : BFD_RELOC_CRIS_32_GOT
     32-bit offset to symbol-entry within GOT.

 -- : BFD_RELOC_CRIS_16_GOT
     16-bit offset to symbol-entry within GOT.

 -- : BFD_RELOC_CRIS_32_GOTPLT
     32-bit offset to symbol-entry within GOT, with PLT handling.

 -- : BFD_RELOC_CRIS_16_GOTPLT
     16-bit offset to symbol-entry within GOT, with PLT handling.

 -- : BFD_RELOC_CRIS_32_GOTREL
     32-bit offset to symbol, relative to GOT.

 -- : BFD_RELOC_CRIS_32_PLT_GOTREL
     32-bit offset to symbol with PLT entry, relative to GOT.

 -- : BFD_RELOC_CRIS_32_PLT_PCREL
     32-bit offset to symbol with PLT entry, relative to this
     relocation.

 -- : BFD_RELOC_CRIS_32_GOT_GD
 -- : BFD_RELOC_CRIS_16_GOT_GD
 -- : BFD_RELOC_CRIS_32_GD
 -- : BFD_RELOC_CRIS_DTP
 -- : BFD_RELOC_CRIS_32_DTPREL
 -- : BFD_RELOC_CRIS_16_DTPREL
 -- : BFD_RELOC_CRIS_32_GOT_TPREL
 -- : BFD_RELOC_CRIS_16_GOT_TPREL
 -- : BFD_RELOC_CRIS_32_TPREL
 -- : BFD_RELOC_CRIS_16_TPREL
 -- : BFD_RELOC_CRIS_DTPMOD
 -- : BFD_RELOC_CRIS_32_IE
     Relocs used in TLS code for CRIS.

 -- : BFD_RELOC_OR1K_REL_26
 -- : BFD_RELOC_OR1K_SLO16
 -- : BFD_RELOC_OR1K_PCREL_PG21
 -- : BFD_RELOC_OR1K_LO13
 -- : BFD_RELOC_OR1K_SLO13
 -- : BFD_RELOC_OR1K_GOTPC_HI16
 -- : BFD_RELOC_OR1K_GOTPC_LO16
 -- : BFD_RELOC_OR1K_GOT16
 -- : BFD_RELOC_OR1K_GOT_PG21
 -- : BFD_RELOC_OR1K_GOT_LO13
 -- : BFD_RELOC_OR1K_PLT26
 -- : BFD_RELOC_OR1K_PLTA26
 -- : BFD_RELOC_OR1K_GOTOFF_SLO16
 -- : BFD_RELOC_OR1K_COPY
 -- : BFD_RELOC_OR1K_GLOB_DAT
 -- : BFD_RELOC_OR1K_JMP_SLOT
 -- : BFD_RELOC_OR1K_RELATIVE
 -- : BFD_RELOC_OR1K_TLS_GD_HI16
 -- : BFD_RELOC_OR1K_TLS_GD_LO16
 -- : BFD_RELOC_OR1K_TLS_GD_PG21
 -- : BFD_RELOC_OR1K_TLS_GD_LO13
 -- : BFD_RELOC_OR1K_TLS_LDM_HI16
 -- : BFD_RELOC_OR1K_TLS_LDM_LO16
 -- : BFD_RELOC_OR1K_TLS_LDM_PG21
 -- : BFD_RELOC_OR1K_TLS_LDM_LO13
 -- : BFD_RELOC_OR1K_TLS_LDO_HI16
 -- : BFD_RELOC_OR1K_TLS_LDO_LO16
 -- : BFD_RELOC_OR1K_TLS_IE_HI16
 -- : BFD_RELOC_OR1K_TLS_IE_AHI16
 -- : BFD_RELOC_OR1K_TLS_IE_LO16
 -- : BFD_RELOC_OR1K_TLS_IE_PG21
 -- : BFD_RELOC_OR1K_TLS_IE_LO13
 -- : BFD_RELOC_OR1K_TLS_LE_HI16
 -- : BFD_RELOC_OR1K_TLS_LE_AHI16
 -- : BFD_RELOC_OR1K_TLS_LE_LO16
 -- : BFD_RELOC_OR1K_TLS_LE_SLO16
 -- : BFD_RELOC_OR1K_TLS_TPOFF
 -- : BFD_RELOC_OR1K_TLS_DTPOFF
 -- : BFD_RELOC_OR1K_TLS_DTPMOD
     OpenRISC 1000 Relocations.

 -- : BFD_RELOC_H8_DIR16A8
 -- : BFD_RELOC_H8_DIR16R8
 -- : BFD_RELOC_H8_DIR24A8
 -- : BFD_RELOC_H8_DIR24R8
 -- : BFD_RELOC_H8_DIR32A16
 -- : BFD_RELOC_H8_DISP32A16
     H8 elf Relocations.

 -- : BFD_RELOC_XSTORMY16_REL_12
 -- : BFD_RELOC_XSTORMY16_12
 -- : BFD_RELOC_XSTORMY16_24
 -- : BFD_RELOC_XSTORMY16_FPTR16
     Sony Xstormy16 Relocations.

 -- : BFD_RELOC_RELC
     Self-describing complex relocations.

 -- : BFD_RELOC_XC16X_PAG
 -- : BFD_RELOC_XC16X_POF
 -- : BFD_RELOC_XC16X_SEG
 -- : BFD_RELOC_XC16X_SOF
     Infineon Relocations.

 -- : BFD_RELOC_VAX_GLOB_DAT
 -- : BFD_RELOC_VAX_JMP_SLOT
 -- : BFD_RELOC_VAX_RELATIVE
     Relocations used by VAX ELF.

 -- : BFD_RELOC_MT_PC16
     Morpho MT - 16 bit immediate relocation.

 -- : BFD_RELOC_MT_HI16
     Morpho MT - Hi 16 bits of an address.

 -- : BFD_RELOC_MT_LO16
     Morpho MT - Low 16 bits of an address.

 -- : BFD_RELOC_MT_GNU_VTINHERIT
     Morpho MT - Used to tell the linker which vtable entries are used.

 -- : BFD_RELOC_MT_GNU_VTENTRY
     Morpho MT - Used to tell the linker which vtable entries are used.

 -- : BFD_RELOC_MT_PCINSN8
     Morpho MT - 8 bit immediate relocation.

 -- : BFD_RELOC_MSP430_10_PCREL
 -- : BFD_RELOC_MSP430_16_PCREL
 -- : BFD_RELOC_MSP430_16
 -- : BFD_RELOC_MSP430_16_PCREL_BYTE
 -- : BFD_RELOC_MSP430_16_BYTE
 -- : BFD_RELOC_MSP430_2X_PCREL
 -- : BFD_RELOC_MSP430_RL_PCREL
 -- : BFD_RELOC_MSP430_ABS8
 -- : BFD_RELOC_MSP430X_PCR20_EXT_SRC
 -- : BFD_RELOC_MSP430X_PCR20_EXT_DST
 -- : BFD_RELOC_MSP430X_PCR20_EXT_ODST
 -- : BFD_RELOC_MSP430X_ABS20_EXT_SRC
 -- : BFD_RELOC_MSP430X_ABS20_EXT_DST
 -- : BFD_RELOC_MSP430X_ABS20_EXT_ODST
 -- : BFD_RELOC_MSP430X_ABS20_ADR_SRC
 -- : BFD_RELOC_MSP430X_ABS20_ADR_DST
 -- : BFD_RELOC_MSP430X_PCR16
 -- : BFD_RELOC_MSP430X_PCR20_CALL
 -- : BFD_RELOC_MSP430X_ABS16
 -- : BFD_RELOC_MSP430_ABS_HI16
 -- : BFD_RELOC_MSP430_PREL31
 -- : BFD_RELOC_MSP430_SYM_DIFF
     msp430 specific relocation codes

 -- : BFD_RELOC_NIOS2_S16
 -- : BFD_RELOC_NIOS2_U16
 -- : BFD_RELOC_NIOS2_CALL26
 -- : BFD_RELOC_NIOS2_IMM5
 -- : BFD_RELOC_NIOS2_CACHE_OPX
 -- : BFD_RELOC_NIOS2_IMM6
 -- : BFD_RELOC_NIOS2_IMM8
 -- : BFD_RELOC_NIOS2_HI16
 -- : BFD_RELOC_NIOS2_LO16
 -- : BFD_RELOC_NIOS2_HIADJ16
 -- : BFD_RELOC_NIOS2_GPREL
 -- : BFD_RELOC_NIOS2_UJMP
 -- : BFD_RELOC_NIOS2_CJMP
 -- : BFD_RELOC_NIOS2_CALLR
 -- : BFD_RELOC_NIOS2_ALIGN
 -- : BFD_RELOC_NIOS2_GOT16
 -- : BFD_RELOC_NIOS2_CALL16
 -- : BFD_RELOC_NIOS2_GOTOFF_LO
 -- : BFD_RELOC_NIOS2_GOTOFF_HA
 -- : BFD_RELOC_NIOS2_PCREL_LO
 -- : BFD_RELOC_NIOS2_PCREL_HA
 -- : BFD_RELOC_NIOS2_TLS_GD16
 -- : BFD_RELOC_NIOS2_TLS_LDM16
 -- : BFD_RELOC_NIOS2_TLS_LDO16
 -- : BFD_RELOC_NIOS2_TLS_IE16
 -- : BFD_RELOC_NIOS2_TLS_LE16
 -- : BFD_RELOC_NIOS2_TLS_DTPMOD
 -- : BFD_RELOC_NIOS2_TLS_DTPREL
 -- : BFD_RELOC_NIOS2_TLS_TPREL
 -- : BFD_RELOC_NIOS2_COPY
 -- : BFD_RELOC_NIOS2_GLOB_DAT
 -- : BFD_RELOC_NIOS2_JUMP_SLOT
 -- : BFD_RELOC_NIOS2_RELATIVE
 -- : BFD_RELOC_NIOS2_GOTOFF
 -- : BFD_RELOC_NIOS2_CALL26_NOAT
 -- : BFD_RELOC_NIOS2_GOT_LO
 -- : BFD_RELOC_NIOS2_GOT_HA
 -- : BFD_RELOC_NIOS2_CALL_LO
 -- : BFD_RELOC_NIOS2_CALL_HA
 -- : BFD_RELOC_NIOS2_R2_S12
 -- : BFD_RELOC_NIOS2_R2_I10_1_PCREL
 -- : BFD_RELOC_NIOS2_R2_T1I7_1_PCREL
 -- : BFD_RELOC_NIOS2_R2_T1I7_2
 -- : BFD_RELOC_NIOS2_R2_T2I4
 -- : BFD_RELOC_NIOS2_R2_T2I4_1
 -- : BFD_RELOC_NIOS2_R2_T2I4_2
 -- : BFD_RELOC_NIOS2_R2_X1I7_2
 -- : BFD_RELOC_NIOS2_R2_X2L5
 -- : BFD_RELOC_NIOS2_R2_F1I5_2
 -- : BFD_RELOC_NIOS2_R2_L5I4X1
 -- : BFD_RELOC_NIOS2_R2_T1X1I6
 -- : BFD_RELOC_NIOS2_R2_T1X1I6_2
     Relocations used by the Altera Nios II core.

 -- : BFD_RELOC_PRU_U16
     PRU LDI 16-bit unsigned data-memory relocation.

 -- : BFD_RELOC_PRU_U16_PMEMIMM
     PRU LDI 16-bit unsigned instruction-memory relocation.

 -- : BFD_RELOC_PRU_LDI32
     PRU relocation for two consecutive LDI load instructions that load
     a 32 bit value into a register. If the higher bits are all zero,
     then the second instruction may be relaxed.

 -- : BFD_RELOC_PRU_S10_PCREL
     PRU QBBx 10-bit signed PC-relative relocation.

 -- : BFD_RELOC_PRU_U8_PCREL
     PRU 8-bit unsigned relocation used for the LOOP instruction.

 -- : BFD_RELOC_PRU_32_PMEM
 -- : BFD_RELOC_PRU_16_PMEM
     PRU Program Memory relocations.  Used to convert from byte
     addressing to 32-bit word addressing.

 -- : BFD_RELOC_PRU_GNU_DIFF8
 -- : BFD_RELOC_PRU_GNU_DIFF16
 -- : BFD_RELOC_PRU_GNU_DIFF32
 -- : BFD_RELOC_PRU_GNU_DIFF16_PMEM
 -- : BFD_RELOC_PRU_GNU_DIFF32_PMEM
     PRU relocations to mark the difference of two local symbols.
     These are only needed to support linker relaxation and can be
     ignored when not relaxing.  The field is set to the value of the
     difference assuming no relaxation.  The relocation encodes the
     position of the second symbol so the linker can determine whether
     to adjust the field value. The PMEM variants encode the word
     difference, instead of byte difference between symbols.

 -- : BFD_RELOC_IQ2000_OFFSET_16
 -- : BFD_RELOC_IQ2000_OFFSET_21
 -- : BFD_RELOC_IQ2000_UHI16
     IQ2000 Relocations.

 -- : BFD_RELOC_XTENSA_RTLD
     Special Xtensa relocation used only by PLT entries in ELF shared
     objects to indicate that the runtime linker should set the value
     to one of its own internal functions or data structures.

 -- : BFD_RELOC_XTENSA_GLOB_DAT
 -- : BFD_RELOC_XTENSA_JMP_SLOT
 -- : BFD_RELOC_XTENSA_RELATIVE
     Xtensa relocations for ELF shared objects.

 -- : BFD_RELOC_XTENSA_PLT
     Xtensa relocation used in ELF object files for symbols that may
     require PLT entries.  Otherwise, this is just a generic 32-bit
     relocation.

 -- : BFD_RELOC_XTENSA_DIFF8
 -- : BFD_RELOC_XTENSA_DIFF16
 -- : BFD_RELOC_XTENSA_DIFF32
     Xtensa relocations to mark the difference of two local symbols.
     These are only needed to support linker relaxation and can be
     ignored when not relaxing.  The field is set to the value of the
     difference assuming no relaxation.  The relocation encodes the
     position of the first symbol so the linker can determine whether
     to adjust the field value.

 -- : BFD_RELOC_XTENSA_SLOT0_OP
 -- : BFD_RELOC_XTENSA_SLOT1_OP
 -- : BFD_RELOC_XTENSA_SLOT2_OP
 -- : BFD_RELOC_XTENSA_SLOT3_OP
 -- : BFD_RELOC_XTENSA_SLOT4_OP
 -- : BFD_RELOC_XTENSA_SLOT5_OP
 -- : BFD_RELOC_XTENSA_SLOT6_OP
 -- : BFD_RELOC_XTENSA_SLOT7_OP
 -- : BFD_RELOC_XTENSA_SLOT8_OP
 -- : BFD_RELOC_XTENSA_SLOT9_OP
 -- : BFD_RELOC_XTENSA_SLOT10_OP
 -- : BFD_RELOC_XTENSA_SLOT11_OP
 -- : BFD_RELOC_XTENSA_SLOT12_OP
 -- : BFD_RELOC_XTENSA_SLOT13_OP
 -- : BFD_RELOC_XTENSA_SLOT14_OP
     Generic Xtensa relocations for instruction operands.  Only the slot
     number is encoded in the relocation.  The relocation applies to the
     last PC-relative immediate operand, or if there are no PC-relative
     immediates, to the last immediate operand.

 -- : BFD_RELOC_XTENSA_SLOT0_ALT
 -- : BFD_RELOC_XTENSA_SLOT1_ALT
 -- : BFD_RELOC_XTENSA_SLOT2_ALT
 -- : BFD_RELOC_XTENSA_SLOT3_ALT
 -- : BFD_RELOC_XTENSA_SLOT4_ALT
 -- : BFD_RELOC_XTENSA_SLOT5_ALT
 -- : BFD_RELOC_XTENSA_SLOT6_ALT
 -- : BFD_RELOC_XTENSA_SLOT7_ALT
 -- : BFD_RELOC_XTENSA_SLOT8_ALT
 -- : BFD_RELOC_XTENSA_SLOT9_ALT
 -- : BFD_RELOC_XTENSA_SLOT10_ALT
 -- : BFD_RELOC_XTENSA_SLOT11_ALT
 -- : BFD_RELOC_XTENSA_SLOT12_ALT
 -- : BFD_RELOC_XTENSA_SLOT13_ALT
 -- : BFD_RELOC_XTENSA_SLOT14_ALT
     Alternate Xtensa relocations.  Only the slot is encoded in the
     relocation.  The meaning of these relocations is opcode-specific.

 -- : BFD_RELOC_XTENSA_OP0
 -- : BFD_RELOC_XTENSA_OP1
 -- : BFD_RELOC_XTENSA_OP2
     Xtensa relocations for backward compatibility.  These have all been
     replaced by BFD_RELOC_XTENSA_SLOT0_OP.

 -- : BFD_RELOC_XTENSA_ASM_EXPAND
     Xtensa relocation to mark that the assembler expanded the
     instructions from an original target.  The expansion size is
     encoded in the reloc size.

 -- : BFD_RELOC_XTENSA_ASM_SIMPLIFY
     Xtensa relocation to mark that the linker should simplify
     assembler-expanded instructions.  This is commonly used internally
     by the linker after analysis of a BFD_RELOC_XTENSA_ASM_EXPAND.

 -- : BFD_RELOC_XTENSA_TLSDESC_FN
 -- : BFD_RELOC_XTENSA_TLSDESC_ARG
 -- : BFD_RELOC_XTENSA_TLS_DTPOFF
 -- : BFD_RELOC_XTENSA_TLS_TPOFF
 -- : BFD_RELOC_XTENSA_TLS_FUNC
 -- : BFD_RELOC_XTENSA_TLS_ARG
 -- : BFD_RELOC_XTENSA_TLS_CALL
     Xtensa TLS relocations.

 -- : BFD_RELOC_Z80_DISP8
     8 bit signed offset in (ix+d) or (iy+d).

 -- : BFD_RELOC_Z8K_DISP7
     DJNZ offset.

 -- : BFD_RELOC_Z8K_CALLR
     CALR offset.

 -- : BFD_RELOC_Z8K_IMM4L
     4 bit value.

 -- : BFD_RELOC_LM32_CALL
 -- : BFD_RELOC_LM32_BRANCH
 -- : BFD_RELOC_LM32_16_GOT
 -- : BFD_RELOC_LM32_GOTOFF_HI16
 -- : BFD_RELOC_LM32_GOTOFF_LO16
 -- : BFD_RELOC_LM32_COPY
 -- : BFD_RELOC_LM32_GLOB_DAT
 -- : BFD_RELOC_LM32_JMP_SLOT
 -- : BFD_RELOC_LM32_RELATIVE
     Lattice Mico32 relocations.

 -- : BFD_RELOC_MACH_O_SECTDIFF
     Difference between two section addreses.  Must be followed by a
     BFD_RELOC_MACH_O_PAIR.

 -- : BFD_RELOC_MACH_O_LOCAL_SECTDIFF
     Like BFD_RELOC_MACH_O_SECTDIFF but with a local symbol.

 -- : BFD_RELOC_MACH_O_PAIR
     Pair of relocation.  Contains the first symbol.

 -- : BFD_RELOC_MACH_O_SUBTRACTOR32
     Symbol will be substracted.  Must be followed by a BFD_RELOC_32.

 -- : BFD_RELOC_MACH_O_SUBTRACTOR64
     Symbol will be substracted.  Must be followed by a BFD_RELOC_64.

 -- : BFD_RELOC_MACH_O_X86_64_BRANCH32
 -- : BFD_RELOC_MACH_O_X86_64_BRANCH8
     PCREL relocations.  They are marked as branch to create PLT entry
     if required.

 -- : BFD_RELOC_MACH_O_X86_64_GOT
     Used when referencing a GOT entry.

 -- : BFD_RELOC_MACH_O_X86_64_GOT_LOAD
     Used when loading a GOT entry with movq.  It is specially marked
     so that the linker could optimize the movq to a leaq if possible.

 -- : BFD_RELOC_MACH_O_X86_64_PCREL32_1
     Same as BFD_RELOC_32_PCREL but with an implicit -1 addend.

 -- : BFD_RELOC_MACH_O_X86_64_PCREL32_2
     Same as BFD_RELOC_32_PCREL but with an implicit -2 addend.

 -- : BFD_RELOC_MACH_O_X86_64_PCREL32_4
     Same as BFD_RELOC_32_PCREL but with an implicit -4 addend.

 -- : BFD_RELOC_MACH_O_X86_64_TLV
     Used when referencing a TLV entry.

 -- : BFD_RELOC_MACH_O_ARM64_ADDEND
     Addend for PAGE or PAGEOFF.

 -- : BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGE21
     Relative offset to page of GOT slot.

 -- : BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGEOFF12
     Relative offset within page of GOT slot.

 -- : BFD_RELOC_MACH_O_ARM64_POINTER_TO_GOT
     Address of a GOT entry.

 -- : BFD_RELOC_MICROBLAZE_32_LO
     This is a 32 bit reloc for the microblaze that stores the low 16
     bits of a value

 -- : BFD_RELOC_MICROBLAZE_32_LO_PCREL
     This is a 32 bit pc-relative reloc for the microblaze that stores
     the low 16 bits of a value

 -- : BFD_RELOC_MICROBLAZE_32_ROSDA
     This is a 32 bit reloc for the microblaze that stores a value
     relative to the read-only small data area anchor

 -- : BFD_RELOC_MICROBLAZE_32_RWSDA
     This is a 32 bit reloc for the microblaze that stores a value
     relative to the read-write small data area anchor

 -- : BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM
     This is a 32 bit reloc for the microblaze to handle expressions of
     the form "Symbol Op Symbol"

 -- : BFD_RELOC_MICROBLAZE_64_NONE
     This is a 64 bit reloc that stores the 32 bit pc relative value in
     two words (with an imm instruction).  No relocation is done here -
     only used for relaxing

 -- : BFD_RELOC_MICROBLAZE_64_GOTPC
     This is a 64 bit reloc that stores the 32 bit pc relative value in
     two words (with an imm instruction).  The relocation is
     PC-relative GOT offset

 -- : BFD_RELOC_MICROBLAZE_64_GOT
     This is a 64 bit reloc that stores the 32 bit pc relative value in
     two words (with an imm instruction).  The relocation is GOT offset

 -- : BFD_RELOC_MICROBLAZE_64_PLT
     This is a 64 bit reloc that stores the 32 bit pc relative value in
     two words (with an imm instruction).  The relocation is
     PC-relative offset into PLT

 -- : BFD_RELOC_MICROBLAZE_64_GOTOFF
     This is a 64 bit reloc that stores the 32 bit GOT relative value
     in two words (with an imm instruction).  The relocation is
     relative offset from _GLOBAL_OFFSET_TABLE_

 -- : BFD_RELOC_MICROBLAZE_32_GOTOFF
     This is a 32 bit reloc that stores the 32 bit GOT relative value
     in a word.  The relocation is relative offset from

 -- : BFD_RELOC_MICROBLAZE_COPY
     This is used to tell the dynamic linker to copy the value out of
     the dynamic object into the runtime process image.

 -- : BFD_RELOC_MICROBLAZE_64_TLS
     Unused Reloc

 -- : BFD_RELOC_MICROBLAZE_64_TLSGD
     This is a 64 bit reloc that stores the 32 bit GOT relative value
     of the GOT TLS GD info entry in two words (with an imm
     instruction). The relocation is GOT offset.

 -- : BFD_RELOC_MICROBLAZE_64_TLSLD
     This is a 64 bit reloc that stores the 32 bit GOT relative value
     of the GOT TLS LD info entry in two words (with an imm
     instruction). The relocation is GOT offset.

 -- : BFD_RELOC_MICROBLAZE_32_TLSDTPMOD
     This is a 32 bit reloc that stores the Module ID to GOT(n).

 -- : BFD_RELOC_MICROBLAZE_32_TLSDTPREL
     This is a 32 bit reloc that stores TLS offset to GOT(n+1).

 -- : BFD_RELOC_MICROBLAZE_64_TLSDTPREL
     This is a 32 bit reloc for storing TLS offset to two words (uses
     imm instruction)

 -- : BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL
     This is a 64 bit reloc that stores 32-bit thread pointer relative
     offset to two words (uses imm instruction).

 -- : BFD_RELOC_MICROBLAZE_64_TLSTPREL
     This is a 64 bit reloc that stores 32-bit thread pointer relative
     offset to two words (uses imm instruction).

 -- : BFD_RELOC_MICROBLAZE_64_TEXTPCREL
     This is a 64 bit reloc that stores the 32 bit pc relative value in
     two words (with an imm instruction).  The relocation is
     PC-relative offset from start of TEXT.

 -- : BFD_RELOC_MICROBLAZE_64_TEXTREL
     This is a 64 bit reloc that stores the 32 bit offset value in two
     words (with an imm instruction).  The relocation is relative
     offset from start of TEXT.

 -- : BFD_RELOC_AARCH64_RELOC_START
     AArch64 pseudo relocation code to mark the start of the AArch64
     relocation enumerators.  N.B. the order of the enumerators is
     important as several tables in the AArch64 bfd backend are indexed
     by these enumerators; make sure they are all synced.

 -- : BFD_RELOC_AARCH64_NULL
     Deprecated AArch64 null relocation code.

 -- : BFD_RELOC_AARCH64_NONE
     AArch64 null relocation code.

 -- : BFD_RELOC_AARCH64_64
 -- : BFD_RELOC_AARCH64_32
 -- : BFD_RELOC_AARCH64_16
     Basic absolute relocations of N bits.  These are equivalent to
     BFD_RELOC_N and they were added to assist the indexing of the howto
     table.

 -- : BFD_RELOC_AARCH64_64_PCREL
 -- : BFD_RELOC_AARCH64_32_PCREL
 -- : BFD_RELOC_AARCH64_16_PCREL
     PC-relative relocations.  These are equivalent to BFD_RELOC_N_PCREL
     and they were added to assist the indexing of the howto table.

 -- : BFD_RELOC_AARCH64_MOVW_G0
     AArch64 MOV[NZK] instruction with most significant bits 0 to 15 of
     an unsigned address/value.

 -- : BFD_RELOC_AARCH64_MOVW_G0_NC
     AArch64 MOV[NZK] instruction with less significant bits 0 to 15 of
     an address/value.  No overflow checking.

 -- : BFD_RELOC_AARCH64_MOVW_G1
     AArch64 MOV[NZK] instruction with most significant bits 16 to 31
     of an unsigned address/value.

 -- : BFD_RELOC_AARCH64_MOVW_G1_NC
     AArch64 MOV[NZK] instruction with less significant bits 16 to 31
     of an address/value.  No overflow checking.

 -- : BFD_RELOC_AARCH64_MOVW_G2
     AArch64 MOV[NZK] instruction with most significant bits 32 to 47
     of an unsigned address/value.

 -- : BFD_RELOC_AARCH64_MOVW_G2_NC
     AArch64 MOV[NZK] instruction with less significant bits 32 to 47
     of an address/value.  No overflow checking.

 -- : BFD_RELOC_AARCH64_MOVW_G3
     AArch64 MOV[NZK] instruction with most signficant bits 48 to 64 of
     a signed or unsigned address/value.

 -- : BFD_RELOC_AARCH64_MOVW_G0_S
     AArch64 MOV[NZ] instruction with most significant bits 0 to 15 of
     a signed value.  Changes instruction to MOVZ or MOVN depending on
     the value's sign.

 -- : BFD_RELOC_AARCH64_MOVW_G1_S
     AArch64 MOV[NZ] instruction with most significant bits 16 to 31 of
     a signed value.  Changes instruction to MOVZ or MOVN depending on
     the value's sign.

 -- : BFD_RELOC_AARCH64_MOVW_G2_S
     AArch64 MOV[NZ] instruction with most significant bits 32 to 47 of
     a signed value.  Changes instruction to MOVZ or MOVN depending on
     the value's sign.

 -- : BFD_RELOC_AARCH64_MOVW_PREL_G0
     AArch64 MOV[NZ] instruction with most significant bits 0 to 15 of
     a signed value.  Changes instruction to MOVZ or MOVN depending on
     the value's sign.

 -- : BFD_RELOC_AARCH64_MOVW_PREL_G0_NC
     AArch64 MOV[NZ] instruction with most significant bits 0 to 15 of
     a signed value.  Changes instruction to MOVZ or MOVN depending on
     the value's sign.

 -- : BFD_RELOC_AARCH64_MOVW_PREL_G1
     AArch64 MOVK instruction with most significant bits 16 to 31 of a
     signed value.

 -- : BFD_RELOC_AARCH64_MOVW_PREL_G1_NC
     AArch64 MOVK instruction with most significant bits 16 to 31 of a
     signed value.

 -- : BFD_RELOC_AARCH64_MOVW_PREL_G2
     AArch64 MOVK instruction with most significant bits 32 to 47 of a
     signed value.

 -- : BFD_RELOC_AARCH64_MOVW_PREL_G2_NC
     AArch64 MOVK instruction with most significant bits 32 to 47 of a
     signed value.

 -- : BFD_RELOC_AARCH64_MOVW_PREL_G3
     AArch64 MOVK instruction with most significant bits 47 to 63 of a
     signed value.

 -- : BFD_RELOC_AARCH64_LD_LO19_PCREL
     AArch64 Load Literal instruction, holding a 19 bit pc-relative word
     offset.  The lowest two bits must be zero and are not stored in the
     instruction, giving a 21 bit signed byte offset.

 -- : BFD_RELOC_AARCH64_ADR_LO21_PCREL
     AArch64 ADR instruction, holding a simple 21 bit pc-relative byte
     offset.

 -- : BFD_RELOC_AARCH64_ADR_HI21_PCREL
     AArch64 ADRP instruction, with bits 12 to 32 of a pc-relative page
     offset, giving a 4KB aligned page base address.

 -- : BFD_RELOC_AARCH64_ADR_HI21_NC_PCREL
     AArch64 ADRP instruction, with bits 12 to 32 of a pc-relative page
     offset, giving a 4KB aligned page base address, but with no
     overflow checking.

 -- : BFD_RELOC_AARCH64_ADD_LO12
     AArch64 ADD immediate instruction, holding bits 0 to 11 of the
     address.  Used in conjunction with
     BFD_RELOC_AARCH64_ADR_HI21_PCREL.

 -- : BFD_RELOC_AARCH64_LDST8_LO12
     AArch64 8-bit load/store instruction, holding bits 0 to 11 of the
     address.  Used in conjunction with
     BFD_RELOC_AARCH64_ADR_HI21_PCREL.

 -- : BFD_RELOC_AARCH64_TSTBR14
     AArch64 14 bit pc-relative test bit and branch.  The lowest two
     bits must be zero and are not stored in the instruction, giving a
     16 bit signed byte offset.

 -- : BFD_RELOC_AARCH64_BRANCH19
     AArch64 19 bit pc-relative conditional branch and compare & branch.
     The lowest two bits must be zero and are not stored in the
     instruction, giving a 21 bit signed byte offset.

 -- : BFD_RELOC_AARCH64_JUMP26
     AArch64 26 bit pc-relative unconditional branch.  The lowest two
     bits must be zero and are not stored in the instruction, giving a
     28 bit signed byte offset.

 -- : BFD_RELOC_AARCH64_CALL26
     AArch64 26 bit pc-relative unconditional branch and link.  The
     lowest two bits must be zero and are not stored in the instruction,
     giving a 28 bit signed byte offset.

 -- : BFD_RELOC_AARCH64_LDST16_LO12
     AArch64 16-bit load/store instruction, holding bits 0 to 11 of the
     address.  Used in conjunction with
     BFD_RELOC_AARCH64_ADR_HI21_PCREL.

 -- : BFD_RELOC_AARCH64_LDST32_LO12
     AArch64 32-bit load/store instruction, holding bits 0 to 11 of the
     address.  Used in conjunction with
     BFD_RELOC_AARCH64_ADR_HI21_PCREL.

 -- : BFD_RELOC_AARCH64_LDST64_LO12
     AArch64 64-bit load/store instruction, holding bits 0 to 11 of the
     address.  Used in conjunction with
     BFD_RELOC_AARCH64_ADR_HI21_PCREL.

 -- : BFD_RELOC_AARCH64_LDST128_LO12
     AArch64 128-bit load/store instruction, holding bits 0 to 11 of the
     address.  Used in conjunction with
     BFD_RELOC_AARCH64_ADR_HI21_PCREL.

 -- : BFD_RELOC_AARCH64_GOT_LD_PREL19
     AArch64 Load Literal instruction, holding a 19 bit PC relative word
     offset of the global offset table entry for a symbol.  The lowest
     two bits must be zero and are not stored in the instruction,
     giving a 21 bit signed byte offset.  This relocation type requires
     signed overflow checking.

 -- : BFD_RELOC_AARCH64_ADR_GOT_PAGE
     Get to the page base of the global offset table entry for a symbol
     as part of an ADRP instruction using a 21 bit PC relative
     value.Used in conjunction with BFD_RELOC_AARCH64_LD64_GOT_LO12_NC.

 -- : BFD_RELOC_AARCH64_LD64_GOT_LO12_NC
     Unsigned 12 bit byte offset for 64 bit load/store from the page of
     the GOT entry for this symbol.  Used in conjunction with
     BFD_RELOC_AARCH64_ADR_GOT_PAGE.  Valid in LP64 ABI only.

 -- : BFD_RELOC_AARCH64_LD32_GOT_LO12_NC
     Unsigned 12 bit byte offset for 32 bit load/store from the page of
     the GOT entry for this symbol.  Used in conjunction with
     BFD_RELOC_AARCH64_ADR_GOT_PAGE.  Valid in ILP32 ABI only.

 -- : BFD_RELOC_AARCH64_MOVW_GOTOFF_G0_NC
     Unsigned 16 bit byte offset for 64 bit load/store from the GOT
     entry for this symbol.  Valid in LP64 ABI only.

 -- : BFD_RELOC_AARCH64_MOVW_GOTOFF_G1
     Unsigned 16 bit byte higher offset for 64 bit load/store from the
     GOT entry for this symbol.  Valid in LP64 ABI only.

 -- : BFD_RELOC_AARCH64_LD64_GOTOFF_LO15
     Unsigned 15 bit byte offset for 64 bit load/store from the page of
     the GOT entry for this symbol.  Valid in LP64 ABI only.

 -- : BFD_RELOC_AARCH64_LD32_GOTPAGE_LO14
     Scaled 14 bit byte offset to the page base of the global offset
     table.

 -- : BFD_RELOC_AARCH64_LD64_GOTPAGE_LO15
     Scaled 15 bit byte offset to the page base of the global offset
     table.

 -- : BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21
     Get to the page base of the global offset table entry for a symbols
     tls_index structure as part of an adrp instruction using a 21 bit
     PC relative value.  Used in conjunction with
     BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC.

 -- : BFD_RELOC_AARCH64_TLSGD_ADR_PREL21
     AArch64 TLS General Dynamic

 -- : BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC
     Unsigned 12 bit byte offset to global offset table entry for a
     symbols tls_index structure.  Used in conjunction with
     BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21.

 -- : BFD_RELOC_AARCH64_TLSGD_MOVW_G0_NC
     AArch64 TLS General Dynamic relocation.

 -- : BFD_RELOC_AARCH64_TLSGD_MOVW_G1
     AArch64 TLS General Dynamic relocation.

 -- : BFD_RELOC_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21
     AArch64 TLS INITIAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC
     AArch64 TLS INITIAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSIE_LD32_GOTTPREL_LO12_NC
     AArch64 TLS INITIAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_PREL19
     AArch64 TLS INITIAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC
     AArch64 TLS INITIAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G1
     AArch64 TLS INITIAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_HI12
     bit[23:12] of byte offset to module TLS base address.

 -- : BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12
     Unsigned 12 bit byte offset to module TLS base address.

 -- : BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12_NC
     No overflow check version of
     BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12.

 -- : BFD_RELOC_AARCH64_TLSLD_ADD_LO12_NC
     Unsigned 12 bit byte offset to global offset table entry for a
     symbols tls_index structure.  Used in conjunction with
     BFD_RELOC_AARCH64_TLSLD_ADR_PAGE21.

 -- : BFD_RELOC_AARCH64_TLSLD_ADR_PAGE21
     GOT entry page address for AArch64 TLS Local Dynamic, used with
     ADRP instruction.

 -- : BFD_RELOC_AARCH64_TLSLD_ADR_PREL21
     GOT entry address for AArch64 TLS Local Dynamic, used with ADR
     instruction.

 -- : BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12
     bit[11:1] of byte offset to module TLS base address, encoded in
     ldst instructions.

 -- : BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC
     Similar as BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12, but no
     overflow check.

 -- : BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12
     bit[11:2] of byte offset to module TLS base address, encoded in
     ldst instructions.

 -- : BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC
     Similar as BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12, but no
     overflow check.

 -- : BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12
     bit[11:3] of byte offset to module TLS base address, encoded in
     ldst instructions.

 -- : BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC
     Similar as BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12, but no
     overflow check.

 -- : BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12
     bit[11:0] of byte offset to module TLS base address, encoded in
     ldst instructions.

 -- : BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC
     Similar as BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12, but no
     overflow check.

 -- : BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0
     bit[15:0] of byte offset to module TLS base address.

 -- : BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0_NC
     No overflow check version of BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0

 -- : BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1
     bit[31:16] of byte offset to module TLS base address.

 -- : BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1_NC
     No overflow check version of BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1

 -- : BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G2
     bit[47:32] of byte offset to module TLS base address.

 -- : BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2
     AArch64 TLS LOCAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1
     AArch64 TLS LOCAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1_NC
     AArch64 TLS LOCAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0
     AArch64 TLS LOCAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0_NC
     AArch64 TLS LOCAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_HI12
     AArch64 TLS LOCAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12
     AArch64 TLS LOCAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12_NC
     AArch64 TLS LOCAL EXEC relocation.

 -- : BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12
     bit[11:1] of byte offset to module TLS base address, encoded in
     ldst instructions.

 -- : BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12_NC
     Similar as BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12, but no
     overflow check.

 -- : BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12
     bit[11:2] of byte offset to module TLS base address, encoded in
     ldst instructions.

 -- : BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12_NC
     Similar as BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12, but no
     overflow check.

 -- : BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12
     bit[11:3] of byte offset to module TLS base address, encoded in
     ldst instructions.

 -- : BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12_NC
     Similar as BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12, but no
     overflow check.

 -- : BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12
     bit[11:0] of byte offset to module TLS base address, encoded in
     ldst instructions.

 -- : BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12_NC
     Similar as BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12, but no
     overflow check.

 -- : BFD_RELOC_AARCH64_TLSDESC_LD_PREL19
     AArch64 TLS DESC relocation.

 -- : BFD_RELOC_AARCH64_TLSDESC_ADR_PREL21
     AArch64 TLS DESC relocation.

 -- : BFD_RELOC_AARCH64_TLSDESC_ADR_PAGE21
     AArch64 TLS DESC relocation.

 -- : BFD_RELOC_AARCH64_TLSDESC_LD64_LO12
     AArch64 TLS DESC relocation.

 -- : BFD_RELOC_AARCH64_TLSDESC_LD32_LO12_NC
     AArch64 TLS DESC relocation.

 -- : BFD_RELOC_AARCH64_TLSDESC_ADD_LO12
     AArch64 TLS DESC relocation.

 -- : BFD_RELOC_AARCH64_TLSDESC_OFF_G1
     AArch64 TLS DESC relocation.

 -- : BFD_RELOC_AARCH64_TLSDESC_OFF_G0_NC
     AArch64 TLS DESC relocation.

 -- : BFD_RELOC_AARCH64_TLSDESC_LDR
     AArch64 TLS DESC relocation.

 -- : BFD_RELOC_AARCH64_TLSDESC_ADD
     AArch64 TLS DESC relocation.

 -- : BFD_RELOC_AARCH64_TLSDESC_CALL
     AArch64 TLS DESC relocation.

 -- : BFD_RELOC_AARCH64_COPY
     AArch64 TLS relocation.

 -- : BFD_RELOC_AARCH64_GLOB_DAT
     AArch64 TLS relocation.

 -- : BFD_RELOC_AARCH64_JUMP_SLOT
     AArch64 TLS relocation.

 -- : BFD_RELOC_AARCH64_RELATIVE
     AArch64 TLS relocation.

 -- : BFD_RELOC_AARCH64_TLS_DTPMOD
     AArch64 TLS relocation.

 -- : BFD_RELOC_AARCH64_TLS_DTPREL
     AArch64 TLS relocation.

 -- : BFD_RELOC_AARCH64_TLS_TPREL
     AArch64 TLS relocation.

 -- : BFD_RELOC_AARCH64_TLSDESC
     AArch64 TLS relocation.

 -- : BFD_RELOC_AARCH64_IRELATIVE
     AArch64 support for STT_GNU_IFUNC.

 -- : BFD_RELOC_AARCH64_RELOC_END
     AArch64 pseudo relocation code to mark the end of the AArch64
     relocation enumerators that have direct mapping to ELF reloc codes.
     There are a few more enumerators after this one; those are mainly
     used by the AArch64 assembler for the internal fixup or to select
     one of the above enumerators.

 -- : BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP
     AArch64 pseudo relocation code to be used internally by the AArch64
     assembler and not (currently) written to any object files.

 -- : BFD_RELOC_AARCH64_LDST_LO12
     AArch64 unspecified load/store instruction, holding bits 0 to 11
     of the address.  Used in conjunction with
     BFD_RELOC_AARCH64_ADR_HI21_PCREL.

 -- : BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12
     AArch64 pseudo relocation code for TLS local dynamic mode.  It's
     to be used internally by the AArch64 assembler and not (currently)
     written to any object files.

 -- : BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12_NC
     Similar as BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12, but no
     overflow check.

 -- : BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12
     AArch64 pseudo relocation code for TLS local exec mode.  It's to be
     used internally by the AArch64 assembler and not (currently)
     written to any object files.

 -- : BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12_NC
     Similar as BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12, but no
     overflow check.

 -- : BFD_RELOC_AARCH64_LD_GOT_LO12_NC
     AArch64 pseudo relocation code to be used internally by the AArch64
     assembler and not (currently) written to any object files.

 -- : BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_LO12_NC
     AArch64 pseudo relocation code to be used internally by the AArch64
     assembler and not (currently) written to any object files.

 -- : BFD_RELOC_AARCH64_TLSDESC_LD_LO12_NC
     AArch64 pseudo relocation code to be used internally by the AArch64
     assembler and not (currently) written to any object files.

 -- : BFD_RELOC_TILEPRO_COPY
 -- : BFD_RELOC_TILEPRO_GLOB_DAT
 -- : BFD_RELOC_TILEPRO_JMP_SLOT
 -- : BFD_RELOC_TILEPRO_RELATIVE
 -- : BFD_RELOC_TILEPRO_BROFF_X1
 -- : BFD_RELOC_TILEPRO_JOFFLONG_X1
 -- : BFD_RELOC_TILEPRO_JOFFLONG_X1_PLT
 -- : BFD_RELOC_TILEPRO_IMM8_X0
 -- : BFD_RELOC_TILEPRO_IMM8_Y0
 -- : BFD_RELOC_TILEPRO_IMM8_X1
 -- : BFD_RELOC_TILEPRO_IMM8_Y1
 -- : BFD_RELOC_TILEPRO_DEST_IMM8_X1
 -- : BFD_RELOC_TILEPRO_MT_IMM15_X1
 -- : BFD_RELOC_TILEPRO_MF_IMM15_X1
 -- : BFD_RELOC_TILEPRO_IMM16_X0
 -- : BFD_RELOC_TILEPRO_IMM16_X1
 -- : BFD_RELOC_TILEPRO_IMM16_X0_LO
 -- : BFD_RELOC_TILEPRO_IMM16_X1_LO
 -- : BFD_RELOC_TILEPRO_IMM16_X0_HI
 -- : BFD_RELOC_TILEPRO_IMM16_X1_HI
 -- : BFD_RELOC_TILEPRO_IMM16_X0_HA
 -- : BFD_RELOC_TILEPRO_IMM16_X1_HA
 -- : BFD_RELOC_TILEPRO_IMM16_X0_PCREL
 -- : BFD_RELOC_TILEPRO_IMM16_X1_PCREL
 -- : BFD_RELOC_TILEPRO_IMM16_X0_LO_PCREL
 -- : BFD_RELOC_TILEPRO_IMM16_X1_LO_PCREL
 -- : BFD_RELOC_TILEPRO_IMM16_X0_HI_PCREL
 -- : BFD_RELOC_TILEPRO_IMM16_X1_HI_PCREL
 -- : BFD_RELOC_TILEPRO_IMM16_X0_HA_PCREL
 -- : BFD_RELOC_TILEPRO_IMM16_X1_HA_PCREL
 -- : BFD_RELOC_TILEPRO_IMM16_X0_GOT
 -- : BFD_RELOC_TILEPRO_IMM16_X1_GOT
 -- : BFD_RELOC_TILEPRO_IMM16_X0_GOT_LO
 -- : BFD_RELOC_TILEPRO_IMM16_X1_GOT_LO
 -- : BFD_RELOC_TILEPRO_IMM16_X0_GOT_HI
 -- : BFD_RELOC_TILEPRO_IMM16_X1_GOT_HI
 -- : BFD_RELOC_TILEPRO_IMM16_X0_GOT_HA
 -- : BFD_RELOC_TILEPRO_IMM16_X1_GOT_HA
 -- : BFD_RELOC_TILEPRO_MMSTART_X0
 -- : BFD_RELOC_TILEPRO_MMEND_X0
 -- : BFD_RELOC_TILEPRO_MMSTART_X1
 -- : BFD_RELOC_TILEPRO_MMEND_X1
 -- : BFD_RELOC_TILEPRO_SHAMT_X0
 -- : BFD_RELOC_TILEPRO_SHAMT_X1
 -- : BFD_RELOC_TILEPRO_SHAMT_Y0
 -- : BFD_RELOC_TILEPRO_SHAMT_Y1
 -- : BFD_RELOC_TILEPRO_TLS_GD_CALL
 -- : BFD_RELOC_TILEPRO_IMM8_X0_TLS_GD_ADD
 -- : BFD_RELOC_TILEPRO_IMM8_X1_TLS_GD_ADD
 -- : BFD_RELOC_TILEPRO_IMM8_Y0_TLS_GD_ADD
 -- : BFD_RELOC_TILEPRO_IMM8_Y1_TLS_GD_ADD
 -- : BFD_RELOC_TILEPRO_TLS_IE_LOAD
 -- : BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD
 -- : BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD
 -- : BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_LO
 -- : BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_LO
 -- : BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HI
 -- : BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HI
 -- : BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HA
 -- : BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HA
 -- : BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE
 -- : BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE
 -- : BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_LO
 -- : BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_LO
 -- : BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HI
 -- : BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HI
 -- : BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HA
 -- : BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HA
 -- : BFD_RELOC_TILEPRO_TLS_DTPMOD32
 -- : BFD_RELOC_TILEPRO_TLS_DTPOFF32
 -- : BFD_RELOC_TILEPRO_TLS_TPOFF32
 -- : BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE
 -- : BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE
 -- : BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_LO
 -- : BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_LO
 -- : BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HI
 -- : BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HI
 -- : BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HA
 -- : BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HA
     Tilera TILEPro Relocations.

 -- : BFD_RELOC_TILEGX_HW0
 -- : BFD_RELOC_TILEGX_HW1
 -- : BFD_RELOC_TILEGX_HW2
 -- : BFD_RELOC_TILEGX_HW3
 -- : BFD_RELOC_TILEGX_HW0_LAST
 -- : BFD_RELOC_TILEGX_HW1_LAST
 -- : BFD_RELOC_TILEGX_HW2_LAST
 -- : BFD_RELOC_TILEGX_COPY
 -- : BFD_RELOC_TILEGX_GLOB_DAT
 -- : BFD_RELOC_TILEGX_JMP_SLOT
 -- : BFD_RELOC_TILEGX_RELATIVE
 -- : BFD_RELOC_TILEGX_BROFF_X1
 -- : BFD_RELOC_TILEGX_JUMPOFF_X1
 -- : BFD_RELOC_TILEGX_JUMPOFF_X1_PLT
 -- : BFD_RELOC_TILEGX_IMM8_X0
 -- : BFD_RELOC_TILEGX_IMM8_Y0
 -- : BFD_RELOC_TILEGX_IMM8_X1
 -- : BFD_RELOC_TILEGX_IMM8_Y1
 -- : BFD_RELOC_TILEGX_DEST_IMM8_X1
 -- : BFD_RELOC_TILEGX_MT_IMM14_X1
 -- : BFD_RELOC_TILEGX_MF_IMM14_X1
 -- : BFD_RELOC_TILEGX_MMSTART_X0
 -- : BFD_RELOC_TILEGX_MMEND_X0
 -- : BFD_RELOC_TILEGX_SHAMT_X0
 -- : BFD_RELOC_TILEGX_SHAMT_X1
 -- : BFD_RELOC_TILEGX_SHAMT_Y0
 -- : BFD_RELOC_TILEGX_SHAMT_Y1
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW1
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW1
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW2
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW2
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW3
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW3
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW1_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW1_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW2_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW2_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW3_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW3_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0_GOT
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0_GOT
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW1_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW1_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW2_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW2_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_GOT
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_GOT
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_GOT
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_GOT
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW3_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW3_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_GD
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_GD
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_LE
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_LE
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_LE
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_LE
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_LE
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_LE
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_GD
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_GD
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_GD
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_GD
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_IE
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_IE
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_IE
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_IE
 -- : BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_IE
 -- : BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_IE
 -- : BFD_RELOC_TILEGX_TLS_DTPMOD64
 -- : BFD_RELOC_TILEGX_TLS_DTPOFF64
 -- : BFD_RELOC_TILEGX_TLS_TPOFF64
 -- : BFD_RELOC_TILEGX_TLS_DTPMOD32
 -- : BFD_RELOC_TILEGX_TLS_DTPOFF32
 -- : BFD_RELOC_TILEGX_TLS_TPOFF32
 -- : BFD_RELOC_TILEGX_TLS_GD_CALL
 -- : BFD_RELOC_TILEGX_IMM8_X0_TLS_GD_ADD
 -- : BFD_RELOC_TILEGX_IMM8_X1_TLS_GD_ADD
 -- : BFD_RELOC_TILEGX_IMM8_Y0_TLS_GD_ADD
 -- : BFD_RELOC_TILEGX_IMM8_Y1_TLS_GD_ADD
 -- : BFD_RELOC_TILEGX_TLS_IE_LOAD
 -- : BFD_RELOC_TILEGX_IMM8_X0_TLS_ADD
 -- : BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD
 -- : BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD
 -- : BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD
     Tilera TILE-Gx Relocations.

 -- : BFD_RELOC_EPIPHANY_SIMM8
     Adapteva EPIPHANY - 8 bit signed pc-relative displacement

 -- : BFD_RELOC_EPIPHANY_SIMM24
     Adapteva EPIPHANY - 24 bit signed pc-relative displacement

 -- : BFD_RELOC_EPIPHANY_HIGH
     Adapteva EPIPHANY - 16 most-significant bits of absolute address

 -- : BFD_RELOC_EPIPHANY_LOW
     Adapteva EPIPHANY - 16 least-significant bits of absolute address

 -- : BFD_RELOC_EPIPHANY_SIMM11
     Adapteva EPIPHANY - 11 bit signed number - add/sub immediate

 -- : BFD_RELOC_EPIPHANY_IMM11
     Adapteva EPIPHANY - 11 bit sign-magnitude number (ld/st
     displacement)

 -- : BFD_RELOC_EPIPHANY_IMM8
     Adapteva EPIPHANY - 8 bit immediate for 16 bit mov instruction.

 -- : BFD_RELOC_VISIUM_HI16
 -- : BFD_RELOC_VISIUM_LO16
 -- : BFD_RELOC_VISIUM_IM16
 -- : BFD_RELOC_VISIUM_REL16
 -- : BFD_RELOC_VISIUM_HI16_PCREL
 -- : BFD_RELOC_VISIUM_LO16_PCREL
 -- : BFD_RELOC_VISIUM_IM16_PCREL
     Visium Relocations.

 -- : BFD_RELOC_WASM32_LEB128
 -- : BFD_RELOC_WASM32_LEB128_GOT
 -- : BFD_RELOC_WASM32_LEB128_GOT_CODE
 -- : BFD_RELOC_WASM32_LEB128_PLT
 -- : BFD_RELOC_WASM32_PLT_INDEX
 -- : BFD_RELOC_WASM32_ABS32_CODE
 -- : BFD_RELOC_WASM32_COPY
 -- : BFD_RELOC_WASM32_CODE_POINTER
 -- : BFD_RELOC_WASM32_INDEX
 -- : BFD_RELOC_WASM32_PLT_SIG
     WebAssembly relocations.

 -- : BFD_RELOC_CKCORE_NONE
 -- : BFD_RELOC_CKCORE_ADDR32
 -- : BFD_RELOC_CKCORE_PCREL_IMM8BY4
 -- : BFD_RELOC_CKCORE_PCREL_IMM11BY2
 -- : BFD_RELOC_CKCORE_PCREL_IMM4BY2
 -- : BFD_RELOC_CKCORE_PCREL32
 -- : BFD_RELOC_CKCORE_PCREL_JSR_IMM11BY2
 -- : BFD_RELOC_CKCORE_GNU_VTINHERIT
 -- : BFD_RELOC_CKCORE_GNU_VTENTRY
 -- : BFD_RELOC_CKCORE_RELATIVE
 -- : BFD_RELOC_CKCORE_COPY
 -- : BFD_RELOC_CKCORE_GLOB_DAT
 -- : BFD_RELOC_CKCORE_JUMP_SLOT
 -- : BFD_RELOC_CKCORE_GOTOFF
 -- : BFD_RELOC_CKCORE_GOTPC
 -- : BFD_RELOC_CKCORE_GOT32
 -- : BFD_RELOC_CKCORE_PLT32
 -- : BFD_RELOC_CKCORE_ADDRGOT
 -- : BFD_RELOC_CKCORE_ADDRPLT
 -- : BFD_RELOC_CKCORE_PCREL_IMM26BY2
 -- : BFD_RELOC_CKCORE_PCREL_IMM16BY2
 -- : BFD_RELOC_CKCORE_PCREL_IMM16BY4
 -- : BFD_RELOC_CKCORE_PCREL_IMM10BY2
 -- : BFD_RELOC_CKCORE_PCREL_IMM10BY4
 -- : BFD_RELOC_CKCORE_ADDR_HI16
 -- : BFD_RELOC_CKCORE_ADDR_LO16
 -- : BFD_RELOC_CKCORE_GOTPC_HI16
 -- : BFD_RELOC_CKCORE_GOTPC_LO16
 -- : BFD_RELOC_CKCORE_GOTOFF_HI16
 -- : BFD_RELOC_CKCORE_GOTOFF_LO16
 -- : BFD_RELOC_CKCORE_GOT12
 -- : BFD_RELOC_CKCORE_GOT_HI16
 -- : BFD_RELOC_CKCORE_GOT_LO16
 -- : BFD_RELOC_CKCORE_PLT12
 -- : BFD_RELOC_CKCORE_PLT_HI16
 -- : BFD_RELOC_CKCORE_PLT_LO16
 -- : BFD_RELOC_CKCORE_ADDRGOT_HI16
 -- : BFD_RELOC_CKCORE_ADDRGOT_LO16
 -- : BFD_RELOC_CKCORE_ADDRPLT_HI16
 -- : BFD_RELOC_CKCORE_ADDRPLT_LO16
 -- : BFD_RELOC_CKCORE_PCREL_JSR_IMM26BY2
 -- : BFD_RELOC_CKCORE_TOFFSET_LO16
 -- : BFD_RELOC_CKCORE_DOFFSET_LO16
 -- : BFD_RELOC_CKCORE_PCREL_IMM18BY2
 -- : BFD_RELOC_CKCORE_DOFFSET_IMM18
 -- : BFD_RELOC_CKCORE_DOFFSET_IMM18BY2
 -- : BFD_RELOC_CKCORE_DOFFSET_IMM18BY4
 -- : BFD_RELOC_CKCORE_GOTOFF_IMM18
 -- : BFD_RELOC_CKCORE_GOT_IMM18BY4
 -- : BFD_RELOC_CKCORE_PLT_IMM18BY4
 -- : BFD_RELOC_CKCORE_PCREL_IMM7BY4
 -- : BFD_RELOC_CKCORE_TLS_LE32
 -- : BFD_RELOC_CKCORE_TLS_IE32
 -- : BFD_RELOC_CKCORE_TLS_GD32
 -- : BFD_RELOC_CKCORE_TLS_LDM32
 -- : BFD_RELOC_CKCORE_TLS_LDO32
 -- : BFD_RELOC_CKCORE_TLS_DTPMOD32
 -- : BFD_RELOC_CKCORE_TLS_DTPOFF32
 -- : BFD_RELOC_CKCORE_TLS_TPOFF32
 -- : BFD_RELOC_CKCORE_PCREL_FLRW_IMM8BY4
 -- : BFD_RELOC_CKCORE_NOJSRI
 -- : BFD_RELOC_CKCORE_CALLGRAPH
 -- : BFD_RELOC_CKCORE_IRELATIVE
 -- : BFD_RELOC_CKCORE_PCREL_BLOOP_IMM4BY4
 -- : BFD_RELOC_CKCORE_PCREL_BLOOP_IMM12BY4
     C-SKY relocations.


     typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
   
2.10.2.2 `bfd_reloc_type_lookup'
................................

*Synopsis*
     reloc_howto_type *bfd_reloc_type_lookup
        (bfd *abfd, bfd_reloc_code_real_type code);
     reloc_howto_type *bfd_reloc_name_lookup
        (bfd *abfd, const char *reloc_name);
   *Description*
Return a pointer to a howto structure which, when invoked, will perform
the relocation CODE on data from the architecture noted.

2.10.2.3 `bfd_default_reloc_type_lookup'
........................................

*Synopsis*
     reloc_howto_type *bfd_default_reloc_type_lookup
        (bfd *abfd, bfd_reloc_code_real_type  code);
   *Description*
Provides a default relocation lookup routine for any architecture.

2.10.2.4 `bfd_get_reloc_code_name'
..................................

*Synopsis*
     const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);
   *Description*
Provides a printable name for the supplied relocation code.  Useful
mainly for printing error messages.

2.10.2.5 `bfd_generic_relax_section'
....................................

*Synopsis*
     bfd_boolean bfd_generic_relax_section
        (bfd *abfd,
         asection *section,
         struct bfd_link_info *,
         bfd_boolean *);
   *Description*
Provides default handling for relaxing for back ends which don't do
relaxing.

2.10.2.6 `bfd_generic_gc_sections'
..................................

*Synopsis*
     bfd_boolean bfd_generic_gc_sections
        (bfd *, struct bfd_link_info *);
   *Description*
Provides default handling for relaxing for back ends which don't do
section gc - i.e., does nothing.

2.10.2.7 `bfd_generic_lookup_section_flags'
...........................................

*Synopsis*
     bfd_boolean bfd_generic_lookup_section_flags
        (struct bfd_link_info *, struct flag_info *, asection *);
   *Description*
Provides default handling for section flags lookup - i.e., does nothing.
Returns FALSE if the section should be omitted, otherwise TRUE.

2.10.2.8 `bfd_generic_merge_sections'
.....................................

*Synopsis*
     bfd_boolean bfd_generic_merge_sections
        (bfd *, struct bfd_link_info *);
   *Description*
Provides default handling for SEC_MERGE section merging for back ends
which don't have SEC_MERGE support - i.e., does nothing.

2.10.2.9 `bfd_generic_get_relocated_section_contents'
.....................................................

*Synopsis*
     bfd_byte *bfd_generic_get_relocated_section_contents
        (bfd *abfd,
         struct bfd_link_info *link_info,
         struct bfd_link_order *link_order,
         bfd_byte *data,
         bfd_boolean relocatable,
         asymbol **symbols);
   *Description*
Provides default handling of relocation effort for back ends which
can't be bothered to do it efficiently.

2.10.2.10 `_bfd_generic_set_reloc'
..................................

*Synopsis*
     void _bfd_generic_set_reloc
        (bfd *abfd,
         sec_ptr section,
         arelent **relptr,
         unsigned int count);
   *Description*
Installs a new set of internal relocations in SECTION.

2.10.2.11 `_bfd_unrecognized_reloc'
...................................

*Synopsis*
     bfd_boolean _bfd_unrecognized_reloc
        (bfd * abfd,
         sec_ptr section,
         unsigned int r_type);
   *Description*
Reports an unrecognized reloc.  Written as a function in order to
reduce code duplication.  Returns FALSE so that it can be called from a
return statement.


File: bfd.info,  Node: Core Files,  Next: Targets,  Prev: Relocations,  Up: BFD front end

2.11 Core files
===============

2.11.1 Core file functions
--------------------------

*Description*
These are functions pertaining to core files.

2.11.1.1 `bfd_core_file_failing_command'
........................................

*Synopsis*
     const char *bfd_core_file_failing_command (bfd *abfd);
   *Description*
Return a read-only string explaining which program was running when it
failed and produced the core file ABFD.

2.11.1.2 `bfd_core_file_failing_signal'
.......................................

*Synopsis*
     int bfd_core_file_failing_signal (bfd *abfd);
   *Description*
Returns the signal number which caused the core dump which generated
the file the BFD ABFD is attached to.

2.11.1.3 `bfd_core_file_pid'
............................

*Synopsis*
     int bfd_core_file_pid (bfd *abfd);
   *Description*
Returns the PID of the process the core dump the BFD ABFD is attached
to was generated from.

2.11.1.4 `core_file_matches_executable_p'
.........................................

*Synopsis*
     bfd_boolean core_file_matches_executable_p
        (bfd *core_bfd, bfd *exec_bfd);
   *Description*
Return `TRUE' if the core file attached to CORE_BFD was generated by a
run of the executable file attached to EXEC_BFD, `FALSE' otherwise.

2.11.1.5 `generic_core_file_matches_executable_p'
.................................................

*Synopsis*
     bfd_boolean generic_core_file_matches_executable_p
        (bfd *core_bfd, bfd *exec_bfd);
   *Description*
Return TRUE if the core file attached to CORE_BFD was generated by a
run of the executable file attached to EXEC_BFD.  The match is based on
executable basenames only.

   Note: When not able to determine the core file failing command or
the executable name, we still return TRUE even though we're not sure
that core file and executable match.  This is to avoid generating a
false warning in situations where we really don't know whether they
match or not.


File: bfd.info,  Node: Targets,  Next: Architectures,  Prev: Core Files,  Up: BFD front end

2.12 Targets
============

*Description*
Each port of BFD to a different machine requires the creation of a
target back end. All the back end provides to the root part of BFD is a
structure containing pointers to functions which perform certain low
level operations on files. BFD translates the applications's requests
through a pointer into calls to the back end routines.

   When a file is opened with `bfd_openr', its format and target are
unknown. BFD uses various mechanisms to determine how to interpret the
file. The operations performed are:

   * Create a BFD by calling the internal routine `_bfd_new_bfd', then
     call `bfd_find_target' with the target string supplied to
     `bfd_openr' and the new BFD pointer.

   * If a null target string was provided to `bfd_find_target', look up
     the environment variable `GNUTARGET' and use that as the target
     string.

   * If the target string is still `NULL', or the target string is
     `default', then use the first item in the target vector as the
     target type, and set `target_defaulted' in the BFD to cause
     `bfd_check_format' to loop through all the targets.  *Note
     bfd_target::.  *Note Formats::.

   * Otherwise, inspect the elements in the target vector one by one,
     until a match on target name is found. When found, use it.

   * Otherwise return the error `bfd_error_invalid_target' to
     `bfd_openr'.

   * `bfd_openr' attempts to open the file using `bfd_open_file', and
     returns the BFD.
   Once the BFD has been opened and the target selected, the file
format may be determined. This is done by calling `bfd_check_format' on
the BFD with a suggested format.  If `target_defaulted' has been set,
each possible target type is tried to see if it recognizes the
specified format.  `bfd_check_format' returns `TRUE' when the caller
guesses right.

* Menu:

* bfd_target::


File: bfd.info,  Node: bfd_target,  Prev: Targets,  Up: Targets

2.12.1 bfd_target
-----------------

*Description*
This structure contains everything that BFD knows about a target. It
includes things like its byte order, name, and which routines to call
to do various operations.

   Every BFD points to a target structure with its `xvec' member.

   The macros below are used to dispatch to functions through the
`bfd_target' vector. They are used in a number of macros further down
in `bfd.h', and are also used when calling various routines by hand
inside the BFD implementation.  The ARGLIST argument must be
parenthesized; it contains all the arguments to the called function.

   They make the documentation (more) unpleasant to read, so if someone
wants to fix this and not break the above, please do.
     #define BFD_SEND(bfd, message, arglist) \
       ((*((bfd)->xvec->message)) arglist)

     #ifdef DEBUG_BFD_SEND
     #undef BFD_SEND
     #define BFD_SEND(bfd, message, arglist) \
       (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
         ((*((bfd)->xvec->message)) arglist) : \
         (bfd_assert (__FILE__,__LINE__), NULL))
     #endif
   For operations which index on the BFD format:
     #define BFD_SEND_FMT(bfd, message, arglist) \
       (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)

     #ifdef DEBUG_BFD_SEND
     #undef BFD_SEND_FMT
     #define BFD_SEND_FMT(bfd, message, arglist) \
       (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
        (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
        (bfd_assert (__FILE__,__LINE__), NULL))
     #endif
   This is the structure which defines the type of BFD this is.  The
`xvec' member of the struct `bfd' itself points here.  Each module that
implements access to a different target under BFD, defines one of these.

   FIXME, these names should be rationalised with the names of the
entry points which call them. Too bad we can't have one macro to define
them both!
     enum bfd_flavour
     {
       /* N.B. Update bfd_flavour_name if you change this.  */
       bfd_target_unknown_flavour,
       bfd_target_aout_flavour,
       bfd_target_coff_flavour,
       bfd_target_ecoff_flavour,
       bfd_target_xcoff_flavour,
       bfd_target_elf_flavour,
       bfd_target_tekhex_flavour,
       bfd_target_srec_flavour,
       bfd_target_verilog_flavour,
       bfd_target_ihex_flavour,
       bfd_target_som_flavour,
       bfd_target_os9k_flavour,
       bfd_target_versados_flavour,
       bfd_target_msdos_flavour,
       bfd_target_ovax_flavour,
       bfd_target_evax_flavour,
       bfd_target_mmo_flavour,
       bfd_target_mach_o_flavour,
       bfd_target_pef_flavour,
       bfd_target_pef_xlib_flavour,
       bfd_target_sym_flavour
     };

     enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };

     /* Forward declaration.  */
     typedef struct bfd_link_info _bfd_link_info;

     /* Forward declaration.  */
     typedef struct flag_info flag_info;

     typedef struct bfd_target
     {
       /* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  */
       char *name;

      /* The "flavour" of a back end is a general indication about
         the contents of a file.  */
       enum bfd_flavour flavour;

       /* The order of bytes within the data area of a file.  */
       enum bfd_endian byteorder;

      /* The order of bytes within the header parts of a file.  */
       enum bfd_endian header_byteorder;

       /* A mask of all the flags which an executable may have set -
          from the set `BFD_NO_FLAGS', `HAS_RELOC', ...`D_PAGED'.  */
       flagword object_flags;

      /* A mask of all the flags which a section may have set - from
         the set `SEC_NO_FLAGS', `SEC_ALLOC', ...`SET_NEVER_LOAD'.  */
       flagword section_flags;

      /* The character normally found at the front of a symbol.
         (if any), perhaps `_'.  */
       char symbol_leading_char;

      /* The pad character for file names within an archive header.  */
       char ar_pad_char;

       /* The maximum number of characters in an archive header.  */
       unsigned char ar_max_namelen;

       /* How well this target matches, used to select between various
          possible targets when more than one target matches.  */
       unsigned char match_priority;

       /* Entries for byte swapping for data. These are different from the
          other entry points, since they don't take a BFD as the first argument.
          Certain other handlers could do the same.  */
       bfd_uint64_t   (*bfd_getx64) (const void *);
       bfd_int64_t    (*bfd_getx_signed_64) (const void *);
       void           (*bfd_putx64) (bfd_uint64_t, void *);
       bfd_vma        (*bfd_getx32) (const void *);
       bfd_signed_vma (*bfd_getx_signed_32) (const void *);
       void           (*bfd_putx32) (bfd_vma, void *);
       bfd_vma        (*bfd_getx16) (const void *);
       bfd_signed_vma (*bfd_getx_signed_16) (const void *);
       void           (*bfd_putx16) (bfd_vma, void *);

       /* Byte swapping for the headers.  */
       bfd_uint64_t   (*bfd_h_getx64) (const void *);
       bfd_int64_t    (*bfd_h_getx_signed_64) (const void *);
       void           (*bfd_h_putx64) (bfd_uint64_t, void *);
       bfd_vma        (*bfd_h_getx32) (const void *);
       bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
       void           (*bfd_h_putx32) (bfd_vma, void *);
       bfd_vma        (*bfd_h_getx16) (const void *);
       bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
       void           (*bfd_h_putx16) (bfd_vma, void *);

       /* Format dependent routines: these are vectors of entry points
          within the target vector structure, one for each format to check.  */

       /* Check the format of a file being read.  Return a `bfd_target *' or zero.  */
       const struct bfd_target *
                   (*_bfd_check_format[bfd_type_end]) (bfd *);

       /* Set the format of a file being written.  */
       bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);

       /* Write cached information into a file being written, at `bfd_close'.  */
       bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
   The general target vector.  These vectors are initialized using the
BFD_JUMP_TABLE macros.

       /* Generic entry points.  */
     #define BFD_JUMP_TABLE_GENERIC(NAME) \
       NAME##_close_and_cleanup, \
       NAME##_bfd_free_cached_info, \
       NAME##_new_section_hook, \
       NAME##_get_section_contents, \
       NAME##_get_section_contents_in_window

       /* Called when the BFD is being closed to do any necessary cleanup.  */
       bfd_boolean (*_close_and_cleanup) (bfd *);
       /* Ask the BFD to free all cached information.  */
       bfd_boolean (*_bfd_free_cached_info) (bfd *);
       /* Called when a new section is created.  */
       bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);
       /* Read the contents of a section.  */
       bfd_boolean (*_bfd_get_section_contents) (bfd *, sec_ptr, void *, file_ptr,
                                                 bfd_size_type);
       bfd_boolean (*_bfd_get_section_contents_in_window) (bfd *, sec_ptr,
                                                           bfd_window *, file_ptr,
                                                           bfd_size_type);

       /* Entry points to copy private data.  */
     #define BFD_JUMP_TABLE_COPY(NAME) \
       NAME##_bfd_copy_private_bfd_data, \
       NAME##_bfd_merge_private_bfd_data, \
       _bfd_generic_init_private_section_data, \
       NAME##_bfd_copy_private_section_data, \
       NAME##_bfd_copy_private_symbol_data, \
       NAME##_bfd_copy_private_header_data, \
       NAME##_bfd_set_private_flags, \
       NAME##_bfd_print_private_bfd_data

       /* Called to copy BFD general private data from one object file
          to another.  */
       bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);
       /* Called to merge BFD general private data from one object file
          to a common output file when linking.  */
       bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, struct bfd_link_info *);
       /* Called to initialize BFD private section data from one object file
          to another.  */
     #define bfd_init_private_section_data(ibfd, isec, obfd, osec, link_info) \
            BFD_SEND (obfd, _bfd_init_private_section_data, \
                      (ibfd, isec, obfd, osec, link_info))
       bfd_boolean (*_bfd_init_private_section_data) (bfd *, sec_ptr, bfd *,
                                                      sec_ptr,
                                                      struct bfd_link_info *);
       /* Called to copy BFD private section data from one object file
          to another.  */
       bfd_boolean (*_bfd_copy_private_section_data) (bfd *, sec_ptr, bfd *,
                                                      sec_ptr);
       /* Called to copy BFD private symbol data from one symbol
          to another.  */
       bfd_boolean (*_bfd_copy_private_symbol_data) (bfd *, asymbol *, bfd *,
                                                     asymbol *);
       /* Called to copy BFD private header data from one object file
          to another.  */
       bfd_boolean (*_bfd_copy_private_header_data) (bfd *, bfd *);
       /* Called to set private backend flags.  */
       bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);

       /* Called to print private BFD data.  */
       bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);

       /* Core file entry points.  */
     #define BFD_JUMP_TABLE_CORE(NAME) \
       NAME##_core_file_failing_command, \
       NAME##_core_file_failing_signal, \
       NAME##_core_file_matches_executable_p, \
       NAME##_core_file_pid

       char *      (*_core_file_failing_command) (bfd *);
       int         (*_core_file_failing_signal) (bfd *);
       bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
       int         (*_core_file_pid) (bfd *);

       /* Archive entry points.  */
     #define BFD_JUMP_TABLE_ARCHIVE(NAME) \
       NAME##_slurp_armap, \
       NAME##_slurp_extended_name_table, \
       NAME##_construct_extended_name_table, \
       NAME##_truncate_arname, \
       NAME##_write_armap, \
       NAME##_read_ar_hdr, \
       NAME##_write_ar_hdr, \
       NAME##_openr_next_archived_file, \
       NAME##_get_elt_at_index, \
       NAME##_generic_stat_arch_elt, \
       NAME##_update_armap_timestamp

       bfd_boolean (*_bfd_slurp_armap) (bfd *);
       bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
       bfd_boolean (*_bfd_construct_extended_name_table) (bfd *, char **,
                                                          bfd_size_type *,
                                                          const char **);
       void        (*_bfd_truncate_arname) (bfd *, const char *, char *);
       bfd_boolean (*write_armap) (bfd *, unsigned int, struct orl *,
                                   unsigned int, int);
       void *      (*_bfd_read_ar_hdr_fn) (bfd *);
       bfd_boolean (*_bfd_write_ar_hdr_fn) (bfd *, bfd *);
       bfd *       (*openr_next_archived_file) (bfd *, bfd *);
     #define bfd_get_elt_at_index(b,i) \
            BFD_SEND (b, _bfd_get_elt_at_index, (b,i))
       bfd *       (*_bfd_get_elt_at_index) (bfd *, symindex);
       int         (*_bfd_stat_arch_elt) (bfd *, struct stat *);
       bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);

       /* Entry points used for symbols.  */
     #define BFD_JUMP_TABLE_SYMBOLS(NAME) \
       NAME##_get_symtab_upper_bound, \
       NAME##_canonicalize_symtab, \
       NAME##_make_empty_symbol, \
       NAME##_print_symbol, \
       NAME##_get_symbol_info, \
       NAME##_get_symbol_version_string, \
       NAME##_bfd_is_local_label_name, \
       NAME##_bfd_is_target_special_symbol, \
       NAME##_get_lineno, \
       NAME##_find_nearest_line, \
       NAME##_find_line, \
       NAME##_find_inliner_info, \
       NAME##_bfd_make_debug_symbol, \
       NAME##_read_minisymbols, \
       NAME##_minisymbol_to_symbol

       long        (*_bfd_get_symtab_upper_bound) (bfd *);
       long        (*_bfd_canonicalize_symtab) (bfd *, struct bfd_symbol **);
       struct bfd_symbol *
                   (*_bfd_make_empty_symbol) (bfd *);
       void        (*_bfd_print_symbol) (bfd *, void *, struct bfd_symbol *,
                                         bfd_print_symbol_type);
     #define bfd_print_symbol(b,p,s,e) \
            BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
       void        (*_bfd_get_symbol_info) (bfd *, struct bfd_symbol *,
                                            symbol_info *);
     #define bfd_get_symbol_info(b,p,e) \
            BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))
       const char *(*_bfd_get_symbol_version_string) (bfd *, struct bfd_symbol *,
                                                      bfd_boolean *);
     #define bfd_get_symbol_version_string(b,s,h) \
            BFD_SEND (b, _bfd_get_symbol_version_string, (b,s,h))
       bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
       bfd_boolean (*_bfd_is_target_special_symbol) (bfd *, asymbol *);
       alent *     (*_get_lineno) (bfd *, struct bfd_symbol *);
       bfd_boolean (*_bfd_find_nearest_line) (bfd *, struct bfd_symbol **,
                                              struct bfd_section *, bfd_vma,
                                              const char **, const char **,
                                              unsigned int *, unsigned int *);
       bfd_boolean (*_bfd_find_line) (bfd *, struct bfd_symbol **,
                                      struct bfd_symbol *, const char **,
                                      unsigned int *);
       bfd_boolean (*_bfd_find_inliner_info)
         (bfd *, const char **, const char **, unsigned int *);
      /* Back-door to allow format-aware applications to create debug symbols
         while using BFD for everything else.  Currently used by the assembler
         when creating COFF files.  */
       asymbol *   (*_bfd_make_debug_symbol) (bfd *, void *, unsigned long size);
     #define bfd_read_minisymbols(b, d, m, s) \
            BFD_SEND (b, _read_minisymbols, (b, d, m, s))
       long        (*_read_minisymbols) (bfd *, bfd_boolean, void **,
                                         unsigned int *);
     #define bfd_minisymbol_to_symbol(b, d, m, f) \
            BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
       asymbol *   (*_minisymbol_to_symbol) (bfd *, bfd_boolean, const void *,
                                             asymbol *);

       /* Routines for relocs.  */
     #define BFD_JUMP_TABLE_RELOCS(NAME) \
       NAME##_get_reloc_upper_bound, \
       NAME##_canonicalize_reloc, \
       NAME##_set_reloc, \
       NAME##_bfd_reloc_type_lookup, \
       NAME##_bfd_reloc_name_lookup

       long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
       long        (*_bfd_canonicalize_reloc) (bfd *, sec_ptr, arelent **,
                                               struct bfd_symbol **);
       void        (*_bfd_set_reloc) (bfd *, sec_ptr, arelent **, unsigned int);
       /* See documentation on reloc types.  */
       reloc_howto_type *
                   (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
       reloc_howto_type *
                   (*reloc_name_lookup) (bfd *, const char *);

       /* Routines used when writing an object file.  */
     #define BFD_JUMP_TABLE_WRITE(NAME) \
       NAME##_set_arch_mach, \
       NAME##_set_section_contents

       bfd_boolean (*_bfd_set_arch_mach) (bfd *, enum bfd_architecture,
                                          unsigned long);
       bfd_boolean (*_bfd_set_section_contents) (bfd *, sec_ptr, const void *,
                                                 file_ptr, bfd_size_type);

       /* Routines used by the linker.  */
     #define BFD_JUMP_TABLE_LINK(NAME) \
       NAME##_sizeof_headers, \
       NAME##_bfd_get_relocated_section_contents, \
       NAME##_bfd_relax_section, \
       NAME##_bfd_link_hash_table_create, \
       NAME##_bfd_link_add_symbols, \
       NAME##_bfd_link_just_syms, \
       NAME##_bfd_copy_link_hash_symbol_type, \
       NAME##_bfd_final_link, \
       NAME##_bfd_link_split_section, \
       NAME##_bfd_link_check_relocs, \
       NAME##_bfd_gc_sections, \
       NAME##_bfd_lookup_section_flags, \
       NAME##_bfd_merge_sections, \
       NAME##_bfd_is_group_section, \
       NAME##_bfd_discard_group, \
       NAME##_section_already_linked, \
       NAME##_bfd_define_common_symbol, \
       NAME##_bfd_link_hide_symbol, \
       NAME##_bfd_define_start_stop

       int         (*_bfd_sizeof_headers) (bfd *, struct bfd_link_info *);
       bfd_byte *  (*_bfd_get_relocated_section_contents) (bfd *,
                                                           struct bfd_link_info *,
                                                           struct bfd_link_order *,
                                                           bfd_byte *, bfd_boolean,
                                                           struct bfd_symbol **);

       bfd_boolean (*_bfd_relax_section) (bfd *, struct bfd_section *,
                                          struct bfd_link_info *, bfd_boolean *);

       /* Create a hash table for the linker.  Different backends store
          different information in this table.  */
       struct bfd_link_hash_table *
                   (*_bfd_link_hash_table_create) (bfd *);

       /* Add symbols from this object file into the hash table.  */
       bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);

       /* Indicate that we are only retrieving symbol values from this section.  */
       void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);

       /* Copy the symbol type and other attributes for a linker script
          assignment of one symbol to another.  */
     #define bfd_copy_link_hash_symbol_type(b, t, f) \
            BFD_SEND (b, _bfd_copy_link_hash_symbol_type, (b, t, f))
       void        (*_bfd_copy_link_hash_symbol_type) (bfd *,
                                                       struct bfd_link_hash_entry *,
                                                       struct bfd_link_hash_entry *);

       /* Do a link based on the link_order structures attached to each
          section of the BFD.  */
       bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);

       /* Should this section be split up into smaller pieces during linking.  */
       bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);

       /* Check the relocations in the bfd for validity.  */
       bfd_boolean (* _bfd_link_check_relocs)(bfd *, struct bfd_link_info *);

       /* Remove sections that are not referenced from the output.  */
       bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);

       /* Sets the bitmask of allowed and disallowed section flags.  */
       bfd_boolean (*_bfd_lookup_section_flags) (struct bfd_link_info *,
                                                 struct flag_info *, asection *);

       /* Attempt to merge SEC_MERGE sections.  */
       bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);

       /* Is this section a member of a group?  */
       bfd_boolean (*_bfd_is_group_section) (bfd *, const struct bfd_section *);

       /* Discard members of a group.  */
       bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);

       /* Check if SEC has been already linked during a reloceatable or
          final link.  */
       bfd_boolean (*_section_already_linked) (bfd *, asection *,
                                               struct bfd_link_info *);

       /* Define a common symbol.  */
       bfd_boolean (*_bfd_define_common_symbol) (bfd *, struct bfd_link_info *,
                                                 struct bfd_link_hash_entry *);

       /* Hide a symbol.  */
       void (*_bfd_link_hide_symbol) (bfd *, struct bfd_link_info *,
                                      struct bfd_link_hash_entry *);

       /* Define a __start, __stop, .startof. or .sizeof. symbol.  */
       struct bfd_link_hash_entry *
                   (*_bfd_define_start_stop) (struct bfd_link_info *, const char *,
                                              asection *);

       /* Routines to handle dynamic symbols and relocs.  */
     #define BFD_JUMP_TABLE_DYNAMIC(NAME) \
       NAME##_get_dynamic_symtab_upper_bound, \
       NAME##_canonicalize_dynamic_symtab, \
       NAME##_get_synthetic_symtab, \
       NAME##_get_dynamic_reloc_upper_bound, \
       NAME##_canonicalize_dynamic_reloc

       /* Get the amount of memory required to hold the dynamic symbols.  */
       long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
       /* Read in the dynamic symbols.  */
       long        (*_bfd_canonicalize_dynamic_symtab) (bfd *, struct bfd_symbol **);
       /* Create synthetized symbols.  */
       long        (*_bfd_get_synthetic_symtab) (bfd *, long, struct bfd_symbol **,
                                                 long, struct bfd_symbol **,
                                                 struct bfd_symbol **);
       /* Get the amount of memory required to hold the dynamic relocs.  */
       long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
       /* Read in the dynamic relocs.  */
       long        (*_bfd_canonicalize_dynamic_reloc) (bfd *, arelent **,
                                                       struct bfd_symbol **);
   A pointer to an alternative bfd_target in case the current one is not
satisfactory.  This can happen when the target cpu supports both big
and little endian code, and target chosen by the linker has the wrong
endianness.  The function open_output() in ld/ldlang.c uses this field
to find an alternative output format that is suitable.
       /* Opposite endian version of this target.  */
       const struct bfd_target *alternative_target;

       /* Data for use by back-end routines, which isn't
          generic enough to belong in this structure.  */
       const void *backend_data;

     } bfd_target;

2.12.1.1 `bfd_set_default_target'
.................................

*Synopsis*
     bfd_boolean bfd_set_default_target (const char *name);
   *Description*
Set the default target vector to use when recognizing a BFD.  This
takes the name of the target, which may be a BFD target name or a
configuration triplet.

2.12.1.2 `bfd_find_target'
..........................

*Synopsis*
     const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);
   *Description*
Return a pointer to the transfer vector for the object target named
TARGET_NAME.  If TARGET_NAME is `NULL', choose the one in the
environment variable `GNUTARGET'; if that is null or not defined, then
choose the first entry in the target list.  Passing in the string
"default" or setting the environment variable to "default" will cause
the first entry in the target list to be returned, and
"target_defaulted" will be set in the BFD if ABFD isn't `NULL'.  This
causes `bfd_check_format' to loop over all the targets to find the one
that matches the file being read.

2.12.1.3 `bfd_get_target_info'
..............................

*Synopsis*
     const bfd_target *bfd_get_target_info (const char *target_name,
         bfd *abfd,
         bfd_boolean *is_bigendian,
         int *underscoring,
         const char **def_target_arch);
   *Description*
Return a pointer to the transfer vector for the object target named
TARGET_NAME.  If TARGET_NAME is `NULL', choose the one in the
environment variable `GNUTARGET'; if that is null or not defined, then
choose the first entry in the target list.  Passing in the string
"default" or setting the environment variable to "default" will cause
the first entry in the target list to be returned, and
"target_defaulted" will be set in the BFD if ABFD isn't `NULL'.  This
causes `bfd_check_format' to loop over all the targets to find the one
that matches the file being read.  If IS_BIGENDIAN is not `NULL', then
set this value to target's endian mode. True for big-endian, FALSE for
little-endian or for invalid target.  If UNDERSCORING is not `NULL',
then set this value to target's underscoring mode. Zero for
none-underscoring, -1 for invalid target, else the value of target
vector's symbol underscoring.  If DEF_TARGET_ARCH is not `NULL', then
set it to the architecture string specified by the target_name.

2.12.1.4 `bfd_target_list'
..........................

*Synopsis*
     const char ** bfd_target_list (void);
   *Description*
Return a freshly malloced NULL-terminated vector of the names of all
the valid BFD targets. Do not modify the names.

2.12.1.5 `bfd_iterate_over_targets'
...................................

*Synopsis*
     const bfd_target *bfd_iterate_over_targets
        (int (*func) (const bfd_target *, void *),
         void *data);
   *Description*
Call FUNC for each target in the list of BFD target vectors, passing
DATA to FUNC.  Stop iterating if FUNC returns a non-zero result, and
return that target vector.  Return NULL if FUNC always returns zero.

2.12.1.6 `bfd_flavour_name'
...........................

*Synopsis*
     const char *bfd_flavour_name (enum bfd_flavour flavour);
   *Description*
Return the string form of FLAVOUR.

